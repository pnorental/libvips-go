// Code generated by github.com/cshum/vipsgen from libvips 8.16.1; DO NOT EDIT.
package vips

// #include "vips.h"
import "C"
import (
	"runtime"
	"unsafe"
)


// vipsgenCMC2LCh vips_CMC2LCh transform LCh to CMC
func vipsgenCMC2LCh(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_CMC2LCh(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenCMYK2XYZ vips_CMYK2XYZ transform CMYK to XYZ
func vipsgenCMYK2XYZ(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_CMYK2XYZ(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenHSV2sRGB vips_HSV2sRGB transform HSV to sRGB
func vipsgenHSV2sRGB(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_HSV2sRGB(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenLCh2CMC vips_LCh2CMC transform LCh to CMC
func vipsgenLCh2CMC(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_LCh2CMC(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenLCh2Lab vips_LCh2Lab transform LCh to Lab
func vipsgenLCh2Lab(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_LCh2Lab(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenLab2LCh vips_Lab2LCh transform Lab to LCh
func vipsgenLab2LCh(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_Lab2LCh(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenLab2LabQ vips_Lab2LabQ transform float Lab to LabQ coding
func vipsgenLab2LabQ(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_Lab2LabQ(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenLab2LabS vips_Lab2LabS transform float Lab to signed short
func vipsgenLab2LabS(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_Lab2LabS(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenLab2XYZ vips_Lab2XYZ transform CIELAB to XYZ
func vipsgenLab2XYZ(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_Lab2XYZ(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenLab2XYZWithOptions vips_Lab2XYZ transform CIELAB to XYZ with optional arguments
func vipsgenLab2XYZWithOptions(in *C.VipsImage, temp []float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	ctemp, ctempLength, err := convertToDoubleArray(temp)
	if err != nil {
		return nil, err
	}
	if ctemp != nil {
		defer freeDoubleArray(ctemp)
	}
	if err := C.vipsgen_Lab2XYZ_with_options(in, &out, ctemp, ctempLength); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenLabQ2Lab vips_LabQ2Lab unpack a LabQ image to float Lab
func vipsgenLabQ2Lab(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_LabQ2Lab(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenLabQ2LabS vips_LabQ2LabS unpack a LabQ image to short Lab
func vipsgenLabQ2LabS(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_LabQ2LabS(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenLabQ2sRGB vips_LabQ2sRGB convert a LabQ image to sRGB
func vipsgenLabQ2sRGB(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_LabQ2sRGB(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenLabS2Lab vips_LabS2Lab transform signed short Lab to float
func vipsgenLabS2Lab(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_LabS2Lab(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenLabS2LabQ vips_LabS2LabQ transform short Lab to LabQ coding
func vipsgenLabS2LabQ(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_LabS2LabQ(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenXYZ2CMYK vips_XYZ2CMYK transform XYZ to CMYK
func vipsgenXYZ2CMYK(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_XYZ2CMYK(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenXYZ2Lab vips_XYZ2Lab transform XYZ to Lab
func vipsgenXYZ2Lab(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_XYZ2Lab(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenXYZ2LabWithOptions vips_XYZ2Lab transform XYZ to Lab with optional arguments
func vipsgenXYZ2LabWithOptions(in *C.VipsImage, temp []float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	ctemp, ctempLength, err := convertToDoubleArray(temp)
	if err != nil {
		return nil, err
	}
	if ctemp != nil {
		defer freeDoubleArray(ctemp)
	}
	if err := C.vipsgen_XYZ2Lab_with_options(in, &out, ctemp, ctempLength); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenXYZ2Yxy vips_XYZ2Yxy transform XYZ to Yxy
func vipsgenXYZ2Yxy(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_XYZ2Yxy(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenXYZ2scRGB vips_XYZ2scRGB transform XYZ to scRGB
func vipsgenXYZ2scRGB(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_XYZ2scRGB(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenYxy2XYZ vips_Yxy2XYZ transform Yxy to XYZ
func vipsgenYxy2XYZ(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_Yxy2XYZ(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenAbs vips_abs absolute value of an image
func vipsgenAbs(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_abs(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenAdd vips_add add two images
func vipsgenAdd(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_add(left, right, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenAddalpha vips_addalpha append an alpha channel
func vipsgenAddalpha(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_addalpha(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenAffine vips_affine affine transform of an image
func vipsgenAffine(in *C.VipsImage, a float64, b float64, c float64, d float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_affine(in, &out, C.double(a), C.double(b), C.double(c), C.double(d)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenAffineWithOptions vips_affine affine transform of an image with optional arguments
func vipsgenAffineWithOptions(in *C.VipsImage, a float64, b float64, c float64, d float64, interpolate *Interpolate, oarea []int, odx float64, ody float64, idx float64, idy float64, background []float64, premultiplied bool, extend Extend) (*C.VipsImage, error) {
	var out *C.VipsImage
	coarea, coareaLength, err := convertToIntArray(oarea)
	if err != nil {
		return nil, err
	}
	if coarea != nil {
		defer freeIntArray(coarea)
	}
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return nil, err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	if err := C.vipsgen_affine_with_options(in, &out, C.double(a), C.double(b), C.double(c), C.double(d), vipsInterpolateToC(interpolate), coarea, coareaLength, C.double(odx), C.double(ody), C.double(idx), C.double(idy), cbackground, cbackgroundLength, C.int(boolToInt(premultiplied)), C.VipsExtend(extend)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenAnalyzeload vips_analyzeload load an Analyze6 image
func vipsgenAnalyzeload(filename string) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_analyzeload(cfilename, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenAnalyzeloadWithOptions vips_analyzeload load an Analyze6 image with optional arguments
func vipsgenAnalyzeloadWithOptions(filename string, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_analyzeload_with_options(cfilename, &out, C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenArrayjoin vips_arrayjoin join an array of images
func vipsgenArrayjoin(in []*C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	cin, _, err := convertToImageArray(in)
	if err != nil {
		return nil, err
	}
	if cin != nil {
		defer freeImageArray(cin)
	}
	if err := C.vipsgen_arrayjoin((**C.VipsImage)(cin), &out, C.int(len(in))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenArrayjoinWithOptions vips_arrayjoin join an array of images with optional arguments
func vipsgenArrayjoinWithOptions(in []*C.VipsImage, across int, shim int, background []float64, halign Align, valign Align, hspacing int, vspacing int) (*C.VipsImage, error) {
	var out *C.VipsImage
	cin, _, err := convertToImageArray(in)
	if err != nil {
		return nil, err
	}
	if cin != nil {
		defer freeImageArray(cin)
	}
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return nil, err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	if err := C.vipsgen_arrayjoin_with_options(cin, &out, C.int(len(in)), C.int(across), C.int(shim), cbackground, cbackgroundLength, C.VipsAlign(halign), C.VipsAlign(valign), C.int(hspacing), C.int(vspacing)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenAutorot vips_autorot autorotate image by exif tag
func vipsgenAutorot(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_autorot(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenAvg vips_avg find image average
func vipsgenAvg(in *C.VipsImage) (float64, error) {
	var out float64
	cout := (*C.double)(unsafe.Pointer(&out))
	if err := C.vipsgen_avg(in, cout); err != 0 {
		return 0, handleVipsError()
	}
	return out, nil
}

// vipsgenBandbool vips_bandbool boolean operation across image bands
func vipsgenBandbool(in *C.VipsImage, boolean OperationBoolean) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_bandbool(in, &out, C.VipsOperationBoolean(boolean)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenBandfold vips_bandfold fold up x axis into bands
func vipsgenBandfold(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_bandfold(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenBandfoldWithOptions vips_bandfold fold up x axis into bands with optional arguments
func vipsgenBandfoldWithOptions(in *C.VipsImage, factor int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_bandfold_with_options(in, &out, C.int(factor)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenBandjoin vips_bandjoin bandwise join a set of images
func vipsgenBandjoin(in []*C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	cin, _, err := convertToImageArray(in)
	if err != nil {
		return nil, err
	}
	if cin != nil {
		defer freeImageArray(cin)
	}
	if err := C.vipsgen_bandjoin((**C.VipsImage)(cin), &out, C.int(len(in))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenBandjoinConst vips_bandjoin_const append a constant band to an image
func vipsgenBandjoinConst(in *C.VipsImage, c []float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	cc, _, err := convertToDoubleArray(c)
	if err != nil {
		return nil, err
	}
	if cc != nil {
		defer freeDoubleArray(cc)
	}
	if err := C.vipsgen_bandjoin_const(in, &out, cc, C.int(len(c))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenBandmean vips_bandmean band-wise average
func vipsgenBandmean(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_bandmean(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenBandrank vips_bandrank band-wise rank of a set of images
func vipsgenBandrank(in []*C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	cin, _, err := convertToImageArray(in)
	if err != nil {
		return nil, err
	}
	if cin != nil {
		defer freeImageArray(cin)
	}
	if err := C.vipsgen_bandrank((**C.VipsImage)(cin), &out, C.int(len(in))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenBandrankWithOptions vips_bandrank band-wise rank of a set of images with optional arguments
func vipsgenBandrankWithOptions(in []*C.VipsImage, index int) (*C.VipsImage, error) {
	var out *C.VipsImage
	cin, _, err := convertToImageArray(in)
	if err != nil {
		return nil, err
	}
	if cin != nil {
		defer freeImageArray(cin)
	}
	if err := C.vipsgen_bandrank_with_options(cin, &out, C.int(len(in)), C.int(index)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenBandunfold vips_bandunfold unfold image bands into x axis
func vipsgenBandunfold(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_bandunfold(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenBandunfoldWithOptions vips_bandunfold unfold image bands into x axis with optional arguments
func vipsgenBandunfoldWithOptions(in *C.VipsImage, factor int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_bandunfold_with_options(in, &out, C.int(factor)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenBlack vips_black make a black image
func vipsgenBlack(width int, height int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_black(&out, C.int(width), C.int(height)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenBlackWithOptions vips_black make a black image with optional arguments
func vipsgenBlackWithOptions(width int, height int, bands int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_black_with_options(&out, C.int(width), C.int(height), C.int(bands)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenBoolean vips_boolean boolean operation on two images
func vipsgenBoolean(left *C.VipsImage, right *C.VipsImage, boolean OperationBoolean) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_boolean(left, right, &out, C.VipsOperationBoolean(boolean)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenBooleanConst vips_boolean_const boolean operations against a constant
func vipsgenBooleanConst(in *C.VipsImage, boolean OperationBoolean, c []float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	cc, _, err := convertToDoubleArray(c)
	if err != nil {
		return nil, err
	}
	if cc != nil {
		defer freeDoubleArray(cc)
	}
	if err := C.vipsgen_boolean_const(in, &out, C.VipsOperationBoolean(boolean), cc, C.int(len(c))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenBuildlut vips_buildlut build a look-up table
func vipsgenBuildlut(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_buildlut(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenByteswap vips_byteswap byteswap an image
func vipsgenByteswap(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_byteswap(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenCanny vips_canny Canny edge detector
func vipsgenCanny(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_canny(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenCannyWithOptions vips_canny Canny edge detector with optional arguments
func vipsgenCannyWithOptions(in *C.VipsImage, sigma float64, precision Precision) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_canny_with_options(in, &out, C.double(sigma), C.VipsPrecision(precision)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenCase vips_case use pixel values to pick cases from an array of images
func vipsgenCase(index *C.VipsImage, cases []*C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	ccases, _, err := convertToImageArray(cases)
	if err != nil {
		return nil, err
	}
	if ccases != nil {
		defer freeImageArray(ccases)
	}
	if err := C.vipsgen_case(index, (**C.VipsImage)(ccases), &out, C.int(len(cases))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenCast vips_cast cast an image
func vipsgenCast(in *C.VipsImage, format BandFormat) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_cast(in, &out, C.VipsBandFormat(format)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenCastWithOptions vips_cast cast an image with optional arguments
func vipsgenCastWithOptions(in *C.VipsImage, format BandFormat, shift bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_cast_with_options(in, &out, C.VipsBandFormat(format), C.int(boolToInt(shift))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenClamp vips_clamp clamp values of an image
func vipsgenClamp(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_clamp(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenClampWithOptions vips_clamp clamp values of an image with optional arguments
func vipsgenClampWithOptions(in *C.VipsImage, min float64, max float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_clamp_with_options(in, &out, C.double(min), C.double(max)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenColourspace vips_colourspace convert to a new colorspace
func vipsgenColourspace(in *C.VipsImage, space Interpretation) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_colourspace(in, &out, C.VipsInterpretation(space)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenColourspaceWithOptions vips_colourspace convert to a new colorspace with optional arguments
func vipsgenColourspaceWithOptions(in *C.VipsImage, space Interpretation, sourceSpace Interpretation) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_colourspace_with_options(in, &out, C.VipsInterpretation(space), C.VipsInterpretation(sourceSpace)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenCompass vips_compass convolve with rotating mask
func vipsgenCompass(in *C.VipsImage, mask *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_compass(in, &out, mask); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenCompassWithOptions vips_compass convolve with rotating mask with optional arguments
func vipsgenCompassWithOptions(in *C.VipsImage, mask *C.VipsImage, times int, angle Angle45, combine Combine, precision Precision, layers int, cluster int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_compass_with_options(in, &out, mask, C.int(times), C.VipsAngle45(angle), C.VipsCombine(combine), C.VipsPrecision(precision), C.int(layers), C.int(cluster)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenComplex vips_complex perform a complex operation on an image
func vipsgenComplex(in *C.VipsImage, cmplx OperationComplex) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_complex(in, &out, C.VipsOperationComplex(cmplx)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenComplex2 vips_complex2 complex binary operations on two images
func vipsgenComplex2(left *C.VipsImage, right *C.VipsImage, cmplx OperationComplex2) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_complex2(left, right, &out, C.VipsOperationComplex2(cmplx)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenComplexform vips_complexform form a complex image from two real images
func vipsgenComplexform(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_complexform(left, right, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenComplexget vips_complexget get a component from a complex image
func vipsgenComplexget(in *C.VipsImage, get OperationComplexget) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_complexget(in, &out, C.VipsOperationComplexget(get)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenComposite vips_composite blend an array of images with an array of blend modes
func vipsgenComposite(in []*C.VipsImage, mode []BlendMode) (*C.VipsImage, error) {
	var out *C.VipsImage
	cin, _, err := convertToImageArray(in)
	if err != nil {
		return nil, err
	}
	if cin != nil {
		defer freeImageArray(cin)
	}
	cmode, _, err := convertToBlendModeArray(mode)
	if err != nil {
		return nil, err
	}
	if cmode != nil {
		defer freeIntArray(cmode)
	}
	if err := C.vipsgen_composite((**C.VipsImage)(cin), &out, C.int(len(in)), cmode); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenCompositeWithOptions vips_composite blend an array of images with an array of blend modes with optional arguments
func vipsgenCompositeWithOptions(in []*C.VipsImage, mode []BlendMode, x []int, y []int, compositingSpace Interpretation, premultiplied bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	cin, _, err := convertToImageArray(in)
	if err != nil {
		return nil, err
	}
	if cin != nil {
		defer freeImageArray(cin)
	}
	cmode, _, err := convertToBlendModeArray(mode)
	if err != nil {
		return nil, err
	}
	if cmode != nil {
		defer freeIntArray(cmode)
	}
	cx, cxLength, err := convertToIntArray(x)
	if err != nil {
		return nil, err
	}
	if cx != nil {
		defer freeIntArray(cx)
	}
	cy, cyLength, err := convertToIntArray(y)
	if err != nil {
		return nil, err
	}
	if cy != nil {
		defer freeIntArray(cy)
	}
	if err := C.vipsgen_composite_with_options(cin, &out, C.int(len(in)), cmode, cx, cxLength, cy, cyLength, C.VipsInterpretation(compositingSpace), C.int(boolToInt(premultiplied))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenComposite2 vips_composite2 blend a pair of images with a blend mode
func vipsgenComposite2(base *C.VipsImage, overlay *C.VipsImage, mode BlendMode) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_composite2(base, overlay, &out, C.VipsBlendMode(mode)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenComposite2WithOptions vips_composite2 blend a pair of images with a blend mode with optional arguments
func vipsgenComposite2WithOptions(base *C.VipsImage, overlay *C.VipsImage, mode BlendMode, x int, y int, compositingSpace Interpretation, premultiplied bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_composite2_with_options(base, overlay, &out, C.VipsBlendMode(mode), C.int(x), C.int(y), C.VipsInterpretation(compositingSpace), C.int(boolToInt(premultiplied))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenConv vips_conv convolution operation
func vipsgenConv(in *C.VipsImage, mask *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_conv(in, &out, mask); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenConvWithOptions vips_conv convolution operation with optional arguments
func vipsgenConvWithOptions(in *C.VipsImage, mask *C.VipsImage, precision Precision, layers int, cluster int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_conv_with_options(in, &out, mask, C.VipsPrecision(precision), C.int(layers), C.int(cluster)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenConva vips_conva approximate integer convolution
func vipsgenConva(in *C.VipsImage, mask *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_conva(in, &out, mask); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenConvaWithOptions vips_conva approximate integer convolution with optional arguments
func vipsgenConvaWithOptions(in *C.VipsImage, mask *C.VipsImage, layers int, cluster int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_conva_with_options(in, &out, mask, C.int(layers), C.int(cluster)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenConvasep vips_convasep approximate separable integer convolution
func vipsgenConvasep(in *C.VipsImage, mask *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_convasep(in, &out, mask); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenConvasepWithOptions vips_convasep approximate separable integer convolution with optional arguments
func vipsgenConvasepWithOptions(in *C.VipsImage, mask *C.VipsImage, layers int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_convasep_with_options(in, &out, mask, C.int(layers)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenConvf vips_convf float convolution operation
func vipsgenConvf(in *C.VipsImage, mask *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_convf(in, &out, mask); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenConvi vips_convi int convolution operation
func vipsgenConvi(in *C.VipsImage, mask *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_convi(in, &out, mask); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenConvsep vips_convsep separable convolution operation
func vipsgenConvsep(in *C.VipsImage, mask *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_convsep(in, &out, mask); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenConvsepWithOptions vips_convsep separable convolution operation with optional arguments
func vipsgenConvsepWithOptions(in *C.VipsImage, mask *C.VipsImage, precision Precision, layers int, cluster int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_convsep_with_options(in, &out, mask, C.VipsPrecision(precision), C.int(layers), C.int(cluster)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenCopy vips_copy copy an image
func vipsgenCopy(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_copy(in, &out); err != 0 {
		return nil, handleVipsError()
	}
	return out, nil
}

// vipsgenCopyWithOptions vips_copy copy an image with optional arguments
func vipsgenCopyWithOptions(in *C.VipsImage, width int, height int, bands int, format BandFormat, coding Coding, interpretation Interpretation, xres float64, yres float64, xoffset int, yoffset int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_copy_with_options(in, &out, C.int(width), C.int(height), C.int(bands), C.VipsBandFormat(format), C.VipsCoding(coding), C.VipsInterpretation(interpretation), C.double(xres), C.double(yres), C.int(xoffset), C.int(yoffset)); err != 0 {
		return nil, handleVipsError()
	}
	return out, nil
}

// vipsgenCountlines vips_countlines count lines in an image
func vipsgenCountlines(in *C.VipsImage, direction Direction) (float64, error) {
	var nolines float64
	cnolines := (*C.double)(unsafe.Pointer(&nolines))
	if err := C.vipsgen_countlines(in, cnolines, C.VipsDirection(direction)); err != 0 {
		return 0, handleVipsError()
	}
	return nolines, nil
}

// vipsgenCsvload vips_csvload load csv
func vipsgenCsvload(filename string) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_csvload(cfilename, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenCsvloadWithOptions vips_csvload load csv with optional arguments
func vipsgenCsvloadWithOptions(filename string, skip int, lines int, whitespace string, separator string, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	cwhitespace := C.CString(whitespace)
	defer freeCString(cwhitespace)
	cseparator := C.CString(separator)
	defer freeCString(cseparator)
	if err := C.vipsgen_csvload_with_options(cfilename, &out, C.int(skip), C.int(lines), cwhitespace, cseparator, C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenCsvloadSource vips_csvload_source load csv
func vipsgenCsvloadSource(source *C.VipsSourceCustom) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_csvload_source(source, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenCsvloadSourceWithOptions vips_csvload_source load csv with optional arguments
func vipsgenCsvloadSourceWithOptions(source *C.VipsSourceCustom, skip int, lines int, whitespace string, separator string, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	cwhitespace := C.CString(whitespace)
	defer freeCString(cwhitespace)
	cseparator := C.CString(separator)
	defer freeCString(cseparator)
	if err := C.vipsgen_csvload_source_with_options(source, &out, C.int(skip), C.int(lines), cwhitespace, cseparator, C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenCsvsave vips_csvsave save image to csv
func vipsgenCsvsave(in *C.VipsImage, filename string) (error) {
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_csvsave(in, cfilename); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenCsvsaveWithOptions vips_csvsave save image to csv with optional arguments
func vipsgenCsvsaveWithOptions(in *C.VipsImage, filename string, separator string, keep Keep, background []float64, pageHeight int, profile string) (error) {
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cseparator := C.CString(separator)
	defer freeCString(cseparator)
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_csvsave_with_options(in, cfilename, cseparator, C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenCsvsaveTarget vips_csvsave_target save image to csv
func vipsgenCsvsaveTarget(in *C.VipsImage, target *C.VipsTargetCustom) (error) {
	
	if err := C.vipsgen_csvsave_target(in, target); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenCsvsaveTargetWithOptions vips_csvsave_target save image to csv with optional arguments
func vipsgenCsvsaveTargetWithOptions(in *C.VipsImage, target *C.VipsTargetCustom, separator string, keep Keep, background []float64, pageHeight int, profile string) (error) {
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cseparator := C.CString(separator)
	defer freeCString(cseparator)
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_csvsave_target_with_options(in, target, cseparator, C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenDE00 vips_dE00 calculate dE00
func vipsgenDE00(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_dE00(left, right, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenDE76 vips_dE76 calculate dE76
func vipsgenDE76(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_dE76(left, right, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenDECMC vips_dECMC calculate dECMC
func vipsgenDECMC(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_dECMC(left, right, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenDeviate vips_deviate find image standard deviation
func vipsgenDeviate(in *C.VipsImage) (float64, error) {
	var out float64
	cout := (*C.double)(unsafe.Pointer(&out))
	if err := C.vipsgen_deviate(in, cout); err != 0 {
		return 0, handleVipsError()
	}
	return out, nil
}

// vipsgenDivide vips_divide divide two images
func vipsgenDivide(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_divide(left, right, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenDrawCircle vips_draw_circle draw a circle on an image
func vipsgenDrawCircle(image *C.VipsImage, ink []float64, cx int, cy int, radius int) (error) {
	cink, _, err := convertToDoubleArray(ink)
	if err != nil {
		return err
	}
	if cink != nil {
		defer freeDoubleArray(cink)
	}
	if err := C.vipsgen_draw_circle(image, cink, C.int(len(ink)), C.int(cx), C.int(cy), C.int(radius)); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenDrawCircleWithOptions vips_draw_circle draw a circle on an image with optional arguments
func vipsgenDrawCircleWithOptions(image *C.VipsImage, ink []float64, cx int, cy int, radius int, fill bool) (error) {
	cink, _, err := convertToDoubleArray(ink)
	if err != nil {
		return err
	}
	if cink != nil {
		defer freeDoubleArray(cink)
	}
	if err := C.vipsgen_draw_circle_with_options(image, cink, C.int(len(ink)), C.int(cx), C.int(cy), C.int(radius), C.int(boolToInt(fill))); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenDrawFlood vips_draw_flood flood-fill an area
func vipsgenDrawFlood(image *C.VipsImage, ink []float64, x int, y int) (error) {
	cink, _, err := convertToDoubleArray(ink)
	if err != nil {
		return err
	}
	if cink != nil {
		defer freeDoubleArray(cink)
	}
	if err := C.vipsgen_draw_flood(image, cink, C.int(len(ink)), C.int(x), C.int(y)); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenDrawFloodWithOptions vips_draw_flood flood-fill an area with optional arguments
func vipsgenDrawFloodWithOptions(image *C.VipsImage, ink []float64, x int, y int, test *C.VipsImage, equal bool) (error) {
	cink, _, err := convertToDoubleArray(ink)
	if err != nil {
		return err
	}
	if cink != nil {
		defer freeDoubleArray(cink)
	}
	if err := C.vipsgen_draw_flood_with_options(image, cink, C.int(len(ink)), C.int(x), C.int(y), test, C.int(boolToInt(equal))); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenDrawImage vips_draw_image paint an image into another image
func vipsgenDrawImage(image *C.VipsImage, sub *C.VipsImage, x int, y int) (error) {
	
	if err := C.vipsgen_draw_image(image, sub, C.int(x), C.int(y)); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenDrawImageWithOptions vips_draw_image paint an image into another image with optional arguments
func vipsgenDrawImageWithOptions(image *C.VipsImage, sub *C.VipsImage, x int, y int, mode CombineMode) (error) {
	
	if err := C.vipsgen_draw_image_with_options(image, sub, C.int(x), C.int(y), C.VipsCombineMode(mode)); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenDrawLine vips_draw_line draw a line on an image
func vipsgenDrawLine(image *C.VipsImage, ink []float64, x1 int, y1 int, x2 int, y2 int) (error) {
	cink, _, err := convertToDoubleArray(ink)
	if err != nil {
		return err
	}
	if cink != nil {
		defer freeDoubleArray(cink)
	}
	if err := C.vipsgen_draw_line(image, cink, C.int(len(ink)), C.int(x1), C.int(y1), C.int(x2), C.int(y2)); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenDrawMask vips_draw_mask draw a mask on an image
func vipsgenDrawMask(image *C.VipsImage, ink []float64, mask *C.VipsImage, x int, y int) (error) {
	cink, _, err := convertToDoubleArray(ink)
	if err != nil {
		return err
	}
	if cink != nil {
		defer freeDoubleArray(cink)
	}
	if err := C.vipsgen_draw_mask(image, cink, C.int(len(ink)), mask, C.int(x), C.int(y)); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenDrawRect vips_draw_rect paint a rectangle on an image
func vipsgenDrawRect(image *C.VipsImage, ink []float64, left int, top int, width int, height int) (error) {
	cink, _, err := convertToDoubleArray(ink)
	if err != nil {
		return err
	}
	if cink != nil {
		defer freeDoubleArray(cink)
	}
	if err := C.vipsgen_draw_rect(image, cink, C.int(len(ink)), C.int(left), C.int(top), C.int(width), C.int(height)); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenDrawRectWithOptions vips_draw_rect paint a rectangle on an image with optional arguments
func vipsgenDrawRectWithOptions(image *C.VipsImage, ink []float64, left int, top int, width int, height int, fill bool) (error) {
	cink, _, err := convertToDoubleArray(ink)
	if err != nil {
		return err
	}
	if cink != nil {
		defer freeDoubleArray(cink)
	}
	if err := C.vipsgen_draw_rect_with_options(image, cink, C.int(len(ink)), C.int(left), C.int(top), C.int(width), C.int(height), C.int(boolToInt(fill))); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenDrawSmudge vips_draw_smudge blur a rectangle on an image
func vipsgenDrawSmudge(image *C.VipsImage, left int, top int, width int, height int) (error) {
	
	if err := C.vipsgen_draw_smudge(image, C.int(left), C.int(top), C.int(width), C.int(height)); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenEmbed vips_embed embed an image in a larger image
func vipsgenEmbed(in *C.VipsImage, x int, y int, width int, height int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_embed(in, &out, C.int(x), C.int(y), C.int(width), C.int(height)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenEmbedWithOptions vips_embed embed an image in a larger image with optional arguments
func vipsgenEmbedWithOptions(in *C.VipsImage, x int, y int, width int, height int, extend Extend, background []float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return nil, err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	if err := C.vipsgen_embed_with_options(in, &out, C.int(x), C.int(y), C.int(width), C.int(height), C.VipsExtend(extend), cbackground, cbackgroundLength); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenExtractArea vips_extract_area extract an area from an image
func vipsgenExtractArea(input *C.VipsImage, left int, top int, width int, height int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_extract_area(input, &out, C.int(left), C.int(top), C.int(width), C.int(height)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenExtractBand vips_extract_band extract band from an image
func vipsgenExtractBand(in *C.VipsImage, band int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_extract_band(in, &out, C.int(band)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenExtractBandWithOptions vips_extract_band extract band from an image with optional arguments
func vipsgenExtractBandWithOptions(in *C.VipsImage, band int, n int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_extract_band_with_options(in, &out, C.int(band), C.int(n)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenEye vips_eye make an image showing the eye's spatial response
func vipsgenEye(width int, height int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_eye(&out, C.int(width), C.int(height)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenEyeWithOptions vips_eye make an image showing the eye's spatial response with optional arguments
func vipsgenEyeWithOptions(width int, height int, uchar bool, factor float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_eye_with_options(&out, C.int(width), C.int(height), C.int(boolToInt(uchar)), C.double(factor)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenFalsecolour vips_falsecolour false-color an image
func vipsgenFalsecolour(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_falsecolour(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenFastcor vips_fastcor fast correlation
func vipsgenFastcor(in *C.VipsImage, ref *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_fastcor(in, ref, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenFillNearest vips_fill_nearest fill image zeros with nearest non-zero pixel
func vipsgenFillNearest(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_fill_nearest(in, &out); err != 0 {
		return nil, handleVipsError()
	}
	return out, nil
}

// vipsgenFindTrim vips_find_trim search an image for non-edge areas
func vipsgenFindTrim(in *C.VipsImage) (int, int, int, int, error) {
	var left int
	cleft := (*C.int)(unsafe.Pointer(&left))
	var top int
	ctop := (*C.int)(unsafe.Pointer(&top))
	var width int
	cwidth := (*C.int)(unsafe.Pointer(&width))
	var height int
	cheight := (*C.int)(unsafe.Pointer(&height))
	if err := C.vipsgen_find_trim(in, cleft, ctop, cwidth, cheight); err != 0 {
		return 0, 0, 0, 0, handleVipsError()
	}
	return left, top, width, height, nil
}

// vipsgenFindTrimWithOptions vips_find_trim search an image for non-edge areas with optional arguments
func vipsgenFindTrimWithOptions(in *C.VipsImage, threshold float64, background []float64, lineArt bool) (int, int, int, int, error) {
	var left int
	cleft := (*C.int)(unsafe.Pointer(&left))
	var top int
	ctop := (*C.int)(unsafe.Pointer(&top))
	var width int
	cwidth := (*C.int)(unsafe.Pointer(&width))
	var height int
	cheight := (*C.int)(unsafe.Pointer(&height))
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return 0, 0, 0, 0, err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	if err := C.vipsgen_find_trim_with_options(in, cleft, ctop, cwidth, cheight, C.double(threshold), cbackground, cbackgroundLength, C.int(boolToInt(lineArt))); err != 0 {
		return 0, 0, 0, 0, handleVipsError()
	}
	return left, top, width, height, nil
}

// vipsgenFlatten vips_flatten flatten alpha out of an image
func vipsgenFlatten(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_flatten(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenFlattenWithOptions vips_flatten flatten alpha out of an image with optional arguments
func vipsgenFlattenWithOptions(in *C.VipsImage, background []float64, maxAlpha float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return nil, err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	if err := C.vipsgen_flatten_with_options(in, &out, cbackground, cbackgroundLength, C.double(maxAlpha)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenFlip vips_flip flip an image
func vipsgenFlip(in *C.VipsImage, direction Direction) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_flip(in, &out, C.VipsDirection(direction)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenFloat2rad vips_float2rad transform float RGB to Radiance coding
func vipsgenFloat2rad(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_float2rad(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenFractsurf vips_fractsurf make a fractal surface
func vipsgenFractsurf(width int, height int, fractalDimension float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_fractsurf(&out, C.int(width), C.int(height), C.double(fractalDimension)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenFreqmult vips_freqmult frequency-domain filtering
func vipsgenFreqmult(in *C.VipsImage, mask *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_freqmult(in, mask, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenGamma vips_gamma gamma an image
func vipsgenGamma(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_gamma(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenGammaWithOptions vips_gamma gamma an image with optional arguments
func vipsgenGammaWithOptions(in *C.VipsImage, exponent float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_gamma_with_options(in, &out, C.double(exponent)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenGaussblur vips_gaussblur gaussian blur
func vipsgenGaussblur(in *C.VipsImage, sigma float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_gaussblur(in, &out, C.double(sigma)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenGaussblurWithOptions vips_gaussblur gaussian blur with optional arguments
func vipsgenGaussblurWithOptions(in *C.VipsImage, sigma float64, minAmpl float64, precision Precision) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_gaussblur_with_options(in, &out, C.double(sigma), C.double(minAmpl), C.VipsPrecision(precision)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenGaussmat vips_gaussmat make a gaussian image
func vipsgenGaussmat(sigma float64, minAmpl float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_gaussmat(&out, C.double(sigma), C.double(minAmpl)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenGaussmatWithOptions vips_gaussmat make a gaussian image with optional arguments
func vipsgenGaussmatWithOptions(sigma float64, minAmpl float64, separable bool, precision Precision) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_gaussmat_with_options(&out, C.double(sigma), C.double(minAmpl), C.int(boolToInt(separable)), C.VipsPrecision(precision)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenGaussnoise vips_gaussnoise make a gaussnoise image
func vipsgenGaussnoise(width int, height int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_gaussnoise(&out, C.int(width), C.int(height)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenGaussnoiseWithOptions vips_gaussnoise make a gaussnoise image with optional arguments
func vipsgenGaussnoiseWithOptions(width int, height int, sigma float64, mean float64, seed int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_gaussnoise_with_options(&out, C.int(width), C.int(height), C.double(sigma), C.double(mean), C.int(seed)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenGetpoint vips_getpoint read a point from an image
func vipsgenGetpoint(in *C.VipsImage, x int, y int) ([]float64, error) {
	var out *C.double
	defer gFreePointer(unsafe.Pointer(out))
	var n int
	cn := (*C.int)(unsafe.Pointer(&n))
	if err := C.vipsgen_getpoint(in, &out, cn, C.int(x), C.int(y)); err != 0 {
		return nil, handleVipsError()
	}
	return (*[1024]float64)(unsafe.Pointer(out))[:n:n], nil
}

// vipsgenGetpointWithOptions vips_getpoint read a point from an image with optional arguments
func vipsgenGetpointWithOptions(in *C.VipsImage, x int, y int, unpackComplex bool) ([]float64, error) {
	var out *C.double
	defer gFreePointer(unsafe.Pointer(out))
	var n int
	cn := (*C.int)(unsafe.Pointer(&n))
	if err := C.vipsgen_getpoint_with_options(in, &out, cn, C.int(x), C.int(y), C.int(boolToInt(unpackComplex))); err != 0 {
		return nil, handleVipsError()
	}
	return (*[1024]float64)(unsafe.Pointer(out))[:n:n], nil
}

// vipsgenGifload vips_gifload load GIF with libnsgif
func vipsgenGifload(filename string) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_gifload(cfilename, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenGifloadWithOptions vips_gifload load GIF with libnsgif with optional arguments
func vipsgenGifloadWithOptions(filename string, n int, page int, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_gifload_with_options(cfilename, &out, C.int(n), C.int(page), C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenGifloadBuffer vips_gifload_buffer load GIF with libnsgif
func vipsgenGifloadBuffer(buf []byte) (*C.VipsImage, error) {
	src := buf
	// Reference src here so it's not garbage collected during image initialization.
	defer runtime.KeepAlive(src)
	var out *C.VipsImage
	if err := C.vipsgen_gifload_buffer(unsafe.Pointer(&src[0]), C.size_t(len(src)), &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenGifloadBufferWithOptions vips_gifload_buffer load GIF with libnsgif with optional arguments
func vipsgenGifloadBufferWithOptions(buf []byte, n int, page int, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	src := buf
	// Reference src here so it's not garbage collected during image initialization.
	defer runtime.KeepAlive(src)
	var out *C.VipsImage
	if err := C.vipsgen_gifload_buffer_with_options(unsafe.Pointer(&src[0]), C.size_t(len(src)), &out, C.int(n), C.int(page), C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenGifloadSource vips_gifload_source load gif from source
func vipsgenGifloadSource(source *C.VipsSourceCustom) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_gifload_source(source, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenGifloadSourceWithOptions vips_gifload_source load gif from source with optional arguments
func vipsgenGifloadSourceWithOptions(source *C.VipsSourceCustom, n int, page int, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_gifload_source_with_options(source, &out, C.int(n), C.int(page), C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenGlobalbalance vips_globalbalance global balance an image mosaic
func vipsgenGlobalbalance(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_globalbalance(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenGlobalbalanceWithOptions vips_globalbalance global balance an image mosaic with optional arguments
func vipsgenGlobalbalanceWithOptions(in *C.VipsImage, gamma float64, intOutput bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_globalbalance_with_options(in, &out, C.double(gamma), C.int(boolToInt(intOutput))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenGravity vips_gravity place an image within a larger image with a certain gravity
func vipsgenGravity(in *C.VipsImage, direction CompassDirection, width int, height int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_gravity(in, &out, C.VipsCompassDirection(direction), C.int(width), C.int(height)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenGravityWithOptions vips_gravity place an image within a larger image with a certain gravity with optional arguments
func vipsgenGravityWithOptions(in *C.VipsImage, direction CompassDirection, width int, height int, extend Extend, background []float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return nil, err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	if err := C.vipsgen_gravity_with_options(in, &out, C.VipsCompassDirection(direction), C.int(width), C.int(height), C.VipsExtend(extend), cbackground, cbackgroundLength); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenGrey vips_grey make a grey ramp image
func vipsgenGrey(width int, height int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_grey(&out, C.int(width), C.int(height)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenGreyWithOptions vips_grey make a grey ramp image with optional arguments
func vipsgenGreyWithOptions(width int, height int, uchar bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_grey_with_options(&out, C.int(width), C.int(height), C.int(boolToInt(uchar))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenGrid vips_grid grid an image
func vipsgenGrid(in *C.VipsImage, tileHeight int, across int, down int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_grid(in, &out, C.int(tileHeight), C.int(across), C.int(down)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenHistCum vips_hist_cum form cumulative histogram
func vipsgenHistCum(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_hist_cum(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenHistEntropy vips_hist_entropy estimate image entropy
func vipsgenHistEntropy(in *C.VipsImage) (float64, error) {
	var out float64
	cout := (*C.double)(unsafe.Pointer(&out))
	if err := C.vipsgen_hist_entropy(in, cout); err != 0 {
		return 0, handleVipsError()
	}
	return out, nil
}

// vipsgenHistEqual vips_hist_equal histogram equalisation
func vipsgenHistEqual(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_hist_equal(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenHistEqualWithOptions vips_hist_equal histogram equalisation with optional arguments
func vipsgenHistEqualWithOptions(in *C.VipsImage, band int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_hist_equal_with_options(in, &out, C.int(band)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenHistFind vips_hist_find find image histogram
func vipsgenHistFind(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_hist_find(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenHistFindWithOptions vips_hist_find find image histogram with optional arguments
func vipsgenHistFindWithOptions(in *C.VipsImage, band int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_hist_find_with_options(in, &out, C.int(band)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenHistFindIndexed vips_hist_find_indexed find indexed image histogram
func vipsgenHistFindIndexed(in *C.VipsImage, index *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_hist_find_indexed(in, index, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenHistFindIndexedWithOptions vips_hist_find_indexed find indexed image histogram with optional arguments
func vipsgenHistFindIndexedWithOptions(in *C.VipsImage, index *C.VipsImage, combine Combine) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_hist_find_indexed_with_options(in, index, &out, C.VipsCombine(combine)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenHistFindNdim vips_hist_find_ndim find n-dimensional image histogram
func vipsgenHistFindNdim(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_hist_find_ndim(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenHistFindNdimWithOptions vips_hist_find_ndim find n-dimensional image histogram with optional arguments
func vipsgenHistFindNdimWithOptions(in *C.VipsImage, bins int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_hist_find_ndim_with_options(in, &out, C.int(bins)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenHistIsmonotonic vips_hist_ismonotonic test for monotonicity
func vipsgenHistIsmonotonic(in *C.VipsImage) (bool, error) {
	var monotonic bool
	cmonotonic := (*C.int)(unsafe.Pointer(&monotonic))
	if err := C.vipsgen_hist_ismonotonic(in, cmonotonic); err != 0 {
		return false, handleVipsError()
	}
	return monotonic, nil
}

// vipsgenHistLocal vips_hist_local local histogram equalisation
func vipsgenHistLocal(in *C.VipsImage, width int, height int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_hist_local(in, &out, C.int(width), C.int(height)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenHistLocalWithOptions vips_hist_local local histogram equalisation with optional arguments
func vipsgenHistLocalWithOptions(in *C.VipsImage, width int, height int, maxSlope int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_hist_local_with_options(in, &out, C.int(width), C.int(height), C.int(maxSlope)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenHistMatch vips_hist_match match two histograms
func vipsgenHistMatch(in *C.VipsImage, ref *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_hist_match(in, ref, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenHistNorm vips_hist_norm normalise histogram
func vipsgenHistNorm(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_hist_norm(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenHistPlot vips_hist_plot plot histogram
func vipsgenHistPlot(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_hist_plot(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenHoughCircle vips_hough_circle find hough circle transform
func vipsgenHoughCircle(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_hough_circle(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenHoughCircleWithOptions vips_hough_circle find hough circle transform with optional arguments
func vipsgenHoughCircleWithOptions(in *C.VipsImage, scale int, minRadius int, maxRadius int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_hough_circle_with_options(in, &out, C.int(scale), C.int(minRadius), C.int(maxRadius)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenHoughLine vips_hough_line find hough line transform
func vipsgenHoughLine(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_hough_line(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenHoughLineWithOptions vips_hough_line find hough line transform with optional arguments
func vipsgenHoughLineWithOptions(in *C.VipsImage, width int, height int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_hough_line_with_options(in, &out, C.int(width), C.int(height)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenIdentity vips_identity make a 1D image where pixel values are indexes
func vipsgenIdentity() (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_identity(&out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenIdentityWithOptions vips_identity make a 1D image where pixel values are indexes with optional arguments
func vipsgenIdentityWithOptions(bands int, ushort bool, size int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_identity_with_options(&out, C.int(bands), C.int(boolToInt(ushort)), C.int(size)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenIfthenelse vips_ifthenelse ifthenelse an image
func vipsgenIfthenelse(cond *C.VipsImage, in1 *C.VipsImage, in2 *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_ifthenelse(cond, in1, in2, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenIfthenelseWithOptions vips_ifthenelse ifthenelse an image with optional arguments
func vipsgenIfthenelseWithOptions(cond *C.VipsImage, in1 *C.VipsImage, in2 *C.VipsImage, blend bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_ifthenelse_with_options(cond, in1, in2, &out, C.int(boolToInt(blend))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenInsert vips_insert insert image @sub into @main at @x, @y
func vipsgenInsert(main *C.VipsImage, sub *C.VipsImage, x int, y int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_insert(main, sub, &out, C.int(x), C.int(y)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenInsertWithOptions vips_insert insert image @sub into @main at @x, @y with optional arguments
func vipsgenInsertWithOptions(main *C.VipsImage, sub *C.VipsImage, x int, y int, expand bool, background []float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return nil, err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	if err := C.vipsgen_insert_with_options(main, sub, &out, C.int(x), C.int(y), C.int(boolToInt(expand)), cbackground, cbackgroundLength); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenInvert vips_invert invert an image
func vipsgenInvert(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_invert(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenInvertlut vips_invertlut build an inverted look-up table
func vipsgenInvertlut(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_invertlut(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenInvertlutWithOptions vips_invertlut build an inverted look-up table with optional arguments
func vipsgenInvertlutWithOptions(in *C.VipsImage, size int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_invertlut_with_options(in, &out, C.int(size)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenJoin vips_join join a pair of images
func vipsgenJoin(in1 *C.VipsImage, in2 *C.VipsImage, direction Direction) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_join(in1, in2, &out, C.VipsDirection(direction)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenJoinWithOptions vips_join join a pair of images with optional arguments
func vipsgenJoinWithOptions(in1 *C.VipsImage, in2 *C.VipsImage, direction Direction, expand bool, shim int, background []float64, align Align) (*C.VipsImage, error) {
	var out *C.VipsImage
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return nil, err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	if err := C.vipsgen_join_with_options(in1, in2, &out, C.VipsDirection(direction), C.int(boolToInt(expand)), C.int(shim), cbackground, cbackgroundLength, C.VipsAlign(align)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenJpegload vips_jpegload load jpeg from file
func vipsgenJpegload(filename string) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_jpegload(cfilename, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenJpegloadWithOptions vips_jpegload load jpeg from file with optional arguments
func vipsgenJpegloadWithOptions(filename string, shrink int, autorotate bool, unlimited bool, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_jpegload_with_options(cfilename, &out, C.int(shrink), C.int(boolToInt(autorotate)), C.int(boolToInt(unlimited)), C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenJpegloadBuffer vips_jpegload_buffer load jpeg from buffer
func vipsgenJpegloadBuffer(buf []byte) (*C.VipsImage, error) {
	src := buf
	// Reference src here so it's not garbage collected during image initialization.
	defer runtime.KeepAlive(src)
	var out *C.VipsImage
	if err := C.vipsgen_jpegload_buffer(unsafe.Pointer(&src[0]), C.size_t(len(src)), &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenJpegloadBufferWithOptions vips_jpegload_buffer load jpeg from buffer with optional arguments
func vipsgenJpegloadBufferWithOptions(buf []byte, shrink int, autorotate bool, unlimited bool, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	src := buf
	// Reference src here so it's not garbage collected during image initialization.
	defer runtime.KeepAlive(src)
	var out *C.VipsImage
	if err := C.vipsgen_jpegload_buffer_with_options(unsafe.Pointer(&src[0]), C.size_t(len(src)), &out, C.int(shrink), C.int(boolToInt(autorotate)), C.int(boolToInt(unlimited)), C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenJpegloadSource vips_jpegload_source load image from jpeg source
func vipsgenJpegloadSource(source *C.VipsSourceCustom) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_jpegload_source(source, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenJpegloadSourceWithOptions vips_jpegload_source load image from jpeg source with optional arguments
func vipsgenJpegloadSourceWithOptions(source *C.VipsSourceCustom, shrink int, autorotate bool, unlimited bool, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_jpegload_source_with_options(source, &out, C.int(shrink), C.int(boolToInt(autorotate)), C.int(boolToInt(unlimited)), C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenJpegsave vips_jpegsave save image to jpeg file
func vipsgenJpegsave(in *C.VipsImage, filename string) (error) {
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_jpegsave(in, cfilename); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenJpegsaveWithOptions vips_jpegsave save image to jpeg file with optional arguments
func vipsgenJpegsaveWithOptions(in *C.VipsImage, filename string, q int, optimizeCoding bool, interlace bool, trellisQuant bool, overshootDeringing bool, optimizeScans bool, quantTable int, subsampleMode Subsample, restartInterval int, keep Keep, background []float64, pageHeight int, profile string) (error) {
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_jpegsave_with_options(in, cfilename, C.int(q), C.int(boolToInt(optimizeCoding)), C.int(boolToInt(interlace)), C.int(boolToInt(trellisQuant)), C.int(boolToInt(overshootDeringing)), C.int(boolToInt(optimizeScans)), C.int(quantTable), C.VipsForeignSubsample(subsampleMode), C.int(restartInterval), C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenJpegsaveBuffer vips_jpegsave_buffer save image to jpeg buffer
func vipsgenJpegsaveBuffer(in *C.VipsImage) ([]byte, error) {
	var buf unsafe.Pointer
	var length C.size_t
	if err := C.vipsgen_jpegsave_buffer(in, &buf, &length); err != 0 {
		return nil, handleVipsError()
	}
	return bufferToBytes(buf, length), nil
}

// vipsgenJpegsaveBufferWithOptions vips_jpegsave_buffer save image to jpeg buffer with optional arguments
func vipsgenJpegsaveBufferWithOptions(in *C.VipsImage, q int, optimizeCoding bool, interlace bool, trellisQuant bool, overshootDeringing bool, optimizeScans bool, quantTable int, subsampleMode Subsample, restartInterval int, keep Keep, background []float64, pageHeight int, profile string) ([]byte, error) {
	var buf unsafe.Pointer
	var length C.size_t
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return nil, err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_jpegsave_buffer_with_options(in, &buf, &length, C.int(q), C.int(boolToInt(optimizeCoding)), C.int(boolToInt(interlace)), C.int(boolToInt(trellisQuant)), C.int(boolToInt(overshootDeringing)), C.int(boolToInt(optimizeScans)), C.int(quantTable), C.VipsForeignSubsample(subsampleMode), C.int(restartInterval), C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return nil, handleVipsError()
	}
	return bufferToBytes(buf, length), nil
}

// vipsgenJpegsaveTarget vips_jpegsave_target save image to jpeg target
func vipsgenJpegsaveTarget(in *C.VipsImage, target *C.VipsTargetCustom) (error) {
	
	if err := C.vipsgen_jpegsave_target(in, target); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenJpegsaveTargetWithOptions vips_jpegsave_target save image to jpeg target with optional arguments
func vipsgenJpegsaveTargetWithOptions(in *C.VipsImage, target *C.VipsTargetCustom, q int, optimizeCoding bool, interlace bool, trellisQuant bool, overshootDeringing bool, optimizeScans bool, quantTable int, subsampleMode Subsample, restartInterval int, keep Keep, background []float64, pageHeight int, profile string) (error) {
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_jpegsave_target_with_options(in, target, C.int(q), C.int(boolToInt(optimizeCoding)), C.int(boolToInt(interlace)), C.int(boolToInt(trellisQuant)), C.int(boolToInt(overshootDeringing)), C.int(boolToInt(optimizeScans)), C.int(quantTable), C.VipsForeignSubsample(subsampleMode), C.int(restartInterval), C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenLabelregions vips_labelregions label regions in an image
func vipsgenLabelregions(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_labelregions(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenLinear vips_linear calculate (a * in + b)
func vipsgenLinear(in *C.VipsImage, a []float64, b []float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	ca, _, err := convertToDoubleArray(a)
	if err != nil {
		return nil, err
	}
	if ca != nil {
		defer freeDoubleArray(ca)
	}
	cb, _, err := convertToDoubleArray(b)
	if err != nil {
		return nil, err
	}
	if cb != nil {
		defer freeDoubleArray(cb)
	}
	if err := C.vipsgen_linear(in, &out, ca, cb, C.int(len(a))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenLinearWithOptions vips_linear calculate (a * in + b) with optional arguments
func vipsgenLinearWithOptions(in *C.VipsImage, a []float64, b []float64, uchar bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	ca, _, err := convertToDoubleArray(a)
	if err != nil {
		return nil, err
	}
	if ca != nil {
		defer freeDoubleArray(ca)
	}
	cb, _, err := convertToDoubleArray(b)
	if err != nil {
		return nil, err
	}
	if cb != nil {
		defer freeDoubleArray(cb)
	}
	if err := C.vipsgen_linear_with_options(in, &out, ca, cb, C.int(len(a)), C.int(boolToInt(uchar))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenLinecache vips_linecache cache an image as a set of lines
func vipsgenLinecache(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_linecache(in, &out); err != 0 {
		return nil, handleVipsError()
	}
	return out, nil
}

// vipsgenLinecacheWithOptions vips_linecache cache an image as a set of lines with optional arguments
func vipsgenLinecacheWithOptions(in *C.VipsImage, tileHeight int, access Access, threaded bool, persistent bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_linecache_with_options(in, &out, C.int(tileHeight), C.VipsAccess(access), C.int(boolToInt(threaded)), C.int(boolToInt(persistent))); err != 0 {
		return nil, handleVipsError()
	}
	return out, nil
}

// vipsgenLogmat vips_logmat make a Laplacian of Gaussian image
func vipsgenLogmat(sigma float64, minAmpl float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_logmat(&out, C.double(sigma), C.double(minAmpl)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenLogmatWithOptions vips_logmat make a Laplacian of Gaussian image with optional arguments
func vipsgenLogmatWithOptions(sigma float64, minAmpl float64, separable bool, precision Precision) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_logmat_with_options(&out, C.double(sigma), C.double(minAmpl), C.int(boolToInt(separable)), C.VipsPrecision(precision)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMapim vips_mapim resample with a map image
func vipsgenMapim(in *C.VipsImage, index *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mapim(in, &out, index); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMapimWithOptions vips_mapim resample with a map image with optional arguments
func vipsgenMapimWithOptions(in *C.VipsImage, index *C.VipsImage, interpolate *Interpolate, background []float64, premultiplied bool, extend Extend) (*C.VipsImage, error) {
	var out *C.VipsImage
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return nil, err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	if err := C.vipsgen_mapim_with_options(in, &out, index, vipsInterpolateToC(interpolate), cbackground, cbackgroundLength, C.int(boolToInt(premultiplied)), C.VipsExtend(extend)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaplut vips_maplut map an image though a lut
func vipsgenMaplut(in *C.VipsImage, lut *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_maplut(in, &out, lut); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaplutWithOptions vips_maplut map an image though a lut with optional arguments
func vipsgenMaplutWithOptions(in *C.VipsImage, lut *C.VipsImage, band int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_maplut_with_options(in, &out, lut, C.int(band)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaskButterworth vips_mask_butterworth make a butterworth filter
func vipsgenMaskButterworth(width int, height int, order float64, frequencyCutoff float64, amplitudeCutoff float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mask_butterworth(&out, C.int(width), C.int(height), C.double(order), C.double(frequencyCutoff), C.double(amplitudeCutoff)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaskButterworthWithOptions vips_mask_butterworth make a butterworth filter with optional arguments
func vipsgenMaskButterworthWithOptions(width int, height int, order float64, frequencyCutoff float64, amplitudeCutoff float64, uchar bool, nodc bool, reject bool, optical bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mask_butterworth_with_options(&out, C.int(width), C.int(height), C.double(order), C.double(frequencyCutoff), C.double(amplitudeCutoff), C.int(boolToInt(uchar)), C.int(boolToInt(nodc)), C.int(boolToInt(reject)), C.int(boolToInt(optical))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaskButterworthBand vips_mask_butterworth_band make a butterworth_band filter
func vipsgenMaskButterworthBand(width int, height int, order float64, frequencyCutoffX float64, frequencyCutoffY float64, radius float64, amplitudeCutoff float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mask_butterworth_band(&out, C.int(width), C.int(height), C.double(order), C.double(frequencyCutoffX), C.double(frequencyCutoffY), C.double(radius), C.double(amplitudeCutoff)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaskButterworthBandWithOptions vips_mask_butterworth_band make a butterworth_band filter with optional arguments
func vipsgenMaskButterworthBandWithOptions(width int, height int, order float64, frequencyCutoffX float64, frequencyCutoffY float64, radius float64, amplitudeCutoff float64, uchar bool, nodc bool, reject bool, optical bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mask_butterworth_band_with_options(&out, C.int(width), C.int(height), C.double(order), C.double(frequencyCutoffX), C.double(frequencyCutoffY), C.double(radius), C.double(amplitudeCutoff), C.int(boolToInt(uchar)), C.int(boolToInt(nodc)), C.int(boolToInt(reject)), C.int(boolToInt(optical))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaskButterworthRing vips_mask_butterworth_ring make a butterworth ring filter
func vipsgenMaskButterworthRing(width int, height int, order float64, frequencyCutoff float64, amplitudeCutoff float64, ringwidth float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mask_butterworth_ring(&out, C.int(width), C.int(height), C.double(order), C.double(frequencyCutoff), C.double(amplitudeCutoff), C.double(ringwidth)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaskButterworthRingWithOptions vips_mask_butterworth_ring make a butterworth ring filter with optional arguments
func vipsgenMaskButterworthRingWithOptions(width int, height int, order float64, frequencyCutoff float64, amplitudeCutoff float64, ringwidth float64, uchar bool, nodc bool, reject bool, optical bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mask_butterworth_ring_with_options(&out, C.int(width), C.int(height), C.double(order), C.double(frequencyCutoff), C.double(amplitudeCutoff), C.double(ringwidth), C.int(boolToInt(uchar)), C.int(boolToInt(nodc)), C.int(boolToInt(reject)), C.int(boolToInt(optical))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaskFractal vips_mask_fractal make fractal filter
func vipsgenMaskFractal(width int, height int, fractalDimension float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mask_fractal(&out, C.int(width), C.int(height), C.double(fractalDimension)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaskFractalWithOptions vips_mask_fractal make fractal filter with optional arguments
func vipsgenMaskFractalWithOptions(width int, height int, fractalDimension float64, uchar bool, nodc bool, reject bool, optical bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mask_fractal_with_options(&out, C.int(width), C.int(height), C.double(fractalDimension), C.int(boolToInt(uchar)), C.int(boolToInt(nodc)), C.int(boolToInt(reject)), C.int(boolToInt(optical))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaskGaussian vips_mask_gaussian make a gaussian filter
func vipsgenMaskGaussian(width int, height int, frequencyCutoff float64, amplitudeCutoff float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mask_gaussian(&out, C.int(width), C.int(height), C.double(frequencyCutoff), C.double(amplitudeCutoff)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaskGaussianWithOptions vips_mask_gaussian make a gaussian filter with optional arguments
func vipsgenMaskGaussianWithOptions(width int, height int, frequencyCutoff float64, amplitudeCutoff float64, uchar bool, nodc bool, reject bool, optical bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mask_gaussian_with_options(&out, C.int(width), C.int(height), C.double(frequencyCutoff), C.double(amplitudeCutoff), C.int(boolToInt(uchar)), C.int(boolToInt(nodc)), C.int(boolToInt(reject)), C.int(boolToInt(optical))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaskGaussianBand vips_mask_gaussian_band make a gaussian filter
func vipsgenMaskGaussianBand(width int, height int, frequencyCutoffX float64, frequencyCutoffY float64, radius float64, amplitudeCutoff float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mask_gaussian_band(&out, C.int(width), C.int(height), C.double(frequencyCutoffX), C.double(frequencyCutoffY), C.double(radius), C.double(amplitudeCutoff)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaskGaussianBandWithOptions vips_mask_gaussian_band make a gaussian filter with optional arguments
func vipsgenMaskGaussianBandWithOptions(width int, height int, frequencyCutoffX float64, frequencyCutoffY float64, radius float64, amplitudeCutoff float64, uchar bool, nodc bool, reject bool, optical bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mask_gaussian_band_with_options(&out, C.int(width), C.int(height), C.double(frequencyCutoffX), C.double(frequencyCutoffY), C.double(radius), C.double(amplitudeCutoff), C.int(boolToInt(uchar)), C.int(boolToInt(nodc)), C.int(boolToInt(reject)), C.int(boolToInt(optical))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaskGaussianRing vips_mask_gaussian_ring make a gaussian ring filter
func vipsgenMaskGaussianRing(width int, height int, frequencyCutoff float64, amplitudeCutoff float64, ringwidth float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mask_gaussian_ring(&out, C.int(width), C.int(height), C.double(frequencyCutoff), C.double(amplitudeCutoff), C.double(ringwidth)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaskGaussianRingWithOptions vips_mask_gaussian_ring make a gaussian ring filter with optional arguments
func vipsgenMaskGaussianRingWithOptions(width int, height int, frequencyCutoff float64, amplitudeCutoff float64, ringwidth float64, uchar bool, nodc bool, reject bool, optical bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mask_gaussian_ring_with_options(&out, C.int(width), C.int(height), C.double(frequencyCutoff), C.double(amplitudeCutoff), C.double(ringwidth), C.int(boolToInt(uchar)), C.int(boolToInt(nodc)), C.int(boolToInt(reject)), C.int(boolToInt(optical))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaskIdeal vips_mask_ideal make an ideal filter
func vipsgenMaskIdeal(width int, height int, frequencyCutoff float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mask_ideal(&out, C.int(width), C.int(height), C.double(frequencyCutoff)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaskIdealWithOptions vips_mask_ideal make an ideal filter with optional arguments
func vipsgenMaskIdealWithOptions(width int, height int, frequencyCutoff float64, uchar bool, nodc bool, reject bool, optical bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mask_ideal_with_options(&out, C.int(width), C.int(height), C.double(frequencyCutoff), C.int(boolToInt(uchar)), C.int(boolToInt(nodc)), C.int(boolToInt(reject)), C.int(boolToInt(optical))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaskIdealBand vips_mask_ideal_band make an ideal band filter
func vipsgenMaskIdealBand(width int, height int, frequencyCutoffX float64, frequencyCutoffY float64, radius float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mask_ideal_band(&out, C.int(width), C.int(height), C.double(frequencyCutoffX), C.double(frequencyCutoffY), C.double(radius)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaskIdealBandWithOptions vips_mask_ideal_band make an ideal band filter with optional arguments
func vipsgenMaskIdealBandWithOptions(width int, height int, frequencyCutoffX float64, frequencyCutoffY float64, radius float64, uchar bool, nodc bool, reject bool, optical bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mask_ideal_band_with_options(&out, C.int(width), C.int(height), C.double(frequencyCutoffX), C.double(frequencyCutoffY), C.double(radius), C.int(boolToInt(uchar)), C.int(boolToInt(nodc)), C.int(boolToInt(reject)), C.int(boolToInt(optical))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaskIdealRing vips_mask_ideal_ring make an ideal ring filter
func vipsgenMaskIdealRing(width int, height int, frequencyCutoff float64, ringwidth float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mask_ideal_ring(&out, C.int(width), C.int(height), C.double(frequencyCutoff), C.double(ringwidth)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMaskIdealRingWithOptions vips_mask_ideal_ring make an ideal ring filter with optional arguments
func vipsgenMaskIdealRingWithOptions(width int, height int, frequencyCutoff float64, ringwidth float64, uchar bool, nodc bool, reject bool, optical bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mask_ideal_ring_with_options(&out, C.int(width), C.int(height), C.double(frequencyCutoff), C.double(ringwidth), C.int(boolToInt(uchar)), C.int(boolToInt(nodc)), C.int(boolToInt(reject)), C.int(boolToInt(optical))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMatch vips_match first-order match of two images
func vipsgenMatch(ref *C.VipsImage, sec *C.VipsImage, xr1 int, yr1 int, xs1 int, ys1 int, xr2 int, yr2 int, xs2 int, ys2 int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_match(ref, sec, &out, C.int(xr1), C.int(yr1), C.int(xs1), C.int(ys1), C.int(xr2), C.int(yr2), C.int(xs2), C.int(ys2)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMatchWithOptions vips_match first-order match of two images with optional arguments
func vipsgenMatchWithOptions(ref *C.VipsImage, sec *C.VipsImage, xr1 int, yr1 int, xs1 int, ys1 int, xr2 int, yr2 int, xs2 int, ys2 int, hwindow int, harea int, search bool, interpolate *Interpolate) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_match_with_options(ref, sec, &out, C.int(xr1), C.int(yr1), C.int(xs1), C.int(ys1), C.int(xr2), C.int(yr2), C.int(xs2), C.int(ys2), C.int(hwindow), C.int(harea), C.int(boolToInt(search)), vipsInterpolateToC(interpolate)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMath vips_math apply a math operation to an image
func vipsgenMath(in *C.VipsImage, math OperationMath) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_math(in, &out, C.VipsOperationMath(math)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMath2 vips_math2 binary math operations
func vipsgenMath2(left *C.VipsImage, right *C.VipsImage, math2 OperationMath2) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_math2(left, right, &out, C.VipsOperationMath2(math2)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMath2Const vips_math2_const binary math operations with a constant
func vipsgenMath2Const(in *C.VipsImage, math2 OperationMath2, c []float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	cc, _, err := convertToDoubleArray(c)
	if err != nil {
		return nil, err
	}
	if cc != nil {
		defer freeDoubleArray(cc)
	}
	if err := C.vipsgen_math2_const(in, &out, C.VipsOperationMath2(math2), cc, C.int(len(c))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMatrixinvert vips_matrixinvert invert an matrix
func vipsgenMatrixinvert(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_matrixinvert(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMatrixload vips_matrixload load matrix
func vipsgenMatrixload(filename string) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_matrixload(cfilename, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMatrixloadWithOptions vips_matrixload load matrix with optional arguments
func vipsgenMatrixloadWithOptions(filename string, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_matrixload_with_options(cfilename, &out, C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMatrixloadSource vips_matrixload_source load matrix
func vipsgenMatrixloadSource(source *C.VipsSourceCustom) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_matrixload_source(source, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMatrixloadSourceWithOptions vips_matrixload_source load matrix with optional arguments
func vipsgenMatrixloadSourceWithOptions(source *C.VipsSourceCustom, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_matrixload_source_with_options(source, &out, C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMatrixprint vips_matrixprint print matrix
func vipsgenMatrixprint(in *C.VipsImage) (error) {
	
	if err := C.vipsgen_matrixprint(in); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenMatrixprintWithOptions vips_matrixprint print matrix with optional arguments
func vipsgenMatrixprintWithOptions(in *C.VipsImage, keep Keep, background []float64, pageHeight int, profile string) (error) {
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_matrixprint_with_options(in, C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenMatrixsave vips_matrixsave save image to matrix
func vipsgenMatrixsave(in *C.VipsImage, filename string) (error) {
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_matrixsave(in, cfilename); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenMatrixsaveWithOptions vips_matrixsave save image to matrix with optional arguments
func vipsgenMatrixsaveWithOptions(in *C.VipsImage, filename string, keep Keep, background []float64, pageHeight int, profile string) (error) {
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_matrixsave_with_options(in, cfilename, C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenMatrixsaveTarget vips_matrixsave_target save image to matrix
func vipsgenMatrixsaveTarget(in *C.VipsImage, target *C.VipsTargetCustom) (error) {
	
	if err := C.vipsgen_matrixsave_target(in, target); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenMatrixsaveTargetWithOptions vips_matrixsave_target save image to matrix with optional arguments
func vipsgenMatrixsaveTargetWithOptions(in *C.VipsImage, target *C.VipsTargetCustom, keep Keep, background []float64, pageHeight int, profile string) (error) {
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_matrixsave_target_with_options(in, target, C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenMax vips_max find image maximum
func vipsgenMax(in *C.VipsImage) (float64, error) {
	var out float64
	cout := (*C.double)(unsafe.Pointer(&out))
	if err := C.vipsgen_max(in, cout); err != 0 {
		return 0, handleVipsError()
	}
	return out, nil
}

// vipsgenMaxWithOptions vips_max find image maximum with optional arguments
func vipsgenMaxWithOptions(in *C.VipsImage, size int) (float64, error) {
	var out float64
	cout := (*C.double)(unsafe.Pointer(&out))
	if err := C.vipsgen_max_with_options(in, cout, C.int(size)); err != 0 {
		return 0, handleVipsError()
	}
	return out, nil
}

// vipsgenMaxpair vips_maxpair maximum of a pair of images
func vipsgenMaxpair(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_maxpair(left, right, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMeasure vips_measure measure a set of patches on a color chart
func vipsgenMeasure(in *C.VipsImage, h int, v int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_measure(in, &out, C.int(h), C.int(v)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMeasureWithOptions vips_measure measure a set of patches on a color chart with optional arguments
func vipsgenMeasureWithOptions(in *C.VipsImage, h int, v int, left int, top int, width int, height int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_measure_with_options(in, &out, C.int(h), C.int(v), C.int(left), C.int(top), C.int(width), C.int(height)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMerge vips_merge merge two images
func vipsgenMerge(ref *C.VipsImage, sec *C.VipsImage, direction Direction, dx int, dy int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_merge(ref, sec, &out, C.VipsDirection(direction), C.int(dx), C.int(dy)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMergeWithOptions vips_merge merge two images with optional arguments
func vipsgenMergeWithOptions(ref *C.VipsImage, sec *C.VipsImage, direction Direction, dx int, dy int, mblend int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_merge_with_options(ref, sec, &out, C.VipsDirection(direction), C.int(dx), C.int(dy), C.int(mblend)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMin vips_min find image minimum
func vipsgenMin(in *C.VipsImage) (float64, error) {
	var out float64
	cout := (*C.double)(unsafe.Pointer(&out))
	if err := C.vipsgen_min(in, cout); err != 0 {
		return 0, handleVipsError()
	}
	return out, nil
}

// vipsgenMinWithOptions vips_min find image minimum with optional arguments
func vipsgenMinWithOptions(in *C.VipsImage, size int) (float64, error) {
	var out float64
	cout := (*C.double)(unsafe.Pointer(&out))
	if err := C.vipsgen_min_with_options(in, cout, C.int(size)); err != 0 {
		return 0, handleVipsError()
	}
	return out, nil
}

// vipsgenMinpair vips_minpair minimum of a pair of images
func vipsgenMinpair(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_minpair(left, right, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMorph vips_morph morphology operation
func vipsgenMorph(in *C.VipsImage, mask *C.VipsImage, morph OperationMorphology) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_morph(in, &out, mask, C.VipsOperationMorphology(morph)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMosaic vips_mosaic mosaic two images
func vipsgenMosaic(ref *C.VipsImage, sec *C.VipsImage, direction Direction, xref int, yref int, xsec int, ysec int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mosaic(ref, sec, &out, C.VipsDirection(direction), C.int(xref), C.int(yref), C.int(xsec), C.int(ysec)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMosaicWithOptions vips_mosaic mosaic two images with optional arguments
func vipsgenMosaicWithOptions(ref *C.VipsImage, sec *C.VipsImage, direction Direction, xref int, yref int, xsec int, ysec int, hwindow int, harea int, mblend int, bandno int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mosaic_with_options(ref, sec, &out, C.VipsDirection(direction), C.int(xref), C.int(yref), C.int(xsec), C.int(ysec), C.int(hwindow), C.int(harea), C.int(mblend), C.int(bandno)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMosaic1 vips_mosaic1 first-order mosaic of two images
func vipsgenMosaic1(ref *C.VipsImage, sec *C.VipsImage, direction Direction, xr1 int, yr1 int, xs1 int, ys1 int, xr2 int, yr2 int, xs2 int, ys2 int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mosaic1(ref, sec, &out, C.VipsDirection(direction), C.int(xr1), C.int(yr1), C.int(xs1), C.int(ys1), C.int(xr2), C.int(yr2), C.int(xs2), C.int(ys2)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMosaic1WithOptions vips_mosaic1 first-order mosaic of two images with optional arguments
func vipsgenMosaic1WithOptions(ref *C.VipsImage, sec *C.VipsImage, direction Direction, xr1 int, yr1 int, xs1 int, ys1 int, xr2 int, yr2 int, xs2 int, ys2 int, hwindow int, harea int, search bool, interpolate *Interpolate, mblend int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_mosaic1_with_options(ref, sec, &out, C.VipsDirection(direction), C.int(xr1), C.int(yr1), C.int(xs1), C.int(ys1), C.int(xr2), C.int(yr2), C.int(xs2), C.int(ys2), C.int(hwindow), C.int(harea), C.int(boolToInt(search)), vipsInterpolateToC(interpolate), C.int(mblend)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMsb vips_msb pick most-significant byte from an image
func vipsgenMsb(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_msb(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMsbWithOptions vips_msb pick most-significant byte from an image with optional arguments
func vipsgenMsbWithOptions(in *C.VipsImage, band int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_msb_with_options(in, &out, C.int(band)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenMultiply vips_multiply multiply two images
func vipsgenMultiply(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_multiply(left, right, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenPercent vips_percent find threshold for percent of pixels
func vipsgenPercent(in *C.VipsImage, percent float64) (int, error) {
	var threshold int
	cthreshold := (*C.int)(unsafe.Pointer(&threshold))
	if err := C.vipsgen_percent(in, C.double(percent), cthreshold); err != 0 {
		return 0, handleVipsError()
	}
	return threshold, nil
}

// vipsgenPerlin vips_perlin make a perlin noise image
func vipsgenPerlin(width int, height int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_perlin(&out, C.int(width), C.int(height)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenPerlinWithOptions vips_perlin make a perlin noise image with optional arguments
func vipsgenPerlinWithOptions(width int, height int, cellSize int, uchar bool, seed int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_perlin_with_options(&out, C.int(width), C.int(height), C.int(cellSize), C.int(boolToInt(uchar)), C.int(seed)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenPhasecor vips_phasecor calculate phase correlation
func vipsgenPhasecor(in *C.VipsImage, in2 *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_phasecor(in, in2, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenPngload vips_pngload load png from file
func vipsgenPngload(filename string) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_pngload(cfilename, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenPngloadWithOptions vips_pngload load png from file with optional arguments
func vipsgenPngloadWithOptions(filename string, unlimited bool, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_pngload_with_options(cfilename, &out, C.int(boolToInt(unlimited)), C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenPngloadBuffer vips_pngload_buffer load png from buffer
func vipsgenPngloadBuffer(buf []byte) (*C.VipsImage, error) {
	src := buf
	// Reference src here so it's not garbage collected during image initialization.
	defer runtime.KeepAlive(src)
	var out *C.VipsImage
	if err := C.vipsgen_pngload_buffer(unsafe.Pointer(&src[0]), C.size_t(len(src)), &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenPngloadBufferWithOptions vips_pngload_buffer load png from buffer with optional arguments
func vipsgenPngloadBufferWithOptions(buf []byte, unlimited bool, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	src := buf
	// Reference src here so it's not garbage collected during image initialization.
	defer runtime.KeepAlive(src)
	var out *C.VipsImage
	if err := C.vipsgen_pngload_buffer_with_options(unsafe.Pointer(&src[0]), C.size_t(len(src)), &out, C.int(boolToInt(unlimited)), C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenPngloadSource vips_pngload_source load png from source
func vipsgenPngloadSource(source *C.VipsSourceCustom) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_pngload_source(source, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenPngloadSourceWithOptions vips_pngload_source load png from source with optional arguments
func vipsgenPngloadSourceWithOptions(source *C.VipsSourceCustom, unlimited bool, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_pngload_source_with_options(source, &out, C.int(boolToInt(unlimited)), C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenPngsave vips_pngsave save image to png file
func vipsgenPngsave(in *C.VipsImage, filename string) (error) {
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_pngsave(in, cfilename); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenPngsaveWithOptions vips_pngsave save image to png file with optional arguments
func vipsgenPngsaveWithOptions(in *C.VipsImage, filename string, compression int, interlace bool, filter PngFilter, palette bool, q int, dither float64, bitdepth int, effort int, keep Keep, background []float64, pageHeight int, profile string) (error) {
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_pngsave_with_options(in, cfilename, C.int(compression), C.int(boolToInt(interlace)), C.VipsForeignPngFilter(filter), C.int(boolToInt(palette)), C.int(q), C.double(dither), C.int(bitdepth), C.int(effort), C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenPngsaveBuffer vips_pngsave_buffer save image to png buffer
func vipsgenPngsaveBuffer(in *C.VipsImage) ([]byte, error) {
	var buf unsafe.Pointer
	var length C.size_t
	if err := C.vipsgen_pngsave_buffer(in, &buf, &length); err != 0 {
		return nil, handleVipsError()
	}
	return bufferToBytes(buf, length), nil
}

// vipsgenPngsaveBufferWithOptions vips_pngsave_buffer save image to png buffer with optional arguments
func vipsgenPngsaveBufferWithOptions(in *C.VipsImage, compression int, interlace bool, filter PngFilter, palette bool, q int, dither float64, bitdepth int, effort int, keep Keep, background []float64, pageHeight int, profile string) ([]byte, error) {
	var buf unsafe.Pointer
	var length C.size_t
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return nil, err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_pngsave_buffer_with_options(in, &buf, &length, C.int(compression), C.int(boolToInt(interlace)), C.VipsForeignPngFilter(filter), C.int(boolToInt(palette)), C.int(q), C.double(dither), C.int(bitdepth), C.int(effort), C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return nil, handleVipsError()
	}
	return bufferToBytes(buf, length), nil
}

// vipsgenPngsaveTarget vips_pngsave_target save image to target as PNG
func vipsgenPngsaveTarget(in *C.VipsImage, target *C.VipsTargetCustom) (error) {
	
	if err := C.vipsgen_pngsave_target(in, target); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenPngsaveTargetWithOptions vips_pngsave_target save image to target as PNG with optional arguments
func vipsgenPngsaveTargetWithOptions(in *C.VipsImage, target *C.VipsTargetCustom, compression int, interlace bool, filter PngFilter, palette bool, q int, dither float64, bitdepth int, effort int, keep Keep, background []float64, pageHeight int, profile string) (error) {
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_pngsave_target_with_options(in, target, C.int(compression), C.int(boolToInt(interlace)), C.VipsForeignPngFilter(filter), C.int(boolToInt(palette)), C.int(q), C.double(dither), C.int(bitdepth), C.int(effort), C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenPpmload vips_ppmload load ppm from file
func vipsgenPpmload(filename string) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_ppmload(cfilename, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenPpmloadWithOptions vips_ppmload load ppm from file with optional arguments
func vipsgenPpmloadWithOptions(filename string, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_ppmload_with_options(cfilename, &out, C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenPpmloadSource vips_ppmload_source load ppm base class
func vipsgenPpmloadSource(source *C.VipsSourceCustom) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_ppmload_source(source, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenPpmloadSourceWithOptions vips_ppmload_source load ppm base class with optional arguments
func vipsgenPpmloadSourceWithOptions(source *C.VipsSourceCustom, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_ppmload_source_with_options(source, &out, C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenPpmsave vips_ppmsave save image to ppm file
func vipsgenPpmsave(in *C.VipsImage, filename string) (error) {
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_ppmsave(in, cfilename); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenPpmsaveWithOptions vips_ppmsave save image to ppm file with optional arguments
func vipsgenPpmsaveWithOptions(in *C.VipsImage, filename string, format PpmFormat, ascii bool, bitdepth int, keep Keep, background []float64, pageHeight int, profile string) (error) {
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_ppmsave_with_options(in, cfilename, C.VipsForeignPpmFormat(format), C.int(boolToInt(ascii)), C.int(bitdepth), C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenPpmsaveTarget vips_ppmsave_target save to ppm
func vipsgenPpmsaveTarget(in *C.VipsImage, target *C.VipsTargetCustom) (error) {
	
	if err := C.vipsgen_ppmsave_target(in, target); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenPpmsaveTargetWithOptions vips_ppmsave_target save to ppm with optional arguments
func vipsgenPpmsaveTargetWithOptions(in *C.VipsImage, target *C.VipsTargetCustom, format PpmFormat, ascii bool, bitdepth int, keep Keep, background []float64, pageHeight int, profile string) (error) {
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_ppmsave_target_with_options(in, target, C.VipsForeignPpmFormat(format), C.int(boolToInt(ascii)), C.int(bitdepth), C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenPremultiply vips_premultiply premultiply image alpha
func vipsgenPremultiply(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_premultiply(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenPremultiplyWithOptions vips_premultiply premultiply image alpha with optional arguments
func vipsgenPremultiplyWithOptions(in *C.VipsImage, maxAlpha float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_premultiply_with_options(in, &out, C.double(maxAlpha)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenPrewitt vips_prewitt Prewitt edge detector
func vipsgenPrewitt(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_prewitt(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenProfile vips_profile find image profiles
func vipsgenProfile(in *C.VipsImage) (*C.VipsImage, *C.VipsImage, error) {
	var columns *C.VipsImage
	var rows *C.VipsImage
	if err := C.vipsgen_profile(in, &columns, &rows); err != 0 {
		return nil, nil, handleVipsError()
	}
	return columns, rows, nil
}

// vipsgenProfileLoad vips_profile_load load named ICC profile
func vipsgenProfileLoad(name string) ([]byte, error) {
	var profile *C.VipsBlob
	cname := C.CString(name)
	defer freeCString(cname)
	if err := C.vipsgen_profile_load(cname, &profile); err != 0 {
		return nil, handleVipsError()
	}
	return vipsBlobToBytes(profile), nil
}

// vipsgenProject vips_project find image projections
func vipsgenProject(in *C.VipsImage) (*C.VipsImage, *C.VipsImage, error) {
	var columns *C.VipsImage
	var rows *C.VipsImage
	if err := C.vipsgen_project(in, &columns, &rows); err != 0 {
		return nil, nil, handleVipsError()
	}
	return columns, rows, nil
}

// vipsgenQuadratic vips_quadratic resample an image with a quadratic transform
func vipsgenQuadratic(in *C.VipsImage, coeff *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_quadratic(in, &out, coeff); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenQuadraticWithOptions vips_quadratic resample an image with a quadratic transform with optional arguments
func vipsgenQuadraticWithOptions(in *C.VipsImage, coeff *C.VipsImage, interpolate *Interpolate) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_quadratic_with_options(in, &out, coeff, vipsInterpolateToC(interpolate)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenRad2float vips_rad2float unpack Radiance coding to float RGB
func vipsgenRad2float(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_rad2float(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenRadload vips_radload load a Radiance image from a file
func vipsgenRadload(filename string) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_radload(cfilename, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenRadloadWithOptions vips_radload load a Radiance image from a file with optional arguments
func vipsgenRadloadWithOptions(filename string, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_radload_with_options(cfilename, &out, C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenRadloadBuffer vips_radload_buffer load rad from buffer
func vipsgenRadloadBuffer(buf []byte) (*C.VipsImage, error) {
	src := buf
	// Reference src here so it's not garbage collected during image initialization.
	defer runtime.KeepAlive(src)
	var out *C.VipsImage
	if err := C.vipsgen_radload_buffer(unsafe.Pointer(&src[0]), C.size_t(len(src)), &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenRadloadBufferWithOptions vips_radload_buffer load rad from buffer with optional arguments
func vipsgenRadloadBufferWithOptions(buf []byte, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	src := buf
	// Reference src here so it's not garbage collected during image initialization.
	defer runtime.KeepAlive(src)
	var out *C.VipsImage
	if err := C.vipsgen_radload_buffer_with_options(unsafe.Pointer(&src[0]), C.size_t(len(src)), &out, C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenRadloadSource vips_radload_source load rad from source
func vipsgenRadloadSource(source *C.VipsSourceCustom) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_radload_source(source, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenRadloadSourceWithOptions vips_radload_source load rad from source with optional arguments
func vipsgenRadloadSourceWithOptions(source *C.VipsSourceCustom, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_radload_source_with_options(source, &out, C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenRadsave vips_radsave save image to Radiance file
func vipsgenRadsave(in *C.VipsImage, filename string) (error) {
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_radsave(in, cfilename); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenRadsaveWithOptions vips_radsave save image to Radiance file with optional arguments
func vipsgenRadsaveWithOptions(in *C.VipsImage, filename string, keep Keep, background []float64, pageHeight int, profile string) (error) {
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_radsave_with_options(in, cfilename, C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenRadsaveBuffer vips_radsave_buffer save image to Radiance buffer
func vipsgenRadsaveBuffer(in *C.VipsImage) ([]byte, error) {
	var buf unsafe.Pointer
	var length C.size_t
	if err := C.vipsgen_radsave_buffer(in, &buf, &length); err != 0 {
		return nil, handleVipsError()
	}
	return bufferToBytes(buf, length), nil
}

// vipsgenRadsaveBufferWithOptions vips_radsave_buffer save image to Radiance buffer with optional arguments
func vipsgenRadsaveBufferWithOptions(in *C.VipsImage, keep Keep, background []float64, pageHeight int, profile string) ([]byte, error) {
	var buf unsafe.Pointer
	var length C.size_t
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return nil, err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_radsave_buffer_with_options(in, &buf, &length, C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return nil, handleVipsError()
	}
	return bufferToBytes(buf, length), nil
}

// vipsgenRadsaveTarget vips_radsave_target save image to Radiance target
func vipsgenRadsaveTarget(in *C.VipsImage, target *C.VipsTargetCustom) (error) {
	
	if err := C.vipsgen_radsave_target(in, target); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenRadsaveTargetWithOptions vips_radsave_target save image to Radiance target with optional arguments
func vipsgenRadsaveTargetWithOptions(in *C.VipsImage, target *C.VipsTargetCustom, keep Keep, background []float64, pageHeight int, profile string) (error) {
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_radsave_target_with_options(in, target, C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenRank vips_rank rank filter
func vipsgenRank(in *C.VipsImage, width int, height int, index int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_rank(in, &out, C.int(width), C.int(height), C.int(index)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenRawload vips_rawload load raw data from a file
func vipsgenRawload(filename string, width int, height int, bands int) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_rawload(cfilename, &out, C.int(width), C.int(height), C.int(bands)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenRawloadWithOptions vips_rawload load raw data from a file with optional arguments
func vipsgenRawloadWithOptions(filename string, width int, height int, bands int, offset uint64, format BandFormat, interpretation Interpretation, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_rawload_with_options(cfilename, &out, C.int(width), C.int(height), C.int(bands), C.guint64(offset), C.VipsBandFormat(format), C.VipsInterpretation(interpretation), C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenRawsave vips_rawsave save image to raw file
func vipsgenRawsave(in *C.VipsImage, filename string) (error) {
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_rawsave(in, cfilename); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenRawsaveWithOptions vips_rawsave save image to raw file with optional arguments
func vipsgenRawsaveWithOptions(in *C.VipsImage, filename string, keep Keep, background []float64, pageHeight int, profile string) (error) {
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_rawsave_with_options(in, cfilename, C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenRawsaveBuffer vips_rawsave_buffer write raw image to buffer
func vipsgenRawsaveBuffer(in *C.VipsImage) ([]byte, error) {
	var buf unsafe.Pointer
	var length C.size_t
	if err := C.vipsgen_rawsave_buffer(in, &buf, &length); err != 0 {
		return nil, handleVipsError()
	}
	return bufferToBytes(buf, length), nil
}

// vipsgenRawsaveBufferWithOptions vips_rawsave_buffer write raw image to buffer with optional arguments
func vipsgenRawsaveBufferWithOptions(in *C.VipsImage, keep Keep, background []float64, pageHeight int, profile string) ([]byte, error) {
	var buf unsafe.Pointer
	var length C.size_t
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return nil, err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_rawsave_buffer_with_options(in, &buf, &length, C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return nil, handleVipsError()
	}
	return bufferToBytes(buf, length), nil
}

// vipsgenRawsaveTarget vips_rawsave_target write raw image to target
func vipsgenRawsaveTarget(in *C.VipsImage, target *C.VipsTargetCustom) (error) {
	
	if err := C.vipsgen_rawsave_target(in, target); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenRawsaveTargetWithOptions vips_rawsave_target write raw image to target with optional arguments
func vipsgenRawsaveTargetWithOptions(in *C.VipsImage, target *C.VipsTargetCustom, keep Keep, background []float64, pageHeight int, profile string) (error) {
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_rawsave_target_with_options(in, target, C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenRecomb vips_recomb linear recombination with matrix
func vipsgenRecomb(in *C.VipsImage, m *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_recomb(in, &out, m); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenReduce vips_reduce reduce an image
func vipsgenReduce(in *C.VipsImage, hshrink float64, vshrink float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_reduce(in, &out, C.double(hshrink), C.double(vshrink)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenReduceWithOptions vips_reduce reduce an image with optional arguments
func vipsgenReduceWithOptions(in *C.VipsImage, hshrink float64, vshrink float64, kernel Kernel, gap float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_reduce_with_options(in, &out, C.double(hshrink), C.double(vshrink), C.VipsKernel(kernel), C.double(gap)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenReduceh vips_reduceh shrink an image horizontally
func vipsgenReduceh(in *C.VipsImage, hshrink float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_reduceh(in, &out, C.double(hshrink)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenReducehWithOptions vips_reduceh shrink an image horizontally with optional arguments
func vipsgenReducehWithOptions(in *C.VipsImage, hshrink float64, kernel Kernel, gap float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_reduceh_with_options(in, &out, C.double(hshrink), C.VipsKernel(kernel), C.double(gap)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenReducev vips_reducev shrink an image vertically
func vipsgenReducev(in *C.VipsImage, vshrink float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_reducev(in, &out, C.double(vshrink)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenReducevWithOptions vips_reducev shrink an image vertically with optional arguments
func vipsgenReducevWithOptions(in *C.VipsImage, vshrink float64, kernel Kernel, gap float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_reducev_with_options(in, &out, C.double(vshrink), C.VipsKernel(kernel), C.double(gap)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenRelational vips_relational relational operation on two images
func vipsgenRelational(left *C.VipsImage, right *C.VipsImage, relational OperationRelational) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_relational(left, right, &out, C.VipsOperationRelational(relational)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenRelationalConst vips_relational_const relational operations against a constant
func vipsgenRelationalConst(in *C.VipsImage, relational OperationRelational, c []float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	cc, _, err := convertToDoubleArray(c)
	if err != nil {
		return nil, err
	}
	if cc != nil {
		defer freeDoubleArray(cc)
	}
	if err := C.vipsgen_relational_const(in, &out, C.VipsOperationRelational(relational), cc, C.int(len(c))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenRemainder vips_remainder remainder after integer division of two images
func vipsgenRemainder(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_remainder(left, right, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenRemainderConst vips_remainder_const remainder after integer division of an image and a constant
func vipsgenRemainderConst(in *C.VipsImage, c []float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	cc, _, err := convertToDoubleArray(c)
	if err != nil {
		return nil, err
	}
	if cc != nil {
		defer freeDoubleArray(cc)
	}
	if err := C.vipsgen_remainder_const(in, &out, cc, C.int(len(c))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenReplicate vips_replicate replicate an image
func vipsgenReplicate(in *C.VipsImage, across int, down int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_replicate(in, &out, C.int(across), C.int(down)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenResize vips_resize resize an image
func vipsgenResize(in *C.VipsImage, scale float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_resize(in, &out, C.double(scale)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenResizeWithOptions vips_resize resize an image with optional arguments
func vipsgenResizeWithOptions(in *C.VipsImage, scale float64, kernel Kernel, gap float64, vscale float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_resize_with_options(in, &out, C.double(scale), C.VipsKernel(kernel), C.double(gap), C.double(vscale)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenRot vips_rot rotate an image
func vipsgenRot(in *C.VipsImage, angle Angle) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_rot(in, &out, C.VipsAngle(angle)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenRot45 vips_rot45 rotate an image
func vipsgenRot45(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_rot45(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenRot45WithOptions vips_rot45 rotate an image with optional arguments
func vipsgenRot45WithOptions(in *C.VipsImage, angle Angle45) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_rot45_with_options(in, &out, C.VipsAngle45(angle)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenRotate vips_rotate rotate an image by a number of degrees
func vipsgenRotate(in *C.VipsImage, angle float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_rotate(in, &out, C.double(angle)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenRotateWithOptions vips_rotate rotate an image by a number of degrees with optional arguments
func vipsgenRotateWithOptions(in *C.VipsImage, angle float64, interpolate *Interpolate, background []float64, odx float64, ody float64, idx float64, idy float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return nil, err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	if err := C.vipsgen_rotate_with_options(in, &out, C.double(angle), vipsInterpolateToC(interpolate), cbackground, cbackgroundLength, C.double(odx), C.double(ody), C.double(idx), C.double(idy)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenRound vips_round perform a round function on an image
func vipsgenRound(in *C.VipsImage, round OperationRound) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_round(in, &out, C.VipsOperationRound(round)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSRGB2HSV vips_sRGB2HSV transform sRGB to HSV
func vipsgenSRGB2HSV(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_sRGB2HSV(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSRGB2scRGB vips_sRGB2scRGB convert an sRGB image to scRGB
func vipsgenSRGB2scRGB(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_sRGB2scRGB(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenScRGB2BW vips_scRGB2BW convert scRGB to BW
func vipsgenScRGB2BW(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_scRGB2BW(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenScRGB2BWWithOptions vips_scRGB2BW convert scRGB to BW with optional arguments
func vipsgenScRGB2BWWithOptions(in *C.VipsImage, depth int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_scRGB2BW_with_options(in, &out, C.int(depth)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenScRGB2XYZ vips_scRGB2XYZ transform scRGB to XYZ
func vipsgenScRGB2XYZ(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_scRGB2XYZ(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenScRGB2sRGB vips_scRGB2sRGB convert an scRGB image to sRGB
func vipsgenScRGB2sRGB(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_scRGB2sRGB(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenScRGB2sRGBWithOptions vips_scRGB2sRGB convert an scRGB image to sRGB with optional arguments
func vipsgenScRGB2sRGBWithOptions(in *C.VipsImage, depth int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_scRGB2sRGB_with_options(in, &out, C.int(depth)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenScale vips_scale scale an image to uchar
func vipsgenScale(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_scale(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenScaleWithOptions vips_scale scale an image to uchar with optional arguments
func vipsgenScaleWithOptions(in *C.VipsImage, exp float64, log bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_scale_with_options(in, &out, C.double(exp), C.int(boolToInt(log))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenScharr vips_scharr Scharr edge detector
func vipsgenScharr(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_scharr(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSdf vips_sdf create an SDF image
func vipsgenSdf(width int, height int, shape SdfShape) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_sdf(&out, C.int(width), C.int(height), C.VipsSdfShape(shape)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSdfWithOptions vips_sdf create an SDF image with optional arguments
func vipsgenSdfWithOptions(width int, height int, shape SdfShape, r float64, a []float64, b []float64, corners []float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	ca, caLength, err := convertToDoubleArray(a)
	if err != nil {
		return nil, err
	}
	if ca != nil {
		defer freeDoubleArray(ca)
	}
	cb, cbLength, err := convertToDoubleArray(b)
	if err != nil {
		return nil, err
	}
	if cb != nil {
		defer freeDoubleArray(cb)
	}
	ccorners, ccornersLength, err := convertToDoubleArray(corners)
	if err != nil {
		return nil, err
	}
	if ccorners != nil {
		defer freeDoubleArray(ccorners)
	}
	if err := C.vipsgen_sdf_with_options(&out, C.int(width), C.int(height), C.VipsSdfShape(shape), C.double(r), ca, caLength, cb, cbLength, ccorners, ccornersLength); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSequential vips_sequential check sequential access
func vipsgenSequential(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_sequential(in, &out); err != 0 {
		return nil, handleVipsError()
	}
	return out, nil
}

// vipsgenSequentialWithOptions vips_sequential check sequential access with optional arguments
func vipsgenSequentialWithOptions(in *C.VipsImage, tileHeight int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_sequential_with_options(in, &out, C.int(tileHeight)); err != 0 {
		return nil, handleVipsError()
	}
	return out, nil
}

// vipsgenSharpen vips_sharpen unsharp masking for print
func vipsgenSharpen(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_sharpen(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSharpenWithOptions vips_sharpen unsharp masking for print with optional arguments
func vipsgenSharpenWithOptions(in *C.VipsImage, sigma float64, x1 float64, y2 float64, y3 float64, m1 float64, m2 float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_sharpen_with_options(in, &out, C.double(sigma), C.double(x1), C.double(y2), C.double(y3), C.double(m1), C.double(m2)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenShrink vips_shrink shrink an image
func vipsgenShrink(in *C.VipsImage, hshrink float64, vshrink float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_shrink(in, &out, C.double(hshrink), C.double(vshrink)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenShrinkWithOptions vips_shrink shrink an image with optional arguments
func vipsgenShrinkWithOptions(in *C.VipsImage, hshrink float64, vshrink float64, ceil bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_shrink_with_options(in, &out, C.double(hshrink), C.double(vshrink), C.int(boolToInt(ceil))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenShrinkh vips_shrinkh shrink an image horizontally
func vipsgenShrinkh(in *C.VipsImage, hshrink int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_shrinkh(in, &out, C.int(hshrink)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenShrinkhWithOptions vips_shrinkh shrink an image horizontally with optional arguments
func vipsgenShrinkhWithOptions(in *C.VipsImage, hshrink int, ceil bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_shrinkh_with_options(in, &out, C.int(hshrink), C.int(boolToInt(ceil))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenShrinkv vips_shrinkv shrink an image vertically
func vipsgenShrinkv(in *C.VipsImage, vshrink int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_shrinkv(in, &out, C.int(vshrink)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenShrinkvWithOptions vips_shrinkv shrink an image vertically with optional arguments
func vipsgenShrinkvWithOptions(in *C.VipsImage, vshrink int, ceil bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_shrinkv_with_options(in, &out, C.int(vshrink), C.int(boolToInt(ceil))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSign vips_sign unit vector of pixel
func vipsgenSign(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_sign(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSimilarity vips_similarity similarity transform of an image
func vipsgenSimilarity(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_similarity(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSimilarityWithOptions vips_similarity similarity transform of an image with optional arguments
func vipsgenSimilarityWithOptions(in *C.VipsImage, scale float64, angle float64, interpolate *Interpolate, background []float64, odx float64, ody float64, idx float64, idy float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return nil, err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	if err := C.vipsgen_similarity_with_options(in, &out, C.double(scale), C.double(angle), vipsInterpolateToC(interpolate), cbackground, cbackgroundLength, C.double(odx), C.double(ody), C.double(idx), C.double(idy)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSines vips_sines make a 2D sine wave
func vipsgenSines(width int, height int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_sines(&out, C.int(width), C.int(height)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSinesWithOptions vips_sines make a 2D sine wave with optional arguments
func vipsgenSinesWithOptions(width int, height int, uchar bool, hfreq float64, vfreq float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_sines_with_options(&out, C.int(width), C.int(height), C.int(boolToInt(uchar)), C.double(hfreq), C.double(vfreq)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSmartcrop vips_smartcrop extract an area from an image
func vipsgenSmartcrop(input *C.VipsImage, width int, height int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_smartcrop(input, &out, C.int(width), C.int(height)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSmartcropWithOptions vips_smartcrop extract an area from an image with optional arguments
func vipsgenSmartcropWithOptions(input *C.VipsImage, width int, height int, interesting Interesting, premultiplied bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_smartcrop_with_options(input, &out, C.int(width), C.int(height), C.VipsInteresting(interesting), C.int(boolToInt(premultiplied))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSobel vips_sobel Sobel edge detector
func vipsgenSobel(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_sobel(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSpcor vips_spcor spatial correlation
func vipsgenSpcor(in *C.VipsImage, ref *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_spcor(in, ref, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSpectrum vips_spectrum make displayable power spectrum
func vipsgenSpectrum(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_spectrum(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenStats vips_stats find many image stats
func vipsgenStats(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_stats(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenStdif vips_stdif statistical difference
func vipsgenStdif(in *C.VipsImage, width int, height int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_stdif(in, &out, C.int(width), C.int(height)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenStdifWithOptions vips_stdif statistical difference with optional arguments
func vipsgenStdifWithOptions(in *C.VipsImage, width int, height int, s0 float64, b float64, m0 float64, a float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_stdif_with_options(in, &out, C.int(width), C.int(height), C.double(s0), C.double(b), C.double(m0), C.double(a)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSubsample vips_subsample subsample an image
func vipsgenSubsample(input *C.VipsImage, xfac int, yfac int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_subsample(input, &out, C.int(xfac), C.int(yfac)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSubsampleWithOptions vips_subsample subsample an image with optional arguments
func vipsgenSubsampleWithOptions(input *C.VipsImage, xfac int, yfac int, point bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_subsample_with_options(input, &out, C.int(xfac), C.int(yfac), C.int(boolToInt(point))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSubtract vips_subtract subtract two images
func vipsgenSubtract(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_subtract(left, right, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSum vips_sum sum an array of images
func vipsgenSum(in []*C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	cin, _, err := convertToImageArray(in)
	if err != nil {
		return nil, err
	}
	if cin != nil {
		defer freeImageArray(cin)
	}
	if err := C.vipsgen_sum((**C.VipsImage)(cin), &out, C.int(len(in))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSwitch vips_switch find the index of the first non-zero pixel in tests
func vipsgenSwitch(tests []*C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	ctests, _, err := convertToImageArray(tests)
	if err != nil {
		return nil, err
	}
	if ctests != nil {
		defer freeImageArray(ctests)
	}
	if err := C.vipsgen_switch((**C.VipsImage)(ctests), &out, C.int(len(tests))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSystem vips_system run an external command
func vipsgenSystem(cmdFormat string) (*C.VipsImage, error) {
	var out *C.VipsImage
	ccmdFormat := C.CString(cmdFormat)
	defer freeCString(ccmdFormat)
	if err := C.vipsgen_system(ccmdFormat); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenSystemWithOptions vips_system run an external command with optional arguments
func vipsgenSystemWithOptions(cmdFormat string, in []*C.VipsImage, outFormat string, inFormat string) (*C.VipsImage, error) {
	var out *C.VipsImage
	ccmdFormat := C.CString(cmdFormat)
	defer freeCString(ccmdFormat)
	cin, cinLength, err := convertToImageArray(in)
	if err != nil {
		return nil, err
	}
	if cin != nil {
		defer freeImageArray(cin)
	}
	coutFormat := C.CString(outFormat)
	defer freeCString(coutFormat)
	cinFormat := C.CString(inFormat)
	defer freeCString(cinFormat)
	if err := C.vipsgen_system_with_options(ccmdFormat, cin, cinLength, coutFormat, cinFormat); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenThumbnail vips_thumbnail generate thumbnail from file
func vipsgenThumbnail(filename string, width int) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_thumbnail(cfilename, &out, C.int(width)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenThumbnailWithOptions vips_thumbnail generate thumbnail from file with optional arguments
func vipsgenThumbnailWithOptions(filename string, width int, height int, size Size, noRotate bool, crop Interesting, linear bool, importProfile string, exportProfile string, intent Intent, failOn FailOn) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	cimportProfile := C.CString(importProfile)
	defer freeCString(cimportProfile)
	cexportProfile := C.CString(exportProfile)
	defer freeCString(cexportProfile)
	if err := C.vipsgen_thumbnail_with_options(cfilename, &out, C.int(width), C.int(height), C.VipsSize(size), C.int(boolToInt(noRotate)), C.VipsInteresting(crop), C.int(boolToInt(linear)), cimportProfile, cexportProfile, C.VipsIntent(intent), C.VipsFailOn(failOn)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenThumbnailBuffer vips_thumbnail_buffer generate thumbnail from buffer
func vipsgenThumbnailBuffer(buf []byte, width int) (*C.VipsImage, error) {
	src := buf
	// Reference src here so it's not garbage collected during image initialization.
	defer runtime.KeepAlive(src)
	var out *C.VipsImage
	if err := C.vipsgen_thumbnail_buffer(unsafe.Pointer(&src[0]), C.size_t(len(src)), &out, C.int(width)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenThumbnailBufferWithOptions vips_thumbnail_buffer generate thumbnail from buffer with optional arguments
func vipsgenThumbnailBufferWithOptions(buf []byte, width int, optionString string, height int, size Size, noRotate bool, crop Interesting, linear bool, importProfile string, exportProfile string, intent Intent, failOn FailOn) (*C.VipsImage, error) {
	src := buf
	// Reference src here so it's not garbage collected during image initialization.
	defer runtime.KeepAlive(src)
	var out *C.VipsImage
	coptionString := C.CString(optionString)
	defer freeCString(coptionString)
	cimportProfile := C.CString(importProfile)
	defer freeCString(cimportProfile)
	cexportProfile := C.CString(exportProfile)
	defer freeCString(cexportProfile)
	if err := C.vipsgen_thumbnail_buffer_with_options(unsafe.Pointer(&src[0]), C.size_t(len(src)), &out, C.int(width), coptionString, C.int(height), C.VipsSize(size), C.int(boolToInt(noRotate)), C.VipsInteresting(crop), C.int(boolToInt(linear)), cimportProfile, cexportProfile, C.VipsIntent(intent), C.VipsFailOn(failOn)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenThumbnailImage vips_thumbnail_image generate thumbnail from image
func vipsgenThumbnailImage(in *C.VipsImage, width int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_thumbnail_image(in, &out, C.int(width)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenThumbnailImageWithOptions vips_thumbnail_image generate thumbnail from image with optional arguments
func vipsgenThumbnailImageWithOptions(in *C.VipsImage, width int, height int, size Size, noRotate bool, crop Interesting, linear bool, importProfile string, exportProfile string, intent Intent, failOn FailOn) (*C.VipsImage, error) {
	var out *C.VipsImage
	cimportProfile := C.CString(importProfile)
	defer freeCString(cimportProfile)
	cexportProfile := C.CString(exportProfile)
	defer freeCString(cexportProfile)
	if err := C.vipsgen_thumbnail_image_with_options(in, &out, C.int(width), C.int(height), C.VipsSize(size), C.int(boolToInt(noRotate)), C.VipsInteresting(crop), C.int(boolToInt(linear)), cimportProfile, cexportProfile, C.VipsIntent(intent), C.VipsFailOn(failOn)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenThumbnailSource vips_thumbnail_source generate thumbnail from source
func vipsgenThumbnailSource(source *C.VipsSourceCustom, width int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_thumbnail_source(source, &out, C.int(width)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenThumbnailSourceWithOptions vips_thumbnail_source generate thumbnail from source with optional arguments
func vipsgenThumbnailSourceWithOptions(source *C.VipsSourceCustom, width int, optionString string, height int, size Size, noRotate bool, crop Interesting, linear bool, importProfile string, exportProfile string, intent Intent, failOn FailOn) (*C.VipsImage, error) {
	var out *C.VipsImage
	coptionString := C.CString(optionString)
	defer freeCString(coptionString)
	cimportProfile := C.CString(importProfile)
	defer freeCString(cimportProfile)
	cexportProfile := C.CString(exportProfile)
	defer freeCString(cexportProfile)
	if err := C.vipsgen_thumbnail_source_with_options(source, &out, C.int(width), coptionString, C.int(height), C.VipsSize(size), C.int(boolToInt(noRotate)), C.VipsInteresting(crop), C.int(boolToInt(linear)), cimportProfile, cexportProfile, C.VipsIntent(intent), C.VipsFailOn(failOn)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenTilecache vips_tilecache cache an image as a set of tiles
func vipsgenTilecache(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_tilecache(in, &out); err != 0 {
		return nil, handleVipsError()
	}
	return out, nil
}

// vipsgenTilecacheWithOptions vips_tilecache cache an image as a set of tiles with optional arguments
func vipsgenTilecacheWithOptions(in *C.VipsImage, tileWidth int, tileHeight int, maxTiles int, access Access, threaded bool, persistent bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_tilecache_with_options(in, &out, C.int(tileWidth), C.int(tileHeight), C.int(maxTiles), C.VipsAccess(access), C.int(boolToInt(threaded)), C.int(boolToInt(persistent))); err != 0 {
		return nil, handleVipsError()
	}
	return out, nil
}

// vipsgenTonelut vips_tonelut build a look-up table
func vipsgenTonelut() (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_tonelut(&out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenTonelutWithOptions vips_tonelut build a look-up table with optional arguments
func vipsgenTonelutWithOptions(inMax int, outMax int, lb float64, lw float64, ps float64, pm float64, ph float64, s float64, m float64, h float64) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_tonelut_with_options(&out, C.int(inMax), C.int(outMax), C.double(lb), C.double(lw), C.double(ps), C.double(pm), C.double(ph), C.double(s), C.double(m), C.double(h)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenTranspose3d vips_transpose3d transpose3d an image
func vipsgenTranspose3d(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_transpose3d(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenTranspose3dWithOptions vips_transpose3d transpose3d an image with optional arguments
func vipsgenTranspose3dWithOptions(in *C.VipsImage, pageHeight int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_transpose3d_with_options(in, &out, C.int(pageHeight)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenUnpremultiply vips_unpremultiply unpremultiply image alpha
func vipsgenUnpremultiply(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_unpremultiply(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenUnpremultiplyWithOptions vips_unpremultiply unpremultiply image alpha with optional arguments
func vipsgenUnpremultiplyWithOptions(in *C.VipsImage, maxAlpha float64, alphaBand int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_unpremultiply_with_options(in, &out, C.double(maxAlpha), C.int(alphaBand)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenVipsload vips_vipsload load vips from file
func vipsgenVipsload(filename string) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_vipsload(cfilename, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenVipsloadWithOptions vips_vipsload load vips from file with optional arguments
func vipsgenVipsloadWithOptions(filename string, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_vipsload_with_options(cfilename, &out, C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenVipsloadSource vips_vipsload_source load vips from source
func vipsgenVipsloadSource(source *C.VipsSourceCustom) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_vipsload_source(source, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenVipsloadSourceWithOptions vips_vipsload_source load vips from source with optional arguments
func vipsgenVipsloadSourceWithOptions(source *C.VipsSourceCustom, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_vipsload_source_with_options(source, &out, C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenVipssave vips_vipssave save image to file in vips format
func vipsgenVipssave(in *C.VipsImage, filename string) (error) {
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_vipssave(in, cfilename); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenVipssaveWithOptions vips_vipssave save image to file in vips format with optional arguments
func vipsgenVipssaveWithOptions(in *C.VipsImage, filename string, keep Keep, background []float64, pageHeight int, profile string) (error) {
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_vipssave_with_options(in, cfilename, C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenVipssaveTarget vips_vipssave_target save image to target in vips format
func vipsgenVipssaveTarget(in *C.VipsImage, target *C.VipsTargetCustom) (error) {
	
	if err := C.vipsgen_vipssave_target(in, target); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenVipssaveTargetWithOptions vips_vipssave_target save image to target in vips format with optional arguments
func vipsgenVipssaveTargetWithOptions(in *C.VipsImage, target *C.VipsTargetCustom, keep Keep, background []float64, pageHeight int, profile string) (error) {
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_vipssave_target_with_options(in, target, C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenWebpload vips_webpload load webp from file
func vipsgenWebpload(filename string) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_webpload(cfilename, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenWebploadWithOptions vips_webpload load webp from file with optional arguments
func vipsgenWebploadWithOptions(filename string, page int, n int, scale float64, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_webpload_with_options(cfilename, &out, C.int(page), C.int(n), C.double(scale), C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenWebploadBuffer vips_webpload_buffer load webp from buffer
func vipsgenWebploadBuffer(buf []byte) (*C.VipsImage, error) {
	src := buf
	// Reference src here so it's not garbage collected during image initialization.
	defer runtime.KeepAlive(src)
	var out *C.VipsImage
	if err := C.vipsgen_webpload_buffer(unsafe.Pointer(&src[0]), C.size_t(len(src)), &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenWebploadBufferWithOptions vips_webpload_buffer load webp from buffer with optional arguments
func vipsgenWebploadBufferWithOptions(buf []byte, page int, n int, scale float64, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	src := buf
	// Reference src here so it's not garbage collected during image initialization.
	defer runtime.KeepAlive(src)
	var out *C.VipsImage
	if err := C.vipsgen_webpload_buffer_with_options(unsafe.Pointer(&src[0]), C.size_t(len(src)), &out, C.int(page), C.int(n), C.double(scale), C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenWebploadSource vips_webpload_source load webp from source
func vipsgenWebploadSource(source *C.VipsSourceCustom) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_webpload_source(source, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenWebploadSourceWithOptions vips_webpload_source load webp from source with optional arguments
func vipsgenWebploadSourceWithOptions(source *C.VipsSourceCustom, page int, n int, scale float64, memory bool, access Access, failOn FailOn, revalidate bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_webpload_source_with_options(source, &out, C.int(page), C.int(n), C.double(scale), C.int(boolToInt(memory)), C.VipsAccess(access), C.VipsFailOn(failOn), C.int(boolToInt(revalidate))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenWebpsave vips_webpsave save as WebP
func vipsgenWebpsave(in *C.VipsImage, filename string) (error) {
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	if err := C.vipsgen_webpsave(in, cfilename); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenWebpsaveWithOptions vips_webpsave save as WebP with optional arguments
func vipsgenWebpsaveWithOptions(in *C.VipsImage, filename string, q int, lossless bool, preset WebpPreset, smartSubsample bool, nearLossless bool, alphaQ int, minSize bool, kmin int, kmax int, effort int, targetSize int, mixed bool, smartDeblock bool, passes int, keep Keep, background []float64, pageHeight int, profile string) (error) {
	cfilename := C.CString(filename)
	defer freeCString(cfilename)
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_webpsave_with_options(in, cfilename, C.int(q), C.int(boolToInt(lossless)), C.VipsForeignWebpPreset(preset), C.int(boolToInt(smartSubsample)), C.int(boolToInt(nearLossless)), C.int(alphaQ), C.int(boolToInt(minSize)), C.int(kmin), C.int(kmax), C.int(effort), C.int(targetSize), C.int(boolToInt(mixed)), C.int(boolToInt(smartDeblock)), C.int(passes), C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenWebpsaveBuffer vips_webpsave_buffer save as WebP
func vipsgenWebpsaveBuffer(in *C.VipsImage) ([]byte, error) {
	var buf unsafe.Pointer
	var length C.size_t
	if err := C.vipsgen_webpsave_buffer(in, &buf, &length); err != 0 {
		return nil, handleVipsError()
	}
	return bufferToBytes(buf, length), nil
}

// vipsgenWebpsaveBufferWithOptions vips_webpsave_buffer save as WebP with optional arguments
func vipsgenWebpsaveBufferWithOptions(in *C.VipsImage, q int, lossless bool, preset WebpPreset, smartSubsample bool, nearLossless bool, alphaQ int, minSize bool, kmin int, kmax int, effort int, targetSize int, mixed bool, smartDeblock bool, passes int, keep Keep, background []float64, pageHeight int, profile string) ([]byte, error) {
	var buf unsafe.Pointer
	var length C.size_t
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return nil, err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_webpsave_buffer_with_options(in, &buf, &length, C.int(q), C.int(boolToInt(lossless)), C.VipsForeignWebpPreset(preset), C.int(boolToInt(smartSubsample)), C.int(boolToInt(nearLossless)), C.int(alphaQ), C.int(boolToInt(minSize)), C.int(kmin), C.int(kmax), C.int(effort), C.int(targetSize), C.int(boolToInt(mixed)), C.int(boolToInt(smartDeblock)), C.int(passes), C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return nil, handleVipsError()
	}
	return bufferToBytes(buf, length), nil
}

// vipsgenWebpsaveTarget vips_webpsave_target save as WebP
func vipsgenWebpsaveTarget(in *C.VipsImage, target *C.VipsTargetCustom) (error) {
	
	if err := C.vipsgen_webpsave_target(in, target); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenWebpsaveTargetWithOptions vips_webpsave_target save as WebP with optional arguments
func vipsgenWebpsaveTargetWithOptions(in *C.VipsImage, target *C.VipsTargetCustom, q int, lossless bool, preset WebpPreset, smartSubsample bool, nearLossless bool, alphaQ int, minSize bool, kmin int, kmax int, effort int, targetSize int, mixed bool, smartDeblock bool, passes int, keep Keep, background []float64, pageHeight int, profile string) (error) {
	cbackground, cbackgroundLength, err := convertToDoubleArray(background)
	if err != nil {
		return err
	}
	if cbackground != nil {
		defer freeDoubleArray(cbackground)
	}
	cprofile := C.CString(profile)
	defer freeCString(cprofile)
	if err := C.vipsgen_webpsave_target_with_options(in, target, C.int(q), C.int(boolToInt(lossless)), C.VipsForeignWebpPreset(preset), C.int(boolToInt(smartSubsample)), C.int(boolToInt(nearLossless)), C.int(alphaQ), C.int(boolToInt(minSize)), C.int(kmin), C.int(kmax), C.int(effort), C.int(targetSize), C.int(boolToInt(mixed)), C.int(boolToInt(smartDeblock)), C.int(passes), C.VipsForeignKeep(keep), cbackground, cbackgroundLength, C.int(pageHeight), cprofile); err != 0 {
		return handleVipsError()
	}
	return nil
}

// vipsgenWorley vips_worley make a worley noise image
func vipsgenWorley(width int, height int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_worley(&out, C.int(width), C.int(height)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenWorleyWithOptions vips_worley make a worley noise image with optional arguments
func vipsgenWorleyWithOptions(width int, height int, cellSize int, seed int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_worley_with_options(&out, C.int(width), C.int(height), C.int(cellSize), C.int(seed)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenWrap vips_wrap wrap image origin
func vipsgenWrap(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_wrap(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenWrapWithOptions vips_wrap wrap image origin with optional arguments
func vipsgenWrapWithOptions(in *C.VipsImage, x int, y int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_wrap_with_options(in, &out, C.int(x), C.int(y)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenXyz vips_xyz make an image where pixel values are coordinates
func vipsgenXyz(width int, height int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_xyz(&out, C.int(width), C.int(height)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenXyzWithOptions vips_xyz make an image where pixel values are coordinates with optional arguments
func vipsgenXyzWithOptions(width int, height int, csize int, dsize int, esize int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_xyz_with_options(&out, C.int(width), C.int(height), C.int(csize), C.int(dsize), C.int(esize)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenZone vips_zone make a zone plate
func vipsgenZone(width int, height int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_zone(&out, C.int(width), C.int(height)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenZoneWithOptions vips_zone make a zone plate with optional arguments
func vipsgenZoneWithOptions(width int, height int, uchar bool) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_zone_with_options(&out, C.int(width), C.int(height), C.int(boolToInt(uchar))); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenZoom vips_zoom zoom an image
func vipsgenZoom(input *C.VipsImage, xfac int, yfac int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_zoom(input, &out, C.int(xfac), C.int(yfac)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}


// clearImage frees the VipsImage
func clearImage(img *C.VipsImage) {
	C.vipsgen_clear_image(&img)
}

// vipsgenImageFromSource vips_image_new_from_source
func vipsgenImageFromSource(src *C.VipsSourceCustom, params *LoadOptions) (*C.VipsImage, error) {
	var out *C.VipsImage
	var code C.int
	var optionString string

	if params != nil {
		optionString = params.OptionString()
	}
	if optionString == "" {
		code = C.vipsgen_image_new_from_source(src, &out)
	} else {
		cOptionString := C.CString(optionString)
		defer freeCString(cOptionString)

		code = C.vipsgen_image_new_from_source_with_option(src, &out, cOptionString)
	}
	if code != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenImageFromBuffer vips_image_new_from_buffer
func vipsgenImageFromBuffer(buf []byte, params *LoadOptions) (*C.VipsImage, error) {
	src := buf
	// Reference src here so it's not garbage collected during image initialization.
	defer runtime.KeepAlive(src)

	var out *C.VipsImage
	var code C.int
	var optionString string
	if params != nil {
		optionString = params.OptionString()
	}
	if optionString == "" {
		code = C.vipsgen_image_new_from_buffer(unsafe.Pointer(&src[0]), C.size_t(len(src)), &out)
	} else {
		cOptionString := C.CString(optionString)
		defer freeCString(cOptionString)

		code = C.vipsgen_image_new_from_buffer_with_option(unsafe.Pointer(&src[0]), C.size_t(len(src)), &out, cOptionString)
	}
	if code != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenImageFromFile vips_image_new_from_file
func vipsgenImageFromFile(path string, params *LoadOptions) (*C.VipsImage, error) {
	// Append options to the filename if needed
	filenameOption := path
	if params != nil && params.OptionString() != "" {
		filenameOption += "[" + params.OptionString() + "]"
	}

	cPath := C.CString(filenameOption)
	defer freeCString(cPath)

	var out *C.VipsImage
	code := C.vipsgen_image_new_from_file(cPath, &out)

	if code != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsgenImageFromMemory vips_image_new_memory
func vipsgenImageFromMemory(buf []byte, width, height, bands int) (*C.VipsImage, error) {
	src := buf
	// Reference src here so it's not garbage collected during image initialization.
	defer runtime.KeepAlive(src)

	var out *C.VipsImage
	var code C.int
	code = C.vipsgen_image_new_from_memory(unsafe.Pointer(&src[0]), C.size_t(len(src)), C.int(width), C.int(height), C.int(bands), &out)
	if code != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

func vipsHasAlpha(in *C.VipsImage) bool {
	return int(C.vips_image_hasalpha(in)) > 0
}

func vipsIsColorSpaceSupported(in *C.VipsImage) bool {
	return int(C.vips_colourspace_issupported(in)) != 0
}

func vipsImageGetFields(in *C.VipsImage) (fields []string) {
	const maxFields = 1024
	rawFields := C.vips_image_get_fields(in)
	defer C.g_strfreev(rawFields)
	cFields := (*[maxFields]*C.char)(unsafe.Pointer(rawFields))[:maxFields:maxFields]
	for _, field := range cFields {
		if field == nil {
			break
		}
		fields = append(fields, C.GoString(field))
	}
	return
}

func vipsImageHasField(in *C.VipsImage, name string) bool {
	cName := C.CString(name)
	defer freeCString(cName)
	return int(C.vips_image_get_typeof(in, cName)) != 0
}

func vipsImageRemoveField(in *C.VipsImage, name string) {
	cName := C.CString(name)
	defer freeCString(cName)
	C.vips_image_remove(in, cName)
}

func vipsImageGetArrayInt(in *C.VipsImage, name string) ([]int, error) {
	var out *C.int
	var n C.int
	cName := C.CString(name)
	defer freeCString(cName)
	if err := C.vips_image_get_array_int(in, cName, &out, &n); err != 0 {
		return nil, handleVipsError()
	}
	result := fromCArrayInt(out, int(n))
	gFreePointer(unsafe.Pointer(out))
	return result, nil
}

func vipsImageGetArrayDouble(in *C.VipsImage, name string) ([]float64, error) {
	var out *C.double
	var n C.int
	cName := C.CString(name)
	defer freeCString(cName)
	if err := C.vips_image_get_array_double(in, cName, &out, &n); err != 0 {
		return nil, handleVipsError()
	}
	result := fromCArrayDouble(out, int(n))
	gFreePointer(unsafe.Pointer(out))
	return result, nil
}

func vipsImageSetBlob(in *C.VipsImage, name string, data []byte) {
	cData := unsafe.Pointer(&data[0])
	cDataLength := C.size_t(len(data))
	cField := C.CString(name)
	defer freeCString(cField)
	C.vips_image_set_blob_copy(in, cField, cData, cDataLength)
}

func vipsImageGetBlob(in *C.VipsImage, name string) ([]byte, error) {
	var bufPtr unsafe.Pointer
	var dataLength C.size_t
	cField := C.CString(name)
	defer freeCString(cField)
	if int(C.vips_image_get_blob(in, cField, &bufPtr, &dataLength)) != 0 {
		return nil, handleVipsError()
	}
	return bufferToBytes(bufPtr, dataLength), nil
}

func vipsHasICCProfile(in *C.VipsImage) bool {
	return int(C.vips_image_get_typeof(in, cachedCString(C.VIPS_META_ICC_NAME))) != 0
}

func vipsGetICCProfile(in *C.VipsImage) ([]byte, bool) {
	if !vipsHasICCProfile(in) {
		return nil, false
	}
	var bufPtr unsafe.Pointer
	var dataLength C.size_t
	if int(C.vips_image_get_blob(in, cachedCString(C.VIPS_META_ICC_NAME), &bufPtr, &dataLength)) != 0 {
		return nil, false
	}
	buf := C.GoBytes(bufPtr, C.int(dataLength))
	return buf, buf != nil
}

func vipsRemoveICCProfile(in *C.VipsImage) bool {
	if vipsHasICCProfile(in) {
		C.vips_image_remove(in, cachedCString(C.VIPS_META_ICC_NAME))
		return true
	}
	return false
}

func vipsHasIPTC(in *C.VipsImage) bool {
	return int(C.vips_image_get_typeof(in, cachedCString(C.VIPS_META_IPTC_NAME))) != 0
}

func vipsGetMetaOrientation(in *C.VipsImage) int {
    orientationFieldName := cachedCString(C.VIPS_META_ORIENTATION)
    if int(C.vips_image_get_typeof(in, orientationFieldName)) == 0 {
        return 0
    }
    var orientation C.int
    if C.vips_image_get_int(in, orientationFieldName, &orientation) == 0 {
        return int(orientation)
    }
    return 0
}

func vipsSetMetaOrientation(in *C.VipsImage, orientation int) {
	C.vips_image_set_int(in, cachedCString(C.VIPS_META_ORIENTATION), C.int(orientation))
}

func vipsRemoveMetaOrientation(in *C.VipsImage) {
	C.vips_image_remove(in, cachedCString(C.VIPS_META_ORIENTATION))
}

func vipsGetImageNPages(in *C.VipsImage) int {
	return int(C.vips_image_get_n_pages(in))
}

func vipsSetImageNPages(in *C.VipsImage, pages int) {
	C.vips_image_set_int(in, cachedCString(C.VIPS_META_N_PAGES), C.int(pages))
}

func vipsGetPageHeight(in *C.VipsImage) int {
	return int(C.vips_image_get_page_height(in))
}

func vipsSetPageHeight(in *C.VipsImage, height int) {
	C.vips_image_set_int(in, cachedCString(C.VIPS_META_PAGE_HEIGHT), C.int(height))
}

func vipsImageSetString(in *C.VipsImage, name string, str string) {
	cField := C.CString(name)
	defer freeCString(cField)
	cStr := C.CString(str)
	defer freeCString(cStr)
	C.vips_image_set_string(in, cField, cStr)
}

func vipsImageGetString(in *C.VipsImage, name string) (string, error) {
	cField := C.CString(name)
	defer freeCString(cField)
	var cFieldValue *C.char
	defer freeCString(cFieldValue)
	if int(C.vips_image_get_string(in, cField, &cFieldValue)) == 0 {
		return C.GoString(cFieldValue), nil
	}
	return "", handleVipsError()
}

func vipsImageGetAsString(in *C.VipsImage, name string) (string, error) {
	cField := C.CString(name)
	defer freeCString(cField)
	var cFieldValue *C.char
	defer freeCString(cFieldValue)
	if int(C.vips_image_get_as_string(in, cField, &cFieldValue)) == 0 {
		return C.GoString(cFieldValue), nil
	}
	return "", handleVipsError()
}

func vipsImageSetDouble(in *C.VipsImage, name string, f float64) {
	cField := C.CString(name)
	defer freeCString(cField)
	cDouble := C.double(f)
	C.vips_image_set_double(in, cField, cDouble)
}

func vipsImageGetDouble(in *C.VipsImage, name string) (float64, error) {
	cField := C.CString(name)
	defer freeCString(cField)
	var cDouble C.double
	if int(C.vips_image_get_double(in, cField, &cDouble)) == 0 {
		return float64(cDouble), nil
	}
	return 0, handleVipsError()
}

func vipsImageSetInt(in *C.VipsImage, name string, i int) {
	cField := C.CString(name)
	defer freeCString(cField)
	cInt := C.int(i)
	C.vips_image_set_int(in, cField, cInt)
}

func vipsImageGetInt(in *C.VipsImage, name string) (int, error) {
	cField := C.CString(name)
	defer freeCString(cField)
	var cInt C.int
	if int(C.vips_image_get_int(in, cField, &cInt)) == 0 {
		return int(cInt), nil
	}
	return 0, handleVipsError()
}

func vipsImageGetMetaLoader(in *C.VipsImage) (string, bool) {
	loaderFieldName := cachedCString(C.VIPS_META_LOADER)
	if int(C.vips_image_get_typeof(in, loaderFieldName)) == 0 {
		return "", false
	}
	var cFieldValue *C.char
	if int(C.vips_image_get_string(in, loaderFieldName, &cFieldValue)) == 0 {
		return C.GoString(cFieldValue), true
	}
	return "", false
}

func vipsgenEmbedMultiPage(in *C.VipsImage, left, top, width, height int, extend Extend) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_embed_multi_page(in, &out, C.int(left), C.int(top), C.int(width), C.int(height), C.int(extend)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

func vipsgenEmbedMultiPageBackground(in *C.VipsImage, left, top, width, height,
	backgroundColorR, backgroundColorG, backgroundColorB, backgroundColorA int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_embed_multi_page_background(in, &out, C.int(left), C.int(top), C.int(width),
		C.int(height), C.double(backgroundColorR),
		C.double(backgroundColorG), C.double(backgroundColorB), C.double(backgroundColorA)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

func vipsgenExtractAreaMultiPage(in *C.VipsImage, left, top, width, height int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_extract_area_multi_page(in, &out, C.int(left), C.int(top), C.int(width), C.int(height)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

func vipsgenRotMultiPage(in *C.VipsImage, angle Angle) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_rot_multi_page(in, &out, C.VipsAngle(angle)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

func vipsgenLabel(
	in *C.VipsImage,
	text, font string,
	x, y, size int, align Align,
	colorR, colorG, colorB int, opacity float64,
) (*C.VipsImage, error) {
	var out *C.VipsImage
	cText := C.CString(text)
	defer freeCString(cText)
	cFont := C.CString(font)
	defer freeCString(cFont)

	err := C.vipsgen_label(in, &out, cText, cFont,
		C.int(x), C.int(y), C.int(size), C.VipsAlign(align),
		C.double(colorR), C.double(colorG), C.double(colorB), C.float(float32(opacity)))
	if int(err) != 0 {
		return nil, handleImageError(out)
	}

	return out, nil
}

func vipsgenRemoveExif(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.vipsgen_remove_exif(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}
