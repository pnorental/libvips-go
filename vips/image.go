// Code generated by github.com/cshum/vipsgen from libvips 8.16.1; DO NOT EDIT.

package vips

// #include "vips.h"
import "C"

import (
	"fmt"
	"strconv"
	"strings"
	"sync"
)

// Image contains a libvips image and manages its lifecycle.
type Image struct {
	// NOTE: We keep a reference to this so that the input buffer is
	// never garbage collected during processing. Some image loaders use random
	// access transcoding and therefore need the original buffer to be in memory.
	buf    []byte
	image  *C.VipsImage
	format ImageType
	lock   sync.Mutex

	pageHeight int // cached page height
}


// AnalyzeloadOptions optional arguments for vips_analyzeload
type AnalyzeloadOptions struct {
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultAnalyzeloadOptions creates default value for vips_analyzeload optional arguments
func DefaultAnalyzeloadOptions() *AnalyzeloadOptions {
	return &AnalyzeloadOptions{
	}
}

// NewAnalyzeload vips_analyzeload load an Analyze6 image
//
// The filename specifies filename to load from.
func NewAnalyzeload(filename string, options *AnalyzeloadOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenAnalyzeloadWithOptions(filename, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeAnalyze, nil), nil
	}
	vipsImage, err := vipsgenAnalyzeload(filename)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeAnalyze, nil), nil
}

// ArrayjoinOptions optional arguments for vips_arrayjoin
type ArrayjoinOptions struct {
	// Across Number of images across grid
	Across int
	// Shim Pixels between images
	Shim int
	// Background Colour for new pixels
	Background []float64
	// Halign Align on the left, centre or right
	Halign Align
	// Valign Align on the top, centre or bottom
	Valign Align
	// Hspacing Horizontal spacing between images
	Hspacing int
	// Vspacing Vertical spacing between images
	Vspacing int
}

// DefaultArrayjoinOptions creates default value for vips_arrayjoin optional arguments
func DefaultArrayjoinOptions() *ArrayjoinOptions {
	return &ArrayjoinOptions{
		Across: 1,
		Hspacing: 1,
		Vspacing: 1,
	}
}

// NewArrayjoin vips_arrayjoin join an array of images
//
// The in specifies array of input images.
func NewArrayjoin(in []*Image, options *ArrayjoinOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenArrayjoinWithOptions(convertImagesToVipsImages(in), options.Across, options.Shim, options.Background, options.Halign, options.Valign, options.Hspacing, options.Vspacing)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenArrayjoin(convertImagesToVipsImages(in))
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}


// NewBandjoin vips_bandjoin bandwise join a set of images
//
// The in specifies array of input images.
func NewBandjoin(in []*Image) (*Image, error) {
	Startup(nil)
	vipsImage, err := vipsgenBandjoin(convertImagesToVipsImages(in))
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// BandrankOptions optional arguments for vips_bandrank
type BandrankOptions struct {
	// Index Select this band element from sorted list
	Index int
}

// DefaultBandrankOptions creates default value for vips_bandrank optional arguments
func DefaultBandrankOptions() *BandrankOptions {
	return &BandrankOptions{
		Index: -1,
	}
}

// NewBandrank vips_bandrank band-wise rank of a set of images
//
// The in specifies array of input images.
func NewBandrank(in []*Image, options *BandrankOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenBandrankWithOptions(convertImagesToVipsImages(in), options.Index)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenBandrank(convertImagesToVipsImages(in))
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// BlackOptions optional arguments for vips_black
type BlackOptions struct {
	// Bands Number of bands in image
	Bands int
}

// DefaultBlackOptions creates default value for vips_black optional arguments
func DefaultBlackOptions() *BlackOptions {
	return &BlackOptions{
		Bands: 1,
	}
}

// NewBlack vips_black make a black image
//
// The width specifies image width in pixels.
// The height specifies image height in pixels.
func NewBlack(width int, height int, options *BlackOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenBlackWithOptions(width, height, options.Bands)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenBlack(width, height)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// CompositeOptions optional arguments for vips_composite
type CompositeOptions struct {
	// X Array of x coordinates to join at
	X []int
	// Y Array of y coordinates to join at
	Y []int
	// CompositingSpace Composite images in this colour space
	CompositingSpace Interpretation
	// Premultiplied Images have premultiplied alpha
	Premultiplied bool
}

// DefaultCompositeOptions creates default value for vips_composite optional arguments
func DefaultCompositeOptions() *CompositeOptions {
	return &CompositeOptions{
		CompositingSpace: Interpretation(22),
	}
}

// NewComposite vips_composite blend an array of images with an array of blend modes
//
// The in specifies array of input images.
// The mode specifies array of VipsBlendMode to join with.
func NewComposite(in []*Image, mode []BlendMode, options *CompositeOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenCompositeWithOptions(convertImagesToVipsImages(in), mode, options.X, options.Y, options.CompositingSpace, options.Premultiplied)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenComposite(convertImagesToVipsImages(in), mode)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// CsvloadOptions optional arguments for vips_csvload
type CsvloadOptions struct {
	// Skip Skip this many lines at the start of the file
	Skip int
	// Lines Read this many lines from the file
	Lines int
	// Whitespace Set of whitespace characters
	Whitespace string
	// Separator Set of separator characters
	Separator string
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultCsvloadOptions creates default value for vips_csvload optional arguments
func DefaultCsvloadOptions() *CsvloadOptions {
	return &CsvloadOptions{
		Whitespace: " ",
		Separator: ";,\t",
	}
}

// NewCsvload vips_csvload load csv
//
// The filename specifies filename to load from.
func NewCsvload(filename string, options *CsvloadOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenCsvloadWithOptions(filename, options.Skip, options.Lines, options.Whitespace, options.Separator, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeCsv, nil), nil
	}
	vipsImage, err := vipsgenCsvload(filename)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeCsv, nil), nil
}

// CsvloadSourceOptions optional arguments for vips_csvload_source
type CsvloadSourceOptions struct {
	// Skip Skip this many lines at the start of the file
	Skip int
	// Lines Read this many lines from the file
	Lines int
	// Whitespace Set of whitespace characters
	Whitespace string
	// Separator Set of separator characters
	Separator string
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultCsvloadSourceOptions creates default value for vips_csvload_source optional arguments
func DefaultCsvloadSourceOptions() *CsvloadSourceOptions {
	return &CsvloadSourceOptions{
		Whitespace: " ",
		Separator: ";,\t",
	}
}

// NewCsvloadSource vips_csvload_source load csv
//
// The source specifies source to load from.
func NewCsvloadSource(source *Source, options *CsvloadSourceOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenCsvloadSourceWithOptions(source.src, options.Skip, options.Lines, options.Whitespace, options.Separator, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeCsv, nil), nil
	}
	vipsImage, err := vipsgenCsvloadSource(source.src)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeCsv, nil), nil
}

// EyeOptions optional arguments for vips_eye
type EyeOptions struct {
	// Uchar Output an unsigned char image
	Uchar bool
	// Factor Maximum spatial frequency
	Factor float64
}

// DefaultEyeOptions creates default value for vips_eye optional arguments
func DefaultEyeOptions() *EyeOptions {
	return &EyeOptions{
		Factor: 0.5,
	}
}

// NewEye vips_eye make an image showing the eye's spatial response
//
// The width specifies image width in pixels.
// The height specifies image height in pixels.
func NewEye(width int, height int, options *EyeOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenEyeWithOptions(width, height, options.Uchar, options.Factor)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenEye(width, height)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}


// NewFractsurf vips_fractsurf make a fractal surface
//
// The width specifies image width in pixels.
// The height specifies image height in pixels.
// The fractalDimension specifies fractal dimension.
func NewFractsurf(width int, height int, fractalDimension float64) (*Image, error) {
	Startup(nil)
	vipsImage, err := vipsgenFractsurf(width, height, fractalDimension)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// GaussmatOptions optional arguments for vips_gaussmat
type GaussmatOptions struct {
	// Separable Generate separable Gaussian
	Separable bool
	// Precision Generate with this precision
	Precision Precision
}

// DefaultGaussmatOptions creates default value for vips_gaussmat optional arguments
func DefaultGaussmatOptions() *GaussmatOptions {
	return &GaussmatOptions{
	}
}

// NewGaussmat vips_gaussmat make a gaussian image
//
// The sigma specifies sigma of Gaussian.
// The minAmpl specifies minimum amplitude of Gaussian.
func NewGaussmat(sigma float64, minAmpl float64, options *GaussmatOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenGaussmatWithOptions(sigma, minAmpl, options.Separable, options.Precision)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenGaussmat(sigma, minAmpl)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// GaussnoiseOptions optional arguments for vips_gaussnoise
type GaussnoiseOptions struct {
	// Sigma Standard deviation of pixels in generated image
	Sigma float64
	// Mean Mean of pixels in generated image
	Mean float64
	// Seed Random number seed
	Seed int
}

// DefaultGaussnoiseOptions creates default value for vips_gaussnoise optional arguments
func DefaultGaussnoiseOptions() *GaussnoiseOptions {
	return &GaussnoiseOptions{
		Sigma: 30,
		Mean: 128,
	}
}

// NewGaussnoise vips_gaussnoise make a gaussnoise image
//
// The width specifies image width in pixels.
// The height specifies image height in pixels.
func NewGaussnoise(width int, height int, options *GaussnoiseOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenGaussnoiseWithOptions(width, height, options.Sigma, options.Mean, options.Seed)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenGaussnoise(width, height)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// GifloadOptions optional arguments for vips_gifload
type GifloadOptions struct {
	// N Number of pages to load, -1 for all
	N int
	// Page First page to load
	Page int
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultGifloadOptions creates default value for vips_gifload optional arguments
func DefaultGifloadOptions() *GifloadOptions {
	return &GifloadOptions{
		N: 1,
	}
}

// NewGifload vips_gifload load GIF with libnsgif
//
// The filename specifies filename to load from.
func NewGifload(filename string, options *GifloadOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenGifloadWithOptions(filename, options.N, options.Page, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeGif, nil), nil
	}
	vipsImage, err := vipsgenGifload(filename)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeGif, nil), nil
}

// GifloadBufferOptions optional arguments for vips_gifload_buffer
type GifloadBufferOptions struct {
	// N Number of pages to load, -1 for all
	N int
	// Page First page to load
	Page int
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultGifloadBufferOptions creates default value for vips_gifload_buffer optional arguments
func DefaultGifloadBufferOptions() *GifloadBufferOptions {
	return &GifloadBufferOptions{
		N: 1,
	}
}

// NewGifloadBuffer vips_gifload_buffer load GIF with libnsgif
func NewGifloadBuffer(buf []byte, options *GifloadBufferOptions) (*Image, error) {
	Startup(nil)
	if len(buf) == 0 {
		return nil, fmt.Errorf("gifload_buffer: buffer is empty")
	}
	if options != nil {
		vipsImage, err := vipsgenGifloadBufferWithOptions(buf, options.N, options.Page, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeGif, buf), nil
	}
	vipsImage, err := vipsgenGifloadBuffer(buf)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeGif, buf), nil
}

// GifloadSourceOptions optional arguments for vips_gifload_source
type GifloadSourceOptions struct {
	// N Number of pages to load, -1 for all
	N int
	// Page First page to load
	Page int
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultGifloadSourceOptions creates default value for vips_gifload_source optional arguments
func DefaultGifloadSourceOptions() *GifloadSourceOptions {
	return &GifloadSourceOptions{
		N: 1,
	}
}

// NewGifloadSource vips_gifload_source load gif from source
//
// The source specifies source to load from.
func NewGifloadSource(source *Source, options *GifloadSourceOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenGifloadSourceWithOptions(source.src, options.N, options.Page, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeGif, nil), nil
	}
	vipsImage, err := vipsgenGifloadSource(source.src)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeGif, nil), nil
}

// GreyOptions optional arguments for vips_grey
type GreyOptions struct {
	// Uchar Output an unsigned char image
	Uchar bool
}

// DefaultGreyOptions creates default value for vips_grey optional arguments
func DefaultGreyOptions() *GreyOptions {
	return &GreyOptions{
	}
}

// NewGrey vips_grey make a grey ramp image
//
// The width specifies image width in pixels.
// The height specifies image height in pixels.
func NewGrey(width int, height int, options *GreyOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenGreyWithOptions(width, height, options.Uchar)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenGrey(width, height)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// HeifloadOptions optional arguments for vips_heifload
type HeifloadOptions struct {
	// Page First page to load
	Page int
	// N Number of pages to load, -1 for all
	N int
	// Thumbnail Fetch thumbnail image
	Thumbnail bool
	// Unlimited Remove all denial of service limits
	Unlimited bool
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultHeifloadOptions creates default value for vips_heifload optional arguments
func DefaultHeifloadOptions() *HeifloadOptions {
	return &HeifloadOptions{
		N: 1,
	}
}

// NewHeifload vips_heifload load a HEIF image
//
// The filename specifies filename to load from.
func NewHeifload(filename string, options *HeifloadOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenHeifloadWithOptions(filename, options.Page, options.N, options.Thumbnail, options.Unlimited, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeHeif, nil), nil
	}
	vipsImage, err := vipsgenHeifload(filename)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeHeif, nil), nil
}

// HeifloadBufferOptions optional arguments for vips_heifload_buffer
type HeifloadBufferOptions struct {
	// Page First page to load
	Page int
	// N Number of pages to load, -1 for all
	N int
	// Thumbnail Fetch thumbnail image
	Thumbnail bool
	// Unlimited Remove all denial of service limits
	Unlimited bool
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultHeifloadBufferOptions creates default value for vips_heifload_buffer optional arguments
func DefaultHeifloadBufferOptions() *HeifloadBufferOptions {
	return &HeifloadBufferOptions{
		N: 1,
	}
}

// NewHeifloadBuffer vips_heifload_buffer load a HEIF image
func NewHeifloadBuffer(buf []byte, options *HeifloadBufferOptions) (*Image, error) {
	Startup(nil)
	if len(buf) == 0 {
		return nil, fmt.Errorf("heifload_buffer: buffer is empty")
	}
	if options != nil {
		vipsImage, err := vipsgenHeifloadBufferWithOptions(buf, options.Page, options.N, options.Thumbnail, options.Unlimited, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeHeif, buf), nil
	}
	vipsImage, err := vipsgenHeifloadBuffer(buf)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeHeif, buf), nil
}

// HeifloadSourceOptions optional arguments for vips_heifload_source
type HeifloadSourceOptions struct {
	// Page First page to load
	Page int
	// N Number of pages to load, -1 for all
	N int
	// Thumbnail Fetch thumbnail image
	Thumbnail bool
	// Unlimited Remove all denial of service limits
	Unlimited bool
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultHeifloadSourceOptions creates default value for vips_heifload_source optional arguments
func DefaultHeifloadSourceOptions() *HeifloadSourceOptions {
	return &HeifloadSourceOptions{
		N: 1,
	}
}

// NewHeifloadSource vips_heifload_source load a HEIF image
//
// The source specifies source to load from.
func NewHeifloadSource(source *Source, options *HeifloadSourceOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenHeifloadSourceWithOptions(source.src, options.Page, options.N, options.Thumbnail, options.Unlimited, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeHeif, nil), nil
	}
	vipsImage, err := vipsgenHeifloadSource(source.src)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeHeif, nil), nil
}

// IdentityOptions optional arguments for vips_identity
type IdentityOptions struct {
	// Bands Number of bands in LUT
	Bands int
	// Ushort Create a 16-bit LUT
	Ushort bool
	// Size Size of 16-bit LUT
	Size int
}

// DefaultIdentityOptions creates default value for vips_identity optional arguments
func DefaultIdentityOptions() *IdentityOptions {
	return &IdentityOptions{
		Bands: 1,
		Size: 65536,
	}
}

// NewIdentity vips_identity make a 1D image where pixel values are indexes
func NewIdentity(options *IdentityOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenIdentityWithOptions(options.Bands, options.Ushort, options.Size)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenIdentity()
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// JpegloadOptions optional arguments for vips_jpegload
type JpegloadOptions struct {
	// Shrink Shrink factor on load
	Shrink int
	// Autorotate Rotate image using exif orientation
	Autorotate bool
	// Unlimited Remove all denial of service limits
	Unlimited bool
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultJpegloadOptions creates default value for vips_jpegload optional arguments
func DefaultJpegloadOptions() *JpegloadOptions {
	return &JpegloadOptions{
		Shrink: 1,
	}
}

// NewJpegload vips_jpegload load jpeg from file
//
// The filename specifies filename to load from.
func NewJpegload(filename string, options *JpegloadOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenJpegloadWithOptions(filename, options.Shrink, options.Autorotate, options.Unlimited, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeJpeg, nil), nil
	}
	vipsImage, err := vipsgenJpegload(filename)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeJpeg, nil), nil
}

// JpegloadBufferOptions optional arguments for vips_jpegload_buffer
type JpegloadBufferOptions struct {
	// Shrink Shrink factor on load
	Shrink int
	// Autorotate Rotate image using exif orientation
	Autorotate bool
	// Unlimited Remove all denial of service limits
	Unlimited bool
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultJpegloadBufferOptions creates default value for vips_jpegload_buffer optional arguments
func DefaultJpegloadBufferOptions() *JpegloadBufferOptions {
	return &JpegloadBufferOptions{
		Shrink: 1,
	}
}

// NewJpegloadBuffer vips_jpegload_buffer load jpeg from buffer
func NewJpegloadBuffer(buf []byte, options *JpegloadBufferOptions) (*Image, error) {
	Startup(nil)
	if len(buf) == 0 {
		return nil, fmt.Errorf("jpegload_buffer: buffer is empty")
	}
	if options != nil {
		vipsImage, err := vipsgenJpegloadBufferWithOptions(buf, options.Shrink, options.Autorotate, options.Unlimited, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeJpeg, buf), nil
	}
	vipsImage, err := vipsgenJpegloadBuffer(buf)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeJpeg, buf), nil
}

// JpegloadSourceOptions optional arguments for vips_jpegload_source
type JpegloadSourceOptions struct {
	// Shrink Shrink factor on load
	Shrink int
	// Autorotate Rotate image using exif orientation
	Autorotate bool
	// Unlimited Remove all denial of service limits
	Unlimited bool
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultJpegloadSourceOptions creates default value for vips_jpegload_source optional arguments
func DefaultJpegloadSourceOptions() *JpegloadSourceOptions {
	return &JpegloadSourceOptions{
		Shrink: 1,
	}
}

// NewJpegloadSource vips_jpegload_source load image from jpeg source
//
// The source specifies source to load from.
func NewJpegloadSource(source *Source, options *JpegloadSourceOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenJpegloadSourceWithOptions(source.src, options.Shrink, options.Autorotate, options.Unlimited, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeJpeg, nil), nil
	}
	vipsImage, err := vipsgenJpegloadSource(source.src)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeJpeg, nil), nil
}

// LogmatOptions optional arguments for vips_logmat
type LogmatOptions struct {
	// Separable Generate separable Gaussian
	Separable bool
	// Precision Generate with this precision
	Precision Precision
}

// DefaultLogmatOptions creates default value for vips_logmat optional arguments
func DefaultLogmatOptions() *LogmatOptions {
	return &LogmatOptions{
	}
}

// NewLogmat vips_logmat make a Laplacian of Gaussian image
//
// The sigma specifies radius of Gaussian.
// The minAmpl specifies minimum amplitude of Gaussian.
func NewLogmat(sigma float64, minAmpl float64, options *LogmatOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenLogmatWithOptions(sigma, minAmpl, options.Separable, options.Precision)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenLogmat(sigma, minAmpl)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// MaskButterworthOptions optional arguments for vips_mask_butterworth
type MaskButterworthOptions struct {
	// Uchar Output an unsigned char image
	Uchar bool
	// Nodc Remove DC component
	Nodc bool
	// Reject Invert the sense of the filter
	Reject bool
	// Optical Rotate quadrants to optical space
	Optical bool
}

// DefaultMaskButterworthOptions creates default value for vips_mask_butterworth optional arguments
func DefaultMaskButterworthOptions() *MaskButterworthOptions {
	return &MaskButterworthOptions{
	}
}

// NewMaskButterworth vips_mask_butterworth make a butterworth filter
//
// The width specifies image width in pixels.
// The height specifies image height in pixels.
// The order specifies filter order.
// The frequencyCutoff specifies frequency cutoff.
// The amplitudeCutoff specifies amplitude cutoff.
func NewMaskButterworth(width int, height int, order float64, frequencyCutoff float64, amplitudeCutoff float64, options *MaskButterworthOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenMaskButterworthWithOptions(width, height, order, frequencyCutoff, amplitudeCutoff, options.Uchar, options.Nodc, options.Reject, options.Optical)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenMaskButterworth(width, height, order, frequencyCutoff, amplitudeCutoff)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// MaskButterworthBandOptions optional arguments for vips_mask_butterworth_band
type MaskButterworthBandOptions struct {
	// Uchar Output an unsigned char image
	Uchar bool
	// Nodc Remove DC component
	Nodc bool
	// Reject Invert the sense of the filter
	Reject bool
	// Optical Rotate quadrants to optical space
	Optical bool
}

// DefaultMaskButterworthBandOptions creates default value for vips_mask_butterworth_band optional arguments
func DefaultMaskButterworthBandOptions() *MaskButterworthBandOptions {
	return &MaskButterworthBandOptions{
	}
}

// NewMaskButterworthBand vips_mask_butterworth_band make a butterworth_band filter
//
// The width specifies image width in pixels.
// The height specifies image height in pixels.
// The order specifies filter order.
// The frequencyCutoffX specifies frequency cutoff x.
// The frequencyCutoffY specifies frequency cutoff y.
// The radius specifies radius of circle.
// The amplitudeCutoff specifies amplitude cutoff.
func NewMaskButterworthBand(width int, height int, order float64, frequencyCutoffX float64, frequencyCutoffY float64, radius float64, amplitudeCutoff float64, options *MaskButterworthBandOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenMaskButterworthBandWithOptions(width, height, order, frequencyCutoffX, frequencyCutoffY, radius, amplitudeCutoff, options.Uchar, options.Nodc, options.Reject, options.Optical)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenMaskButterworthBand(width, height, order, frequencyCutoffX, frequencyCutoffY, radius, amplitudeCutoff)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// MaskButterworthRingOptions optional arguments for vips_mask_butterworth_ring
type MaskButterworthRingOptions struct {
	// Uchar Output an unsigned char image
	Uchar bool
	// Nodc Remove DC component
	Nodc bool
	// Reject Invert the sense of the filter
	Reject bool
	// Optical Rotate quadrants to optical space
	Optical bool
}

// DefaultMaskButterworthRingOptions creates default value for vips_mask_butterworth_ring optional arguments
func DefaultMaskButterworthRingOptions() *MaskButterworthRingOptions {
	return &MaskButterworthRingOptions{
	}
}

// NewMaskButterworthRing vips_mask_butterworth_ring make a butterworth ring filter
//
// The width specifies image width in pixels.
// The height specifies image height in pixels.
// The order specifies filter order.
// The frequencyCutoff specifies frequency cutoff.
// The amplitudeCutoff specifies amplitude cutoff.
// The ringwidth specifies ringwidth.
func NewMaskButterworthRing(width int, height int, order float64, frequencyCutoff float64, amplitudeCutoff float64, ringwidth float64, options *MaskButterworthRingOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenMaskButterworthRingWithOptions(width, height, order, frequencyCutoff, amplitudeCutoff, ringwidth, options.Uchar, options.Nodc, options.Reject, options.Optical)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenMaskButterworthRing(width, height, order, frequencyCutoff, amplitudeCutoff, ringwidth)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// MaskFractalOptions optional arguments for vips_mask_fractal
type MaskFractalOptions struct {
	// Uchar Output an unsigned char image
	Uchar bool
	// Nodc Remove DC component
	Nodc bool
	// Reject Invert the sense of the filter
	Reject bool
	// Optical Rotate quadrants to optical space
	Optical bool
}

// DefaultMaskFractalOptions creates default value for vips_mask_fractal optional arguments
func DefaultMaskFractalOptions() *MaskFractalOptions {
	return &MaskFractalOptions{
	}
}

// NewMaskFractal vips_mask_fractal make fractal filter
//
// The width specifies image width in pixels.
// The height specifies image height in pixels.
// The fractalDimension specifies fractal dimension.
func NewMaskFractal(width int, height int, fractalDimension float64, options *MaskFractalOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenMaskFractalWithOptions(width, height, fractalDimension, options.Uchar, options.Nodc, options.Reject, options.Optical)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenMaskFractal(width, height, fractalDimension)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// MaskGaussianOptions optional arguments for vips_mask_gaussian
type MaskGaussianOptions struct {
	// Uchar Output an unsigned char image
	Uchar bool
	// Nodc Remove DC component
	Nodc bool
	// Reject Invert the sense of the filter
	Reject bool
	// Optical Rotate quadrants to optical space
	Optical bool
}

// DefaultMaskGaussianOptions creates default value for vips_mask_gaussian optional arguments
func DefaultMaskGaussianOptions() *MaskGaussianOptions {
	return &MaskGaussianOptions{
	}
}

// NewMaskGaussian vips_mask_gaussian make a gaussian filter
//
// The width specifies image width in pixels.
// The height specifies image height in pixels.
// The frequencyCutoff specifies frequency cutoff.
// The amplitudeCutoff specifies amplitude cutoff.
func NewMaskGaussian(width int, height int, frequencyCutoff float64, amplitudeCutoff float64, options *MaskGaussianOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenMaskGaussianWithOptions(width, height, frequencyCutoff, amplitudeCutoff, options.Uchar, options.Nodc, options.Reject, options.Optical)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenMaskGaussian(width, height, frequencyCutoff, amplitudeCutoff)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// MaskGaussianBandOptions optional arguments for vips_mask_gaussian_band
type MaskGaussianBandOptions struct {
	// Uchar Output an unsigned char image
	Uchar bool
	// Nodc Remove DC component
	Nodc bool
	// Reject Invert the sense of the filter
	Reject bool
	// Optical Rotate quadrants to optical space
	Optical bool
}

// DefaultMaskGaussianBandOptions creates default value for vips_mask_gaussian_band optional arguments
func DefaultMaskGaussianBandOptions() *MaskGaussianBandOptions {
	return &MaskGaussianBandOptions{
	}
}

// NewMaskGaussianBand vips_mask_gaussian_band make a gaussian filter
//
// The width specifies image width in pixels.
// The height specifies image height in pixels.
// The frequencyCutoffX specifies frequency cutoff x.
// The frequencyCutoffY specifies frequency cutoff y.
// The radius specifies radius of circle.
// The amplitudeCutoff specifies amplitude cutoff.
func NewMaskGaussianBand(width int, height int, frequencyCutoffX float64, frequencyCutoffY float64, radius float64, amplitudeCutoff float64, options *MaskGaussianBandOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenMaskGaussianBandWithOptions(width, height, frequencyCutoffX, frequencyCutoffY, radius, amplitudeCutoff, options.Uchar, options.Nodc, options.Reject, options.Optical)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenMaskGaussianBand(width, height, frequencyCutoffX, frequencyCutoffY, radius, amplitudeCutoff)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// MaskGaussianRingOptions optional arguments for vips_mask_gaussian_ring
type MaskGaussianRingOptions struct {
	// Uchar Output an unsigned char image
	Uchar bool
	// Nodc Remove DC component
	Nodc bool
	// Reject Invert the sense of the filter
	Reject bool
	// Optical Rotate quadrants to optical space
	Optical bool
}

// DefaultMaskGaussianRingOptions creates default value for vips_mask_gaussian_ring optional arguments
func DefaultMaskGaussianRingOptions() *MaskGaussianRingOptions {
	return &MaskGaussianRingOptions{
	}
}

// NewMaskGaussianRing vips_mask_gaussian_ring make a gaussian ring filter
//
// The width specifies image width in pixels.
// The height specifies image height in pixels.
// The frequencyCutoff specifies frequency cutoff.
// The amplitudeCutoff specifies amplitude cutoff.
// The ringwidth specifies ringwidth.
func NewMaskGaussianRing(width int, height int, frequencyCutoff float64, amplitudeCutoff float64, ringwidth float64, options *MaskGaussianRingOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenMaskGaussianRingWithOptions(width, height, frequencyCutoff, amplitudeCutoff, ringwidth, options.Uchar, options.Nodc, options.Reject, options.Optical)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenMaskGaussianRing(width, height, frequencyCutoff, amplitudeCutoff, ringwidth)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// MaskIdealOptions optional arguments for vips_mask_ideal
type MaskIdealOptions struct {
	// Uchar Output an unsigned char image
	Uchar bool
	// Nodc Remove DC component
	Nodc bool
	// Reject Invert the sense of the filter
	Reject bool
	// Optical Rotate quadrants to optical space
	Optical bool
}

// DefaultMaskIdealOptions creates default value for vips_mask_ideal optional arguments
func DefaultMaskIdealOptions() *MaskIdealOptions {
	return &MaskIdealOptions{
	}
}

// NewMaskIdeal vips_mask_ideal make an ideal filter
//
// The width specifies image width in pixels.
// The height specifies image height in pixels.
// The frequencyCutoff specifies frequency cutoff.
func NewMaskIdeal(width int, height int, frequencyCutoff float64, options *MaskIdealOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenMaskIdealWithOptions(width, height, frequencyCutoff, options.Uchar, options.Nodc, options.Reject, options.Optical)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenMaskIdeal(width, height, frequencyCutoff)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// MaskIdealBandOptions optional arguments for vips_mask_ideal_band
type MaskIdealBandOptions struct {
	// Uchar Output an unsigned char image
	Uchar bool
	// Nodc Remove DC component
	Nodc bool
	// Reject Invert the sense of the filter
	Reject bool
	// Optical Rotate quadrants to optical space
	Optical bool
}

// DefaultMaskIdealBandOptions creates default value for vips_mask_ideal_band optional arguments
func DefaultMaskIdealBandOptions() *MaskIdealBandOptions {
	return &MaskIdealBandOptions{
	}
}

// NewMaskIdealBand vips_mask_ideal_band make an ideal band filter
//
// The width specifies image width in pixels.
// The height specifies image height in pixels.
// The frequencyCutoffX specifies frequency cutoff x.
// The frequencyCutoffY specifies frequency cutoff y.
// The radius specifies radius of circle.
func NewMaskIdealBand(width int, height int, frequencyCutoffX float64, frequencyCutoffY float64, radius float64, options *MaskIdealBandOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenMaskIdealBandWithOptions(width, height, frequencyCutoffX, frequencyCutoffY, radius, options.Uchar, options.Nodc, options.Reject, options.Optical)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenMaskIdealBand(width, height, frequencyCutoffX, frequencyCutoffY, radius)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// MaskIdealRingOptions optional arguments for vips_mask_ideal_ring
type MaskIdealRingOptions struct {
	// Uchar Output an unsigned char image
	Uchar bool
	// Nodc Remove DC component
	Nodc bool
	// Reject Invert the sense of the filter
	Reject bool
	// Optical Rotate quadrants to optical space
	Optical bool
}

// DefaultMaskIdealRingOptions creates default value for vips_mask_ideal_ring optional arguments
func DefaultMaskIdealRingOptions() *MaskIdealRingOptions {
	return &MaskIdealRingOptions{
	}
}

// NewMaskIdealRing vips_mask_ideal_ring make an ideal ring filter
//
// The width specifies image width in pixels.
// The height specifies image height in pixels.
// The frequencyCutoff specifies frequency cutoff.
// The ringwidth specifies ringwidth.
func NewMaskIdealRing(width int, height int, frequencyCutoff float64, ringwidth float64, options *MaskIdealRingOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenMaskIdealRingWithOptions(width, height, frequencyCutoff, ringwidth, options.Uchar, options.Nodc, options.Reject, options.Optical)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenMaskIdealRing(width, height, frequencyCutoff, ringwidth)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// MatrixloadOptions optional arguments for vips_matrixload
type MatrixloadOptions struct {
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultMatrixloadOptions creates default value for vips_matrixload optional arguments
func DefaultMatrixloadOptions() *MatrixloadOptions {
	return &MatrixloadOptions{
	}
}

// NewMatrixload vips_matrixload load matrix
//
// The filename specifies filename to load from.
func NewMatrixload(filename string, options *MatrixloadOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenMatrixloadWithOptions(filename, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeMatrix, nil), nil
	}
	vipsImage, err := vipsgenMatrixload(filename)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeMatrix, nil), nil
}

// MatrixloadSourceOptions optional arguments for vips_matrixload_source
type MatrixloadSourceOptions struct {
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultMatrixloadSourceOptions creates default value for vips_matrixload_source optional arguments
func DefaultMatrixloadSourceOptions() *MatrixloadSourceOptions {
	return &MatrixloadSourceOptions{
	}
}

// NewMatrixloadSource vips_matrixload_source load matrix
//
// The source specifies source to load from.
func NewMatrixloadSource(source *Source, options *MatrixloadSourceOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenMatrixloadSourceWithOptions(source.src, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeMatrix, nil), nil
	}
	vipsImage, err := vipsgenMatrixloadSource(source.src)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeMatrix, nil), nil
}

// PerlinOptions optional arguments for vips_perlin
type PerlinOptions struct {
	// CellSize Size of Perlin cells
	CellSize int
	// Uchar Output an unsigned char image
	Uchar bool
	// Seed Random number seed
	Seed int
}

// DefaultPerlinOptions creates default value for vips_perlin optional arguments
func DefaultPerlinOptions() *PerlinOptions {
	return &PerlinOptions{
		CellSize: 256,
	}
}

// NewPerlin vips_perlin make a perlin noise image
//
// The width specifies image width in pixels.
// The height specifies image height in pixels.
func NewPerlin(width int, height int, options *PerlinOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenPerlinWithOptions(width, height, options.CellSize, options.Uchar, options.Seed)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenPerlin(width, height)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// PngloadOptions optional arguments for vips_pngload
type PngloadOptions struct {
	// Unlimited Remove all denial of service limits
	Unlimited bool
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultPngloadOptions creates default value for vips_pngload optional arguments
func DefaultPngloadOptions() *PngloadOptions {
	return &PngloadOptions{
	}
}

// NewPngload vips_pngload load png from file
//
// The filename specifies filename to load from.
func NewPngload(filename string, options *PngloadOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenPngloadWithOptions(filename, options.Unlimited, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypePng, nil), nil
	}
	vipsImage, err := vipsgenPngload(filename)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypePng, nil), nil
}

// PngloadBufferOptions optional arguments for vips_pngload_buffer
type PngloadBufferOptions struct {
	// Unlimited Remove all denial of service limits
	Unlimited bool
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultPngloadBufferOptions creates default value for vips_pngload_buffer optional arguments
func DefaultPngloadBufferOptions() *PngloadBufferOptions {
	return &PngloadBufferOptions{
	}
}

// NewPngloadBuffer vips_pngload_buffer load png from buffer
func NewPngloadBuffer(buf []byte, options *PngloadBufferOptions) (*Image, error) {
	Startup(nil)
	if len(buf) == 0 {
		return nil, fmt.Errorf("pngload_buffer: buffer is empty")
	}
	if options != nil {
		vipsImage, err := vipsgenPngloadBufferWithOptions(buf, options.Unlimited, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypePng, buf), nil
	}
	vipsImage, err := vipsgenPngloadBuffer(buf)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypePng, buf), nil
}

// PngloadSourceOptions optional arguments for vips_pngload_source
type PngloadSourceOptions struct {
	// Unlimited Remove all denial of service limits
	Unlimited bool
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultPngloadSourceOptions creates default value for vips_pngload_source optional arguments
func DefaultPngloadSourceOptions() *PngloadSourceOptions {
	return &PngloadSourceOptions{
	}
}

// NewPngloadSource vips_pngload_source load png from source
//
// The source specifies source to load from.
func NewPngloadSource(source *Source, options *PngloadSourceOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenPngloadSourceWithOptions(source.src, options.Unlimited, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypePng, nil), nil
	}
	vipsImage, err := vipsgenPngloadSource(source.src)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypePng, nil), nil
}

// PpmloadOptions optional arguments for vips_ppmload
type PpmloadOptions struct {
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultPpmloadOptions creates default value for vips_ppmload optional arguments
func DefaultPpmloadOptions() *PpmloadOptions {
	return &PpmloadOptions{
	}
}

// NewPpmload vips_ppmload load ppm from file
//
// The filename specifies filename to load from.
func NewPpmload(filename string, options *PpmloadOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenPpmloadWithOptions(filename, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypePpm, nil), nil
	}
	vipsImage, err := vipsgenPpmload(filename)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypePpm, nil), nil
}

// PpmloadSourceOptions optional arguments for vips_ppmload_source
type PpmloadSourceOptions struct {
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultPpmloadSourceOptions creates default value for vips_ppmload_source optional arguments
func DefaultPpmloadSourceOptions() *PpmloadSourceOptions {
	return &PpmloadSourceOptions{
	}
}

// NewPpmloadSource vips_ppmload_source load ppm base class
//
// The source specifies source to load from.
func NewPpmloadSource(source *Source, options *PpmloadSourceOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenPpmloadSourceWithOptions(source.src, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypePpm, nil), nil
	}
	vipsImage, err := vipsgenPpmloadSource(source.src)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypePpm, nil), nil
}

// RadloadOptions optional arguments for vips_radload
type RadloadOptions struct {
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultRadloadOptions creates default value for vips_radload optional arguments
func DefaultRadloadOptions() *RadloadOptions {
	return &RadloadOptions{
	}
}

// NewRadload vips_radload load a Radiance image from a file
//
// The filename specifies filename to load from.
func NewRadload(filename string, options *RadloadOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenRadloadWithOptions(filename, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeRad, nil), nil
	}
	vipsImage, err := vipsgenRadload(filename)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeRad, nil), nil
}

// RadloadBufferOptions optional arguments for vips_radload_buffer
type RadloadBufferOptions struct {
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultRadloadBufferOptions creates default value for vips_radload_buffer optional arguments
func DefaultRadloadBufferOptions() *RadloadBufferOptions {
	return &RadloadBufferOptions{
	}
}

// NewRadloadBuffer vips_radload_buffer load rad from buffer
func NewRadloadBuffer(buf []byte, options *RadloadBufferOptions) (*Image, error) {
	Startup(nil)
	if len(buf) == 0 {
		return nil, fmt.Errorf("radload_buffer: buffer is empty")
	}
	if options != nil {
		vipsImage, err := vipsgenRadloadBufferWithOptions(buf, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeRad, buf), nil
	}
	vipsImage, err := vipsgenRadloadBuffer(buf)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeRad, buf), nil
}

// RadloadSourceOptions optional arguments for vips_radload_source
type RadloadSourceOptions struct {
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultRadloadSourceOptions creates default value for vips_radload_source optional arguments
func DefaultRadloadSourceOptions() *RadloadSourceOptions {
	return &RadloadSourceOptions{
	}
}

// NewRadloadSource vips_radload_source load rad from source
//
// The source specifies source to load from.
func NewRadloadSource(source *Source, options *RadloadSourceOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenRadloadSourceWithOptions(source.src, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeRad, nil), nil
	}
	vipsImage, err := vipsgenRadloadSource(source.src)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeRad, nil), nil
}

// RawloadOptions optional arguments for vips_rawload
type RawloadOptions struct {
	// Offset Offset in bytes from start of file
	Offset uint64
	// Format Pixel format in image
	Format BandFormat
	// Interpretation Pixel interpretation
	Interpretation Interpretation
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultRawloadOptions creates default value for vips_rawload optional arguments
func DefaultRawloadOptions() *RawloadOptions {
	return &RawloadOptions{
	}
}

// NewRawload vips_rawload load raw data from a file
//
// The filename specifies filename to load from.
// The width specifies image width in pixels.
// The height specifies image height in pixels.
// The bands specifies number of bands in image.
func NewRawload(filename string, width int, height int, bands int, options *RawloadOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenRawloadWithOptions(filename, width, height, bands, options.Offset, options.Format, options.Interpretation, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeRaw, nil), nil
	}
	vipsImage, err := vipsgenRawload(filename, width, height, bands)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeRaw, nil), nil
}

// SdfOptions optional arguments for vips_sdf
type SdfOptions struct {
	// R Radius
	R float64
	// A Point a
	A []float64
	// B Point b
	B []float64
	// Corners Corner radii
	Corners []float64
}

// DefaultSdfOptions creates default value for vips_sdf optional arguments
func DefaultSdfOptions() *SdfOptions {
	return &SdfOptions{
		R: 50,
	}
}

// NewSdf vips_sdf create an SDF image
//
// The width specifies image width in pixels.
// The height specifies image height in pixels.
// The shape specifies sDF shape to create.
func NewSdf(width int, height int, shape SdfShape, options *SdfOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenSdfWithOptions(width, height, shape, options.R, options.A, options.B, options.Corners)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenSdf(width, height, shape)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// SinesOptions optional arguments for vips_sines
type SinesOptions struct {
	// Uchar Output an unsigned char image
	Uchar bool
	// Hfreq Horizontal spatial frequency
	Hfreq float64
	// Vfreq Vertical spatial frequency
	Vfreq float64
}

// DefaultSinesOptions creates default value for vips_sines optional arguments
func DefaultSinesOptions() *SinesOptions {
	return &SinesOptions{
		Hfreq: 0.5,
		Vfreq: 0.5,
	}
}

// NewSines vips_sines make a 2D sine wave
//
// The width specifies image width in pixels.
// The height specifies image height in pixels.
func NewSines(width int, height int, options *SinesOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenSinesWithOptions(width, height, options.Uchar, options.Hfreq, options.Vfreq)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenSines(width, height)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}


// NewSum vips_sum sum an array of images
//
// The in specifies array of input images.
func NewSum(in []*Image) (*Image, error) {
	Startup(nil)
	vipsImage, err := vipsgenSum(convertImagesToVipsImages(in))
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}


// NewSwitch vips_switch find the index of the first non-zero pixel in tests
//
// The tests specifies table of images to test.
func NewSwitch(tests []*Image) (*Image, error) {
	Startup(nil)
	vipsImage, err := vipsgenSwitch(convertImagesToVipsImages(tests))
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// SystemOptions optional arguments for vips_system
type SystemOptions struct {
	// In Array of input images
	In []*Image
	// OutFormat Format for output filename
	OutFormat string
	// InFormat Format for input filename
	InFormat string
}

// DefaultSystemOptions creates default value for vips_system optional arguments
func DefaultSystemOptions() *SystemOptions {
	return &SystemOptions{
	}
}

// NewSystem vips_system run an external command
//
// The cmdFormat specifies command to run.
func NewSystem(cmdFormat string, options *SystemOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenSystemWithOptions(cmdFormat, convertImagesToVipsImages(options.In), options.OutFormat, options.InFormat)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenSystem(cmdFormat)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// ThumbnailOptions optional arguments for vips_thumbnail
type ThumbnailOptions struct {
	// Height Size to this height
	Height int
	// Size Only upsize, only downsize, or both
	Size Size
	// NoRotate Don't use orientation tags to rotate image upright
	NoRotate bool
	// Crop Reduce to fill target rectangle, then crop
	Crop Interesting
	// Linear Reduce in linear light
	Linear bool
	// ImportProfile Fallback import profile
	ImportProfile string
	// ExportProfile Fallback export profile
	ExportProfile string
	// Intent Rendering intent
	Intent Intent
	// FailOn Error level to fail on
	FailOn FailOn
}

// DefaultThumbnailOptions creates default value for vips_thumbnail optional arguments
func DefaultThumbnailOptions() *ThumbnailOptions {
	return &ThumbnailOptions{
		Height: 1,
		Intent: Intent(1),
	}
}

// NewThumbnail vips_thumbnail generate thumbnail from file
//
// The filename specifies filename to read from.
// The width specifies size to this width.
func NewThumbnail(filename string, width int, options *ThumbnailOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenThumbnailWithOptions(filename, width, options.Height, options.Size, options.NoRotate, options.Crop, options.Linear, options.ImportProfile, options.ExportProfile, options.Intent, options.FailOn)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, vipsDetermineImageType(vipsImage), nil), nil
	}
	vipsImage, err := vipsgenThumbnail(filename, width)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, vipsDetermineImageType(vipsImage), nil), nil
}

// ThumbnailBufferOptions optional arguments for vips_thumbnail_buffer
type ThumbnailBufferOptions struct {
	// OptionString Options that are passed on to the underlying loader
	OptionString string
	// Height Size to this height
	Height int
	// Size Only upsize, only downsize, or both
	Size Size
	// NoRotate Don't use orientation tags to rotate image upright
	NoRotate bool
	// Crop Reduce to fill target rectangle, then crop
	Crop Interesting
	// Linear Reduce in linear light
	Linear bool
	// ImportProfile Fallback import profile
	ImportProfile string
	// ExportProfile Fallback export profile
	ExportProfile string
	// Intent Rendering intent
	Intent Intent
	// FailOn Error level to fail on
	FailOn FailOn
}

// DefaultThumbnailBufferOptions creates default value for vips_thumbnail_buffer optional arguments
func DefaultThumbnailBufferOptions() *ThumbnailBufferOptions {
	return &ThumbnailBufferOptions{
		Height: 1,
		Intent: Intent(1),
	}
}

// NewThumbnailBuffer vips_thumbnail_buffer generate thumbnail from buffer
//
// The width specifies size to this width.
func NewThumbnailBuffer(buf []byte, width int, options *ThumbnailBufferOptions) (*Image, error) {
	Startup(nil)
	if len(buf) == 0 {
		return nil, fmt.Errorf("thumbnail_buffer: buffer is empty")
	}
	if options != nil {
		vipsImage, err := vipsgenThumbnailBufferWithOptions(buf, width, options.OptionString, options.Height, options.Size, options.NoRotate, options.Crop, options.Linear, options.ImportProfile, options.ExportProfile, options.Intent, options.FailOn)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, vipsDetermineImageType(vipsImage), buf), nil
	}
	vipsImage, err := vipsgenThumbnailBuffer(buf, width)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, vipsDetermineImageType(vipsImage), buf), nil
}

// ThumbnailSourceOptions optional arguments for vips_thumbnail_source
type ThumbnailSourceOptions struct {
	// OptionString Options that are passed on to the underlying loader
	OptionString string
	// Height Size to this height
	Height int
	// Size Only upsize, only downsize, or both
	Size Size
	// NoRotate Don't use orientation tags to rotate image upright
	NoRotate bool
	// Crop Reduce to fill target rectangle, then crop
	Crop Interesting
	// Linear Reduce in linear light
	Linear bool
	// ImportProfile Fallback import profile
	ImportProfile string
	// ExportProfile Fallback export profile
	ExportProfile string
	// Intent Rendering intent
	Intent Intent
	// FailOn Error level to fail on
	FailOn FailOn
}

// DefaultThumbnailSourceOptions creates default value for vips_thumbnail_source optional arguments
func DefaultThumbnailSourceOptions() *ThumbnailSourceOptions {
	return &ThumbnailSourceOptions{
		Height: 1,
		Intent: Intent(1),
	}
}

// NewThumbnailSource vips_thumbnail_source generate thumbnail from source
//
// The source specifies source to load from.
// The width specifies size to this width.
func NewThumbnailSource(source *Source, width int, options *ThumbnailSourceOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenThumbnailSourceWithOptions(source.src, width, options.OptionString, options.Height, options.Size, options.NoRotate, options.Crop, options.Linear, options.ImportProfile, options.ExportProfile, options.Intent, options.FailOn)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, vipsDetermineImageType(vipsImage), nil), nil
	}
	vipsImage, err := vipsgenThumbnailSource(source.src, width)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, vipsDetermineImageType(vipsImage), nil), nil
}

// TonelutOptions optional arguments for vips_tonelut
type TonelutOptions struct {
	// InMax Size of LUT to build
	InMax int
	// OutMax Maximum value in output LUT
	OutMax int
	// Lb Lowest value in output
	Lb float64
	// Lw Highest value in output
	Lw float64
	// Ps Position of shadow
	Ps float64
	// Pm Position of mid-tones
	Pm float64
	// Ph Position of highlights
	Ph float64
	// S Adjust shadows by this much
	S float64
	// M Adjust mid-tones by this much
	M float64
	// H Adjust highlights by this much
	H float64
}

// DefaultTonelutOptions creates default value for vips_tonelut optional arguments
func DefaultTonelutOptions() *TonelutOptions {
	return &TonelutOptions{
		InMax: 32767,
		OutMax: 32767,
		Lw: 100,
		Ps: 0.2,
		Pm: 0.5,
		Ph: 0.8,
	}
}

// NewTonelut vips_tonelut build a look-up table
func NewTonelut(options *TonelutOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenTonelutWithOptions(options.InMax, options.OutMax, options.Lb, options.Lw, options.Ps, options.Pm, options.Ph, options.S, options.M, options.H)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenTonelut()
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// VipsloadOptions optional arguments for vips_vipsload
type VipsloadOptions struct {
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultVipsloadOptions creates default value for vips_vipsload optional arguments
func DefaultVipsloadOptions() *VipsloadOptions {
	return &VipsloadOptions{
	}
}

// NewVipsload vips_vipsload load vips from file
//
// The filename specifies filename to load from.
func NewVipsload(filename string, options *VipsloadOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenVipsloadWithOptions(filename, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeVips, nil), nil
	}
	vipsImage, err := vipsgenVipsload(filename)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeVips, nil), nil
}

// VipsloadSourceOptions optional arguments for vips_vipsload_source
type VipsloadSourceOptions struct {
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultVipsloadSourceOptions creates default value for vips_vipsload_source optional arguments
func DefaultVipsloadSourceOptions() *VipsloadSourceOptions {
	return &VipsloadSourceOptions{
	}
}

// NewVipsloadSource vips_vipsload_source load vips from source
//
// The source specifies source to load from.
func NewVipsloadSource(source *Source, options *VipsloadSourceOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenVipsloadSourceWithOptions(source.src, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeVips, nil), nil
	}
	vipsImage, err := vipsgenVipsloadSource(source.src)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeVips, nil), nil
}

// WebploadOptions optional arguments for vips_webpload
type WebploadOptions struct {
	// Page First page to load
	Page int
	// N Number of pages to load, -1 for all
	N int
	// Scale Factor to scale by
	Scale float64
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultWebploadOptions creates default value for vips_webpload optional arguments
func DefaultWebploadOptions() *WebploadOptions {
	return &WebploadOptions{
		N: 1,
		Scale: 1,
	}
}

// NewWebpload vips_webpload load webp from file
//
// The filename specifies filename to load from.
func NewWebpload(filename string, options *WebploadOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenWebploadWithOptions(filename, options.Page, options.N, options.Scale, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeWebp, nil), nil
	}
	vipsImage, err := vipsgenWebpload(filename)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeWebp, nil), nil
}

// WebploadBufferOptions optional arguments for vips_webpload_buffer
type WebploadBufferOptions struct {
	// Page First page to load
	Page int
	// N Number of pages to load, -1 for all
	N int
	// Scale Factor to scale by
	Scale float64
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultWebploadBufferOptions creates default value for vips_webpload_buffer optional arguments
func DefaultWebploadBufferOptions() *WebploadBufferOptions {
	return &WebploadBufferOptions{
		N: 1,
		Scale: 1,
	}
}

// NewWebploadBuffer vips_webpload_buffer load webp from buffer
func NewWebploadBuffer(buf []byte, options *WebploadBufferOptions) (*Image, error) {
	Startup(nil)
	if len(buf) == 0 {
		return nil, fmt.Errorf("webpload_buffer: buffer is empty")
	}
	if options != nil {
		vipsImage, err := vipsgenWebploadBufferWithOptions(buf, options.Page, options.N, options.Scale, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeWebp, buf), nil
	}
	vipsImage, err := vipsgenWebploadBuffer(buf)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeWebp, buf), nil
}

// WebploadSourceOptions optional arguments for vips_webpload_source
type WebploadSourceOptions struct {
	// Page First page to load
	Page int
	// N Number of pages to load, -1 for all
	N int
	// Scale Factor to scale by
	Scale float64
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
	// FailOn Error level to fail on
	FailOn FailOn
	// Revalidate Don't use a cached result for this operation
	Revalidate bool
}

// DefaultWebploadSourceOptions creates default value for vips_webpload_source optional arguments
func DefaultWebploadSourceOptions() *WebploadSourceOptions {
	return &WebploadSourceOptions{
		N: 1,
		Scale: 1,
	}
}

// NewWebploadSource vips_webpload_source load webp from source
//
// The source specifies source to load from.
func NewWebploadSource(source *Source, options *WebploadSourceOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenWebploadSourceWithOptions(source.src, options.Page, options.N, options.Scale, options.Memory, options.Access, options.FailOn, options.Revalidate)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeWebp, nil), nil
	}
	vipsImage, err := vipsgenWebploadSource(source.src)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeWebp, nil), nil
}

// WorleyOptions optional arguments for vips_worley
type WorleyOptions struct {
	// CellSize Size of Worley cells
	CellSize int
	// Seed Random number seed
	Seed int
}

// DefaultWorleyOptions creates default value for vips_worley optional arguments
func DefaultWorleyOptions() *WorleyOptions {
	return &WorleyOptions{
		CellSize: 256,
	}
}

// NewWorley vips_worley make a worley noise image
//
// The width specifies image width in pixels.
// The height specifies image height in pixels.
func NewWorley(width int, height int, options *WorleyOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenWorleyWithOptions(width, height, options.CellSize, options.Seed)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenWorley(width, height)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// XyzOptions optional arguments for vips_xyz
type XyzOptions struct {
	// Csize Size of third dimension
	Csize int
	// Dsize Size of fourth dimension
	Dsize int
	// Esize Size of fifth dimension
	Esize int
}

// DefaultXyzOptions creates default value for vips_xyz optional arguments
func DefaultXyzOptions() *XyzOptions {
	return &XyzOptions{
		Csize: 1,
		Dsize: 1,
		Esize: 1,
	}
}

// NewXyz vips_xyz make an image where pixel values are coordinates
//
// The width specifies image width in pixels.
// The height specifies image height in pixels.
func NewXyz(width int, height int, options *XyzOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenXyzWithOptions(width, height, options.Csize, options.Dsize, options.Esize)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenXyz(width, height)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}

// ZoneOptions optional arguments for vips_zone
type ZoneOptions struct {
	// Uchar Output an unsigned char image
	Uchar bool
}

// DefaultZoneOptions creates default value for vips_zone optional arguments
func DefaultZoneOptions() *ZoneOptions {
	return &ZoneOptions{
	}
}

// NewZone vips_zone make a zone plate
//
// The width specifies image width in pixels.
// The height specifies image height in pixels.
func NewZone(width int, height int, options *ZoneOptions) (*Image, error) {
	Startup(nil)
	if options != nil {
		vipsImage, err := vipsgenZoneWithOptions(width, height, options.Uchar)
		if err != nil {
			return nil, err
		}
		return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
	}
	vipsImage, err := vipsgenZone(width, height)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, nil), nil
}




// CMC2LCh vips_CMC2LCh transform LCh to CMC
func (r *Image) CMC2LCh() (error) {
	out, err := vipsgenCMC2LCh(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// CMYK2XYZ vips_CMYK2XYZ transform CMYK to XYZ
func (r *Image) CMYK2XYZ() (error) {
	out, err := vipsgenCMYK2XYZ(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// HSV2sRGB vips_HSV2sRGB transform HSV to sRGB
func (r *Image) HSV2sRGB() (error) {
	out, err := vipsgenHSV2sRGB(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// LCh2CMC vips_LCh2CMC transform LCh to CMC
func (r *Image) LCh2CMC() (error) {
	out, err := vipsgenLCh2CMC(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// LCh2Lab vips_LCh2Lab transform LCh to Lab
func (r *Image) LCh2Lab() (error) {
	out, err := vipsgenLCh2Lab(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Lab2LCh vips_Lab2LCh transform Lab to LCh
func (r *Image) Lab2LCh() (error) {
	out, err := vipsgenLab2LCh(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Lab2LabQ vips_Lab2LabQ transform float Lab to LabQ coding
func (r *Image) Lab2LabQ() (error) {
	out, err := vipsgenLab2LabQ(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Lab2LabS vips_Lab2LabS transform float Lab to signed short
func (r *Image) Lab2LabS() (error) {
	out, err := vipsgenLab2LabS(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// Lab2XYZOptions optional arguments for vips_Lab2XYZ
type Lab2XYZOptions struct {
	// Temp Color temperature
	Temp []float64
}

// DefaultLab2XYZOptions creates default value for vips_Lab2XYZ optional arguments
func DefaultLab2XYZOptions() *Lab2XYZOptions {
	return &Lab2XYZOptions{
	}
}

// Lab2XYZ vips_Lab2XYZ transform CIELAB to XYZ
func (r *Image) Lab2XYZ(options *Lab2XYZOptions) (error) {
	if options != nil {
		out, err := vipsgenLab2XYZWithOptions(r.image, options.Temp)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenLab2XYZ(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// LabQ2Lab vips_LabQ2Lab unpack a LabQ image to float Lab
func (r *Image) LabQ2Lab() (error) {
	out, err := vipsgenLabQ2Lab(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// LabQ2LabS vips_LabQ2LabS unpack a LabQ image to short Lab
func (r *Image) LabQ2LabS() (error) {
	out, err := vipsgenLabQ2LabS(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// LabQ2sRGB vips_LabQ2sRGB convert a LabQ image to sRGB
func (r *Image) LabQ2sRGB() (error) {
	out, err := vipsgenLabQ2sRGB(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// LabS2Lab vips_LabS2Lab transform signed short Lab to float
func (r *Image) LabS2Lab() (error) {
	out, err := vipsgenLabS2Lab(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// LabS2LabQ vips_LabS2LabQ transform short Lab to LabQ coding
func (r *Image) LabS2LabQ() (error) {
	out, err := vipsgenLabS2LabQ(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// XYZ2CMYK vips_XYZ2CMYK transform XYZ to CMYK
func (r *Image) XYZ2CMYK() (error) {
	out, err := vipsgenXYZ2CMYK(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// XYZ2LabOptions optional arguments for vips_XYZ2Lab
type XYZ2LabOptions struct {
	// Temp Colour temperature
	Temp []float64
}

// DefaultXYZ2LabOptions creates default value for vips_XYZ2Lab optional arguments
func DefaultXYZ2LabOptions() *XYZ2LabOptions {
	return &XYZ2LabOptions{
	}
}

// XYZ2Lab vips_XYZ2Lab transform XYZ to Lab
func (r *Image) XYZ2Lab(options *XYZ2LabOptions) (error) {
	if options != nil {
		out, err := vipsgenXYZ2LabWithOptions(r.image, options.Temp)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenXYZ2Lab(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// XYZ2Yxy vips_XYZ2Yxy transform XYZ to Yxy
func (r *Image) XYZ2Yxy() (error) {
	out, err := vipsgenXYZ2Yxy(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// XYZ2scRGB vips_XYZ2scRGB transform XYZ to scRGB
func (r *Image) XYZ2scRGB() (error) {
	out, err := vipsgenXYZ2scRGB(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Yxy2XYZ vips_Yxy2XYZ transform Yxy to XYZ
func (r *Image) Yxy2XYZ() (error) {
	out, err := vipsgenYxy2XYZ(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Abs vips_abs absolute value of an image
func (r *Image) Abs() (error) {
	out, err := vipsgenAbs(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Add vips_add add two images
//
// The right specifies right-hand image argument.
func (r *Image) Add(right *Image) (error) {
	out, err := vipsgenAdd(r.image, right.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Addalpha vips_addalpha append an alpha channel
func (r *Image) Addalpha() (error) {
	out, err := vipsgenAddalpha(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// AffineOptions optional arguments for vips_affine
type AffineOptions struct {
	// Interpolate Interpolate pixels with this
	Interpolate *Interpolate
	// Oarea Area of output to generate
	Oarea []int
	// Odx Horizontal output displacement
	Odx float64
	// Ody Vertical output displacement
	Ody float64
	// Idx Horizontal input displacement
	Idx float64
	// Idy Vertical input displacement
	Idy float64
	// Background Background value
	Background []float64
	// Premultiplied Images have premultiplied alpha
	Premultiplied bool
	// Extend How to generate the extra pixels
	Extend Extend
}

// DefaultAffineOptions creates default value for vips_affine optional arguments
func DefaultAffineOptions() *AffineOptions {
	return &AffineOptions{
		Extend: Extend(5),
	}
}

// Affine vips_affine affine transform of an image
//
// The a specifies coefficient a (horizontal scale).
// The b specifies coefficient b (horizontal shear).
// The c specifies coefficient c (vertical shear).
// The d specifies coefficient d (vertical scale).
func (r *Image) Affine(a float64, b float64, c float64, d float64, options *AffineOptions) (error) {
	if options != nil {
		out, err := vipsgenAffineWithOptions(r.image, a, b, c, d, options.Interpolate, options.Oarea, options.Odx, options.Ody, options.Idx, options.Idy, options.Background, options.Premultiplied, options.Extend)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenAffine(r.image, a, b, c, d)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Autorot vips_autorot autorotate image by exif tag
func (r *Image) Autorot() (error) {
	out, err := vipsgenAutorot(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Avg vips_avg find image average
func (r *Image) Avg() (float64, error) {
	out, err := vipsgenAvg(r.image)
	if err != nil {
		return 0, err
	}
	return out, nil
}


// Bandbool vips_bandbool boolean operation across image bands
//
// The boolean specifies boolean to perform.
func (r *Image) Bandbool(boolean OperationBoolean) (error) {
	out, err := vipsgenBandbool(r.image, boolean)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// BandfoldOptions optional arguments for vips_bandfold
type BandfoldOptions struct {
	// Factor Fold by this factor
	Factor int
}

// DefaultBandfoldOptions creates default value for vips_bandfold optional arguments
func DefaultBandfoldOptions() *BandfoldOptions {
	return &BandfoldOptions{
	}
}

// Bandfold vips_bandfold fold up x axis into bands
func (r *Image) Bandfold(options *BandfoldOptions) (error) {
	if options != nil {
		out, err := vipsgenBandfoldWithOptions(r.image, options.Factor)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenBandfold(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// BandjoinConst vips_bandjoin_const append a constant band to an image
//
// The c specifies array of constants to add.
func (r *Image) BandjoinConst(c []float64) (error) {
	out, err := vipsgenBandjoinConst(r.image, c)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Bandmean vips_bandmean band-wise average
func (r *Image) Bandmean() (error) {
	out, err := vipsgenBandmean(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// BandunfoldOptions optional arguments for vips_bandunfold
type BandunfoldOptions struct {
	// Factor Unfold by this factor
	Factor int
}

// DefaultBandunfoldOptions creates default value for vips_bandunfold optional arguments
func DefaultBandunfoldOptions() *BandunfoldOptions {
	return &BandunfoldOptions{
	}
}

// Bandunfold vips_bandunfold unfold image bands into x axis
func (r *Image) Bandunfold(options *BandunfoldOptions) (error) {
	if options != nil {
		out, err := vipsgenBandunfoldWithOptions(r.image, options.Factor)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenBandunfold(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Boolean vips_boolean boolean operation on two images
//
// The right specifies right-hand image argument.
// The boolean specifies boolean to perform.
func (r *Image) Boolean(right *Image, boolean OperationBoolean) (error) {
	out, err := vipsgenBoolean(r.image, right.image, boolean)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// BooleanConst vips_boolean_const boolean operations against a constant
//
// The boolean specifies boolean to perform.
// The c specifies array of constants.
func (r *Image) BooleanConst(boolean OperationBoolean, c []float64) (error) {
	out, err := vipsgenBooleanConst(r.image, boolean, c)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Buildlut vips_buildlut build a look-up table
func (r *Image) Buildlut() (error) {
	out, err := vipsgenBuildlut(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Byteswap vips_byteswap byteswap an image
func (r *Image) Byteswap() (error) {
	out, err := vipsgenByteswap(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// CannyOptions optional arguments for vips_canny
type CannyOptions struct {
	// Sigma Sigma of Gaussian
	Sigma float64
	// Precision Convolve with this precision
	Precision Precision
}

// DefaultCannyOptions creates default value for vips_canny optional arguments
func DefaultCannyOptions() *CannyOptions {
	return &CannyOptions{
		Sigma: 1.4,
		Precision: Precision(1),
	}
}

// Canny vips_canny Canny edge detector
func (r *Image) Canny(options *CannyOptions) (error) {
	if options != nil {
		out, err := vipsgenCannyWithOptions(r.image, options.Sigma, options.Precision)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenCanny(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Case vips_case use pixel values to pick cases from an array of images
//
// The cases specifies array of case images.
func (r *Image) Case(cases []*Image) (error) {
	out, err := vipsgenCase(r.image, convertImagesToVipsImages(cases))
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// CastOptions optional arguments for vips_cast
type CastOptions struct {
	// Shift Shift integer values up and down
	Shift bool
}

// DefaultCastOptions creates default value for vips_cast optional arguments
func DefaultCastOptions() *CastOptions {
	return &CastOptions{
	}
}

// Cast vips_cast cast an image
//
// The format specifies format to cast to.
func (r *Image) Cast(format BandFormat, options *CastOptions) (error) {
	if options != nil {
		out, err := vipsgenCastWithOptions(r.image, format, options.Shift)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenCast(r.image, format)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// ClampOptions optional arguments for vips_clamp
type ClampOptions struct {
	// Min Minimum value
	Min float64
	// Max Maximum value
	Max float64
}

// DefaultClampOptions creates default value for vips_clamp optional arguments
func DefaultClampOptions() *ClampOptions {
	return &ClampOptions{
	}
}

// Clamp vips_clamp clamp values of an image
func (r *Image) Clamp(options *ClampOptions) (error) {
	if options != nil {
		out, err := vipsgenClampWithOptions(r.image, options.Min, options.Max)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenClamp(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// ColourspaceOptions optional arguments for vips_colourspace
type ColourspaceOptions struct {
	// SourceSpace Source color space
	SourceSpace Interpretation
}

// DefaultColourspaceOptions creates default value for vips_colourspace optional arguments
func DefaultColourspaceOptions() *ColourspaceOptions {
	return &ColourspaceOptions{
		SourceSpace: Interpretation(22),
	}
}

// Colourspace vips_colourspace convert to a new colorspace
//
// The space specifies destination color space.
func (r *Image) Colourspace(space Interpretation, options *ColourspaceOptions) (error) {
	if options != nil {
		out, err := vipsgenColourspaceWithOptions(r.image, space, options.SourceSpace)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenColourspace(r.image, space)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// CompassOptions optional arguments for vips_compass
type CompassOptions struct {
	// Times Rotate and convolve this many times
	Times int
	// Angle Rotate mask by this much between convolutions
	Angle Angle45
	// Combine Combine convolution results like this
	Combine Combine
	// Precision Convolve with this precision
	Precision Precision
	// Layers Use this many layers in approximation
	Layers int
	// Cluster Cluster lines closer than this in approximation
	Cluster int
}

// DefaultCompassOptions creates default value for vips_compass optional arguments
func DefaultCompassOptions() *CompassOptions {
	return &CompassOptions{
		Times: 2,
		Angle: Angle45(2),
		Precision: Precision(1),
		Layers: 5,
		Cluster: 1,
	}
}

// Compass vips_compass convolve with rotating mask
//
// The mask specifies input matrix image.
func (r *Image) Compass(mask *Image, options *CompassOptions) (error) {
	if options != nil {
		out, err := vipsgenCompassWithOptions(r.image, mask.image, options.Times, options.Angle, options.Combine, options.Precision, options.Layers, options.Cluster)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenCompass(r.image, mask.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Complex vips_complex perform a complex operation on an image
//
// The cmplx specifies complex to perform.
func (r *Image) Complex(cmplx OperationComplex) (error) {
	out, err := vipsgenComplex(r.image, cmplx)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Complex2 vips_complex2 complex binary operations on two images
//
// The right specifies right-hand image argument.
// The cmplx specifies binary complex operation to perform.
func (r *Image) Complex2(right *Image, cmplx OperationComplex2) (error) {
	out, err := vipsgenComplex2(r.image, right.image, cmplx)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Complexform vips_complexform form a complex image from two real images
//
// The right specifies right-hand image argument.
func (r *Image) Complexform(right *Image) (error) {
	out, err := vipsgenComplexform(r.image, right.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Complexget vips_complexget get a component from a complex image
//
// The get specifies complex to perform.
func (r *Image) Complexget(get OperationComplexget) (error) {
	out, err := vipsgenComplexget(r.image, get)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// Composite2Options optional arguments for vips_composite2
type Composite2Options struct {
	// X x position of overlay
	X int
	// Y y position of overlay
	Y int
	// CompositingSpace Composite images in this colour space
	CompositingSpace Interpretation
	// Premultiplied Images have premultiplied alpha
	Premultiplied bool
}

// DefaultComposite2Options creates default value for vips_composite2 optional arguments
func DefaultComposite2Options() *Composite2Options {
	return &Composite2Options{
		CompositingSpace: Interpretation(22),
	}
}

// Composite2 vips_composite2 blend a pair of images with a blend mode
//
// The overlay specifies overlay image.
// The mode specifies vipsBlendMode to join with.
func (r *Image) Composite2(overlay *Image, mode BlendMode, options *Composite2Options) (error) {
	if options != nil {
		out, err := vipsgenComposite2WithOptions(r.image, overlay.image, mode, options.X, options.Y, options.CompositingSpace, options.Premultiplied)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenComposite2(r.image, overlay.image, mode)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// ConvOptions optional arguments for vips_conv
type ConvOptions struct {
	// Precision Convolve with this precision
	Precision Precision
	// Layers Use this many layers in approximation
	Layers int
	// Cluster Cluster lines closer than this in approximation
	Cluster int
}

// DefaultConvOptions creates default value for vips_conv optional arguments
func DefaultConvOptions() *ConvOptions {
	return &ConvOptions{
		Precision: Precision(1),
		Layers: 5,
		Cluster: 1,
	}
}

// Conv vips_conv convolution operation
//
// The mask specifies input matrix image.
func (r *Image) Conv(mask *Image, options *ConvOptions) (error) {
	if options != nil {
		out, err := vipsgenConvWithOptions(r.image, mask.image, options.Precision, options.Layers, options.Cluster)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenConv(r.image, mask.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// ConvaOptions optional arguments for vips_conva
type ConvaOptions struct {
	// Layers Use this many layers in approximation
	Layers int
	// Cluster Cluster lines closer than this in approximation
	Cluster int
}

// DefaultConvaOptions creates default value for vips_conva optional arguments
func DefaultConvaOptions() *ConvaOptions {
	return &ConvaOptions{
		Layers: 5,
		Cluster: 1,
	}
}

// Conva vips_conva approximate integer convolution
//
// The mask specifies input matrix image.
func (r *Image) Conva(mask *Image, options *ConvaOptions) (error) {
	if options != nil {
		out, err := vipsgenConvaWithOptions(r.image, mask.image, options.Layers, options.Cluster)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenConva(r.image, mask.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// ConvasepOptions optional arguments for vips_convasep
type ConvasepOptions struct {
	// Layers Use this many layers in approximation
	Layers int
}

// DefaultConvasepOptions creates default value for vips_convasep optional arguments
func DefaultConvasepOptions() *ConvasepOptions {
	return &ConvasepOptions{
		Layers: 5,
	}
}

// Convasep vips_convasep approximate separable integer convolution
//
// The mask specifies input matrix image.
func (r *Image) Convasep(mask *Image, options *ConvasepOptions) (error) {
	if options != nil {
		out, err := vipsgenConvasepWithOptions(r.image, mask.image, options.Layers)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenConvasep(r.image, mask.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Convf vips_convf float convolution operation
//
// The mask specifies input matrix image.
func (r *Image) Convf(mask *Image) (error) {
	out, err := vipsgenConvf(r.image, mask.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Convi vips_convi int convolution operation
//
// The mask specifies input matrix image.
func (r *Image) Convi(mask *Image) (error) {
	out, err := vipsgenConvi(r.image, mask.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// ConvsepOptions optional arguments for vips_convsep
type ConvsepOptions struct {
	// Precision Convolve with this precision
	Precision Precision
	// Layers Use this many layers in approximation
	Layers int
	// Cluster Cluster lines closer than this in approximation
	Cluster int
}

// DefaultConvsepOptions creates default value for vips_convsep optional arguments
func DefaultConvsepOptions() *ConvsepOptions {
	return &ConvsepOptions{
		Precision: Precision(1),
		Layers: 5,
		Cluster: 1,
	}
}

// Convsep vips_convsep separable convolution operation
//
// The mask specifies input matrix image.
func (r *Image) Convsep(mask *Image, options *ConvsepOptions) (error) {
	if options != nil {
		out, err := vipsgenConvsepWithOptions(r.image, mask.image, options.Precision, options.Layers, options.Cluster)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenConvsep(r.image, mask.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// CopyOptions optional arguments for vips_copy
type CopyOptions struct {
	// Width Image width in pixels
	Width int
	// Height Image height in pixels
	Height int
	// Bands Number of bands in image
	Bands int
	// Format Pixel format in image
	Format BandFormat
	// Coding Pixel coding
	Coding Coding
	// Interpretation Pixel interpretation
	Interpretation Interpretation
	// Xres Horizontal resolution in pixels/mm
	Xres float64
	// Yres Vertical resolution in pixels/mm
	Yres float64
	// Xoffset Horizontal offset of origin
	Xoffset int
	// Yoffset Vertical offset of origin
	Yoffset int
}

// DefaultCopyOptions creates default value for vips_copy optional arguments
func DefaultCopyOptions() *CopyOptions {
	return &CopyOptions{
	}
}

// Copy vips_copy copy an image
func (r *Image) Copy(options *CopyOptions) (*Image, error) {
	if options != nil {
		out, err := vipsgenCopyWithOptions(r.image, options.Width, options.Height, options.Bands, options.Format, options.Coding, options.Interpretation, options.Xres, options.Yres, options.Xoffset, options.Yoffset)
		if err != nil {
			return nil, err
		}
		outImage := newImageRef(out, r.format, nil)
		return outImage, nil
	}
	out, err := vipsgenCopy(r.image)
	if err != nil {
		return nil, err
	}
	outImage := newImageRef(out, r.format, nil)
	return outImage, nil
}


// Countlines vips_countlines count lines in an image
//
// The direction specifies countlines left-right or up-down.
func (r *Image) Countlines(direction Direction) (float64, error) {
	out, err := vipsgenCountlines(r.image, direction)
	if err != nil {
		return 0, err
	}
	return out, nil
}

// CsvsaveOptions optional arguments for vips_csvsave
type CsvsaveOptions struct {
	// Separator Separator characters
	Separator string
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultCsvsaveOptions creates default value for vips_csvsave optional arguments
func DefaultCsvsaveOptions() *CsvsaveOptions {
	return &CsvsaveOptions{
		Separator: "\t",
	}
}

// Csvsave vips_csvsave save image to csv
//
// The filename specifies filename to save to.
func (r *Image) Csvsave(filename string, options *CsvsaveOptions) (error) {
	if options != nil {
		err := vipsgenCsvsaveWithOptions(r.image, filename, options.Separator, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenCsvsave(r.image, filename)
	if err != nil {
		return err
	}
	return nil
}

// CsvsaveTargetOptions optional arguments for vips_csvsave_target
type CsvsaveTargetOptions struct {
	// Separator Separator characters
	Separator string
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultCsvsaveTargetOptions creates default value for vips_csvsave_target optional arguments
func DefaultCsvsaveTargetOptions() *CsvsaveTargetOptions {
	return &CsvsaveTargetOptions{
		Separator: "\t",
	}
}

// CsvsaveTarget vips_csvsave_target save image to csv
//
// The target specifies target to save to.
func (r *Image) CsvsaveTarget(target *Target, options *CsvsaveTargetOptions) (error) {
	if options != nil {
		err := vipsgenCsvsaveTargetWithOptions(r.image, target.target, options.Separator, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenCsvsaveTarget(r.image, target.target)
	if err != nil {
		return err
	}
	return nil
}


// DE00 vips_dE00 calculate dE00
//
// The right specifies right-hand input image.
func (r *Image) DE00(right *Image) (error) {
	out, err := vipsgenDE00(r.image, right.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// DE76 vips_dE76 calculate dE76
//
// The right specifies right-hand input image.
func (r *Image) DE76(right *Image) (error) {
	out, err := vipsgenDE76(r.image, right.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// DECMC vips_dECMC calculate dECMC
//
// The right specifies right-hand input image.
func (r *Image) DECMC(right *Image) (error) {
	out, err := vipsgenDECMC(r.image, right.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Deviate vips_deviate find image standard deviation
func (r *Image) Deviate() (float64, error) {
	out, err := vipsgenDeviate(r.image)
	if err != nil {
		return 0, err
	}
	return out, nil
}


// Divide vips_divide divide two images
//
// The right specifies right-hand image argument.
func (r *Image) Divide(right *Image) (error) {
	out, err := vipsgenDivide(r.image, right.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// DrawCircleOptions optional arguments for vips_draw_circle
type DrawCircleOptions struct {
	// Fill Draw a solid object
	Fill bool
}

// DefaultDrawCircleOptions creates default value for vips_draw_circle optional arguments
func DefaultDrawCircleOptions() *DrawCircleOptions {
	return &DrawCircleOptions{
	}
}

// DrawCircle vips_draw_circle draw a circle on an image
//
// The ink specifies color for pixels.
// The cx specifies centre of draw_circle.
// The cy specifies centre of draw_circle.
// The radius specifies radius in pixels.
func (r *Image) DrawCircle(ink []float64, cx int, cy int, radius int, options *DrawCircleOptions) (error) {
	if options != nil {
		err := vipsgenDrawCircleWithOptions(r.image, ink, cx, cy, radius, options.Fill)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenDrawCircle(r.image, ink, cx, cy, radius)
	if err != nil {
		return err
	}
	return nil
}

// DrawFloodOptions optional arguments for vips_draw_flood
type DrawFloodOptions struct {
	// Test Test pixels in this image
	Test *Image
	// Equal DrawFlood while equal to edge
	Equal bool
}

// DefaultDrawFloodOptions creates default value for vips_draw_flood optional arguments
func DefaultDrawFloodOptions() *DrawFloodOptions {
	return &DrawFloodOptions{
	}
}

// DrawFlood vips_draw_flood flood-fill an area
//
// The ink specifies color for pixels.
// The x specifies drawFlood start point.
// The y specifies drawFlood start point.
func (r *Image) DrawFlood(ink []float64, x int, y int, options *DrawFloodOptions) (error) {
	if options != nil {
		err := vipsgenDrawFloodWithOptions(r.image, ink, x, y, options.Test.image, options.Equal)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenDrawFlood(r.image, ink, x, y)
	if err != nil {
		return err
	}
	return nil
}

// DrawImageOptions optional arguments for vips_draw_image
type DrawImageOptions struct {
	// Mode Combining mode
	Mode CombineMode
}

// DefaultDrawImageOptions creates default value for vips_draw_image optional arguments
func DefaultDrawImageOptions() *DrawImageOptions {
	return &DrawImageOptions{
	}
}

// DrawImage vips_draw_image paint an image into another image
//
// The sub specifies sub-image to insert into main image.
// The x specifies draw image here.
// The y specifies draw image here.
func (r *Image) DrawImage(sub *Image, x int, y int, options *DrawImageOptions) (error) {
	if options != nil {
		err := vipsgenDrawImageWithOptions(r.image, sub.image, x, y, options.Mode)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenDrawImage(r.image, sub.image, x, y)
	if err != nil {
		return err
	}
	return nil
}


// DrawLine vips_draw_line draw a line on an image
//
// The ink specifies color for pixels.
// The x1 specifies start of draw_line.
// The y1 specifies start of draw_line.
// The x2 specifies end of draw_line.
// The y2 specifies end of draw_line.
func (r *Image) DrawLine(ink []float64, x1 int, y1 int, x2 int, y2 int) (error) {
	err := vipsgenDrawLine(r.image, ink, x1, y1, x2, y2)
	if err != nil {
		return err
	}
	return nil
}


// DrawMask vips_draw_mask draw a mask on an image
//
// The ink specifies color for pixels.
// The mask specifies mask of pixels to draw.
// The x specifies draw mask here.
// The y specifies draw mask here.
func (r *Image) DrawMask(ink []float64, mask *Image, x int, y int) (error) {
	err := vipsgenDrawMask(r.image, ink, mask.image, x, y)
	if err != nil {
		return err
	}
	return nil
}

// DrawRectOptions optional arguments for vips_draw_rect
type DrawRectOptions struct {
	// Fill Draw a solid object
	Fill bool
}

// DefaultDrawRectOptions creates default value for vips_draw_rect optional arguments
func DefaultDrawRectOptions() *DrawRectOptions {
	return &DrawRectOptions{
	}
}

// DrawRect vips_draw_rect paint a rectangle on an image
//
// The ink specifies color for pixels.
// The left specifies rect to fill.
// The top specifies rect to fill.
// The width specifies rect to fill.
// The height specifies rect to fill.
func (r *Image) DrawRect(ink []float64, left int, top int, width int, height int, options *DrawRectOptions) (error) {
	if options != nil {
		err := vipsgenDrawRectWithOptions(r.image, ink, left, top, width, height, options.Fill)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenDrawRect(r.image, ink, left, top, width, height)
	if err != nil {
		return err
	}
	return nil
}


// DrawSmudge vips_draw_smudge blur a rectangle on an image
//
// The left specifies rect to fill.
// The top specifies rect to fill.
// The width specifies rect to fill.
// The height specifies rect to fill.
func (r *Image) DrawSmudge(left int, top int, width int, height int) (error) {
	err := vipsgenDrawSmudge(r.image, left, top, width, height)
	if err != nil {
		return err
	}
	return nil
}

// EmbedOptions optional arguments for vips_embed
type EmbedOptions struct {
	// Extend How to generate the extra pixels
	Extend Extend
	// Background Color for background pixels
	Background []float64
}

// DefaultEmbedOptions creates default value for vips_embed optional arguments
func DefaultEmbedOptions() *EmbedOptions {
	return &EmbedOptions{
	}
}

// Embed vips_embed embed an image in a larger image
//
// The x specifies left edge of input in output.
// The y specifies top edge of input in output.
// The width specifies image width in pixels.
// The height specifies image height in pixels.
func (r *Image) Embed(x int, y int, width int, height int, options *EmbedOptions) (error) {
	if options != nil {
		out, err := vipsgenEmbedWithOptions(r.image, x, y, width, height, options.Extend, options.Background)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenEmbed(r.image, x, y, width, height)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// ExtractArea vips_extract_area extract an area from an image
//
// The left specifies left edge of extract area.
// The top specifies top edge of extract area.
// The width specifies width of extract area.
// The height specifies height of extract area.
func (r *Image) ExtractArea(left int, top int, width int, height int) (error) {
	out, err := vipsgenExtractArea(r.image, left, top, width, height)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// ExtractBandOptions optional arguments for vips_extract_band
type ExtractBandOptions struct {
	// N Number of bands to extract
	N int
}

// DefaultExtractBandOptions creates default value for vips_extract_band optional arguments
func DefaultExtractBandOptions() *ExtractBandOptions {
	return &ExtractBandOptions{
		N: 1,
	}
}

// ExtractBand vips_extract_band extract band from an image
//
// The band specifies band to extract.
func (r *Image) ExtractBand(band int, options *ExtractBandOptions) (error) {
	if options != nil {
		out, err := vipsgenExtractBandWithOptions(r.image, band, options.N)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenExtractBand(r.image, band)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Falsecolour vips_falsecolour false-color an image
func (r *Image) Falsecolour() (error) {
	out, err := vipsgenFalsecolour(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Fastcor vips_fastcor fast correlation
//
// The ref specifies input reference image.
func (r *Image) Fastcor(ref *Image) (error) {
	out, err := vipsgenFastcor(r.image, ref.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// FillNearest vips_fill_nearest fill image zeros with nearest non-zero pixel
func (r *Image) FillNearest() (*Image, error) {
	out, err := vipsgenFillNearest(r.image)
	if err != nil {
		return nil, err
	}
	outImage := newImageRef(out, r.format, nil)
	return outImage, nil
}

// FindTrimOptions optional arguments for vips_find_trim
type FindTrimOptions struct {
	// Threshold Object threshold
	Threshold float64
	// Background Color for background pixels
	Background []float64
	// LineArt Enable line art mode
	LineArt bool
}

// DefaultFindTrimOptions creates default value for vips_find_trim optional arguments
func DefaultFindTrimOptions() *FindTrimOptions {
	return &FindTrimOptions{
		Threshold: 10,
	}
}

// FindTrim vips_find_trim search an image for non-edge areas
func (r *Image) FindTrim(options *FindTrimOptions) (int, int, int, int, error) {
	if options != nil {
		left, top, width, height, err := vipsgenFindTrimWithOptions(r.image, options.Threshold, options.Background, options.LineArt)
		if err != nil {
			return 0, 0, 0, 0, err
		}
		return left, top, width, height, nil
	}
	left, top, width, height, err := vipsgenFindTrim(r.image)
	if err != nil {
		return 0, 0, 0, 0, err
	}
	return left, top, width, height, nil
}

// FlattenOptions optional arguments for vips_flatten
type FlattenOptions struct {
	// Background Background value
	Background []float64
	// MaxAlpha Maximum value of alpha channel
	MaxAlpha float64
}

// DefaultFlattenOptions creates default value for vips_flatten optional arguments
func DefaultFlattenOptions() *FlattenOptions {
	return &FlattenOptions{
		MaxAlpha: 255,
	}
}

// Flatten vips_flatten flatten alpha out of an image
func (r *Image) Flatten(options *FlattenOptions) (error) {
	if options != nil {
		out, err := vipsgenFlattenWithOptions(r.image, options.Background, options.MaxAlpha)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenFlatten(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Flip vips_flip flip an image
//
// The direction specifies direction to flip image.
func (r *Image) Flip(direction Direction) (error) {
	out, err := vipsgenFlip(r.image, direction)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Float2rad vips_float2rad transform float RGB to Radiance coding
func (r *Image) Float2rad() (error) {
	out, err := vipsgenFloat2rad(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Freqmult vips_freqmult frequency-domain filtering
//
// The mask specifies input mask image.
func (r *Image) Freqmult(mask *Image) (error) {
	out, err := vipsgenFreqmult(r.image, mask.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// GammaOptions optional arguments for vips_gamma
type GammaOptions struct {
	// Exponent Gamma factor
	Exponent float64
}

// DefaultGammaOptions creates default value for vips_gamma optional arguments
func DefaultGammaOptions() *GammaOptions {
	return &GammaOptions{
		Exponent: 2.4,
	}
}

// Gamma vips_gamma gamma an image
func (r *Image) Gamma(options *GammaOptions) (error) {
	if options != nil {
		out, err := vipsgenGammaWithOptions(r.image, options.Exponent)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenGamma(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// GaussblurOptions optional arguments for vips_gaussblur
type GaussblurOptions struct {
	// MinAmpl Minimum amplitude of Gaussian
	MinAmpl float64
	// Precision Convolve with this precision
	Precision Precision
}

// DefaultGaussblurOptions creates default value for vips_gaussblur optional arguments
func DefaultGaussblurOptions() *GaussblurOptions {
	return &GaussblurOptions{
		MinAmpl: 0.2,
	}
}

// Gaussblur vips_gaussblur gaussian blur
//
// The sigma specifies sigma of Gaussian.
func (r *Image) Gaussblur(sigma float64, options *GaussblurOptions) (error) {
	if options != nil {
		out, err := vipsgenGaussblurWithOptions(r.image, sigma, options.MinAmpl, options.Precision)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenGaussblur(r.image, sigma)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// GetpointOptions optional arguments for vips_getpoint
type GetpointOptions struct {
	// UnpackComplex Complex pixels should be unpacked
	UnpackComplex bool
}

// DefaultGetpointOptions creates default value for vips_getpoint optional arguments
func DefaultGetpointOptions() *GetpointOptions {
	return &GetpointOptions{
	}
}

// Getpoint vips_getpoint read a point from an image
//
// The x specifies point to read.
// The y specifies point to read.
func (r *Image) Getpoint(x int, y int, options *GetpointOptions) ([]float64, error) {
	if options != nil {
		outArray, err := vipsgenGetpointWithOptions(r.image, x, y, options.UnpackComplex)
		if err != nil {
			return nil, err
		}
		return outArray, nil
	}
	outArray, err := vipsgenGetpoint(r.image, x, y)
	if err != nil {
		return nil, err
	}
	return outArray, nil
}

// GlobalbalanceOptions optional arguments for vips_globalbalance
type GlobalbalanceOptions struct {
	// Gamma Image gamma
	Gamma float64
	// IntOutput Integer output
	IntOutput bool
}

// DefaultGlobalbalanceOptions creates default value for vips_globalbalance optional arguments
func DefaultGlobalbalanceOptions() *GlobalbalanceOptions {
	return &GlobalbalanceOptions{
		Gamma: 1.6,
	}
}

// Globalbalance vips_globalbalance global balance an image mosaic
func (r *Image) Globalbalance(options *GlobalbalanceOptions) (error) {
	if options != nil {
		out, err := vipsgenGlobalbalanceWithOptions(r.image, options.Gamma, options.IntOutput)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenGlobalbalance(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// GravityOptions optional arguments for vips_gravity
type GravityOptions struct {
	// Extend How to generate the extra pixels
	Extend Extend
	// Background Color for background pixels
	Background []float64
}

// DefaultGravityOptions creates default value for vips_gravity optional arguments
func DefaultGravityOptions() *GravityOptions {
	return &GravityOptions{
	}
}

// Gravity vips_gravity place an image within a larger image with a certain gravity
//
// The direction specifies direction to place image within width/height.
// The width specifies image width in pixels.
// The height specifies image height in pixels.
func (r *Image) Gravity(direction CompassDirection, width int, height int, options *GravityOptions) (error) {
	if options != nil {
		out, err := vipsgenGravityWithOptions(r.image, direction, width, height, options.Extend, options.Background)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenGravity(r.image, direction, width, height)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Grid vips_grid grid an image
//
// The tileHeight specifies chop into tiles this high.
// The across specifies number of tiles across.
// The down specifies number of tiles down.
func (r *Image) Grid(tileHeight int, across int, down int) (error) {
	out, err := vipsgenGrid(r.image, tileHeight, across, down)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// HeifsaveOptions optional arguments for vips_heifsave
type HeifsaveOptions struct {
	// Q Q factor
	Q int
	// Bitdepth Number of bits per pixel
	Bitdepth int
	// Lossless Enable lossless compression
	Lossless bool
	// Compression Compression format
	Compression HeifCompression
	// Effort CPU effort
	Effort int
	// SubsampleMode Select chroma subsample operation mode
	SubsampleMode Subsample
	// Encoder Select encoder to use
	Encoder HeifEncoder
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultHeifsaveOptions creates default value for vips_heifsave optional arguments
func DefaultHeifsaveOptions() *HeifsaveOptions {
	return &HeifsaveOptions{
		Q: 50,
		Bitdepth: 12,
		Compression: HeifCompression(1),
		Effort: 4,
	}
}

// Heifsave vips_heifsave save image in HEIF format
//
// The filename specifies filename to save to.
func (r *Image) Heifsave(filename string, options *HeifsaveOptions) (error) {
	if options != nil {
		err := vipsgenHeifsaveWithOptions(r.image, filename, options.Q, options.Bitdepth, options.Lossless, options.Compression, options.Effort, options.SubsampleMode, options.Encoder, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenHeifsave(r.image, filename)
	if err != nil {
		return err
	}
	return nil
}

// HeifsaveBufferOptions optional arguments for vips_heifsave_buffer
type HeifsaveBufferOptions struct {
	// Q Q factor
	Q int
	// Bitdepth Number of bits per pixel
	Bitdepth int
	// Lossless Enable lossless compression
	Lossless bool
	// Compression Compression format
	Compression HeifCompression
	// Effort CPU effort
	Effort int
	// SubsampleMode Select chroma subsample operation mode
	SubsampleMode Subsample
	// Encoder Select encoder to use
	Encoder HeifEncoder
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultHeifsaveBufferOptions creates default value for vips_heifsave_buffer optional arguments
func DefaultHeifsaveBufferOptions() *HeifsaveBufferOptions {
	return &HeifsaveBufferOptions{
		Q: 50,
		Bitdepth: 12,
		Compression: HeifCompression(1),
		Effort: 4,
	}
}

// HeifsaveBuffer vips_heifsave_buffer save image in HEIF format
func (r *Image) HeifsaveBuffer(options *HeifsaveBufferOptions) ([]byte, error) {
	if options != nil {
		buf, err := vipsgenHeifsaveBufferWithOptions(r.image, options.Q, options.Bitdepth, options.Lossless, options.Compression, options.Effort, options.SubsampleMode, options.Encoder, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return nil, err
		}
		return buf, nil
	}
	buf, err := vipsgenHeifsaveBuffer(r.image)
	if err != nil {
		return nil, err
	}
	return buf, nil
}

// HeifsaveTargetOptions optional arguments for vips_heifsave_target
type HeifsaveTargetOptions struct {
	// Q Q factor
	Q int
	// Bitdepth Number of bits per pixel
	Bitdepth int
	// Lossless Enable lossless compression
	Lossless bool
	// Compression Compression format
	Compression HeifCompression
	// Effort CPU effort
	Effort int
	// SubsampleMode Select chroma subsample operation mode
	SubsampleMode Subsample
	// Encoder Select encoder to use
	Encoder HeifEncoder
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultHeifsaveTargetOptions creates default value for vips_heifsave_target optional arguments
func DefaultHeifsaveTargetOptions() *HeifsaveTargetOptions {
	return &HeifsaveTargetOptions{
		Q: 50,
		Bitdepth: 12,
		Compression: HeifCompression(1),
		Effort: 4,
	}
}

// HeifsaveTarget vips_heifsave_target save image in HEIF format
//
// The target specifies target to save to.
func (r *Image) HeifsaveTarget(target *Target, options *HeifsaveTargetOptions) (error) {
	if options != nil {
		err := vipsgenHeifsaveTargetWithOptions(r.image, target.target, options.Q, options.Bitdepth, options.Lossless, options.Compression, options.Effort, options.SubsampleMode, options.Encoder, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenHeifsaveTarget(r.image, target.target)
	if err != nil {
		return err
	}
	return nil
}


// HistCum vips_hist_cum form cumulative histogram
func (r *Image) HistCum() (error) {
	out, err := vipsgenHistCum(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// HistEntropy vips_hist_entropy estimate image entropy
func (r *Image) HistEntropy() (float64, error) {
	out, err := vipsgenHistEntropy(r.image)
	if err != nil {
		return 0, err
	}
	return out, nil
}

// HistEqualOptions optional arguments for vips_hist_equal
type HistEqualOptions struct {
	// Band Equalise with this band
	Band int
}

// DefaultHistEqualOptions creates default value for vips_hist_equal optional arguments
func DefaultHistEqualOptions() *HistEqualOptions {
	return &HistEqualOptions{
		Band: -1,
	}
}

// HistEqual vips_hist_equal histogram equalisation
func (r *Image) HistEqual(options *HistEqualOptions) (error) {
	if options != nil {
		out, err := vipsgenHistEqualWithOptions(r.image, options.Band)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenHistEqual(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// HistFindOptions optional arguments for vips_hist_find
type HistFindOptions struct {
	// Band Find histogram of band
	Band int
}

// DefaultHistFindOptions creates default value for vips_hist_find optional arguments
func DefaultHistFindOptions() *HistFindOptions {
	return &HistFindOptions{
		Band: -1,
	}
}

// HistFind vips_hist_find find image histogram
func (r *Image) HistFind(options *HistFindOptions) (error) {
	if options != nil {
		out, err := vipsgenHistFindWithOptions(r.image, options.Band)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenHistFind(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// HistFindIndexedOptions optional arguments for vips_hist_find_indexed
type HistFindIndexedOptions struct {
	// Combine Combine bins like this
	Combine Combine
}

// DefaultHistFindIndexedOptions creates default value for vips_hist_find_indexed optional arguments
func DefaultHistFindIndexedOptions() *HistFindIndexedOptions {
	return &HistFindIndexedOptions{
		Combine: Combine(1),
	}
}

// HistFindIndexed vips_hist_find_indexed find indexed image histogram
//
// The index specifies index image.
func (r *Image) HistFindIndexed(index *Image, options *HistFindIndexedOptions) (error) {
	if options != nil {
		out, err := vipsgenHistFindIndexedWithOptions(r.image, index.image, options.Combine)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenHistFindIndexed(r.image, index.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// HistFindNdimOptions optional arguments for vips_hist_find_ndim
type HistFindNdimOptions struct {
	// Bins Number of bins in each dimension
	Bins int
}

// DefaultHistFindNdimOptions creates default value for vips_hist_find_ndim optional arguments
func DefaultHistFindNdimOptions() *HistFindNdimOptions {
	return &HistFindNdimOptions{
		Bins: 10,
	}
}

// HistFindNdim vips_hist_find_ndim find n-dimensional image histogram
func (r *Image) HistFindNdim(options *HistFindNdimOptions) (error) {
	if options != nil {
		out, err := vipsgenHistFindNdimWithOptions(r.image, options.Bins)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenHistFindNdim(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// HistIsmonotonic vips_hist_ismonotonic test for monotonicity
func (r *Image) HistIsmonotonic() (bool, error) {
	monotonic, err := vipsgenHistIsmonotonic(r.image)
	if err != nil {
		return false, err
	}
	return monotonic, nil
}

// HistLocalOptions optional arguments for vips_hist_local
type HistLocalOptions struct {
	// MaxSlope Maximum slope (CLAHE)
	MaxSlope int
}

// DefaultHistLocalOptions creates default value for vips_hist_local optional arguments
func DefaultHistLocalOptions() *HistLocalOptions {
	return &HistLocalOptions{
	}
}

// HistLocal vips_hist_local local histogram equalisation
//
// The width specifies window width in pixels.
// The height specifies window height in pixels.
func (r *Image) HistLocal(width int, height int, options *HistLocalOptions) (error) {
	if options != nil {
		out, err := vipsgenHistLocalWithOptions(r.image, width, height, options.MaxSlope)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenHistLocal(r.image, width, height)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// HistMatch vips_hist_match match two histograms
//
// The ref specifies reference histogram.
func (r *Image) HistMatch(ref *Image) (error) {
	out, err := vipsgenHistMatch(r.image, ref.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// HistNorm vips_hist_norm normalise histogram
func (r *Image) HistNorm() (error) {
	out, err := vipsgenHistNorm(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// HistPlot vips_hist_plot plot histogram
func (r *Image) HistPlot() (error) {
	out, err := vipsgenHistPlot(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// HoughCircleOptions optional arguments for vips_hough_circle
type HoughCircleOptions struct {
	// Scale Scale down dimensions by this factor
	Scale int
	// MinRadius Smallest radius to search for
	MinRadius int
	// MaxRadius Largest radius to search for
	MaxRadius int
}

// DefaultHoughCircleOptions creates default value for vips_hough_circle optional arguments
func DefaultHoughCircleOptions() *HoughCircleOptions {
	return &HoughCircleOptions{
		Scale: 3,
		MinRadius: 10,
		MaxRadius: 20,
	}
}

// HoughCircle vips_hough_circle find hough circle transform
func (r *Image) HoughCircle(options *HoughCircleOptions) (error) {
	if options != nil {
		out, err := vipsgenHoughCircleWithOptions(r.image, options.Scale, options.MinRadius, options.MaxRadius)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenHoughCircle(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// HoughLineOptions optional arguments for vips_hough_line
type HoughLineOptions struct {
	// Width Horizontal size of parameter space
	Width int
	// Height Vertical size of parameter space
	Height int
}

// DefaultHoughLineOptions creates default value for vips_hough_line optional arguments
func DefaultHoughLineOptions() *HoughLineOptions {
	return &HoughLineOptions{
		Width: 256,
		Height: 256,
	}
}

// HoughLine vips_hough_line find hough line transform
func (r *Image) HoughLine(options *HoughLineOptions) (error) {
	if options != nil {
		out, err := vipsgenHoughLineWithOptions(r.image, options.Width, options.Height)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenHoughLine(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// IfthenelseOptions optional arguments for vips_ifthenelse
type IfthenelseOptions struct {
	// Blend Blend smoothly between then and else parts
	Blend bool
}

// DefaultIfthenelseOptions creates default value for vips_ifthenelse optional arguments
func DefaultIfthenelseOptions() *IfthenelseOptions {
	return &IfthenelseOptions{
	}
}

// Ifthenelse vips_ifthenelse ifthenelse an image
//
// The in1 specifies source for TRUE pixels.
// The in2 specifies source for FALSE pixels.
func (r *Image) Ifthenelse(in1 *Image, in2 *Image, options *IfthenelseOptions) (error) {
	if options != nil {
		out, err := vipsgenIfthenelseWithOptions(r.image, in1.image, in2.image, options.Blend)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenIfthenelse(r.image, in1.image, in2.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// InsertOptions optional arguments for vips_insert
type InsertOptions struct {
	// Expand Expand output to hold all of both inputs
	Expand bool
	// Background Color for new pixels
	Background []float64
}

// DefaultInsertOptions creates default value for vips_insert optional arguments
func DefaultInsertOptions() *InsertOptions {
	return &InsertOptions{
	}
}

// Insert vips_insert insert image @sub into @main at @x, @y
//
// The sub specifies sub-image to insert into main image.
// The x specifies left edge of sub in main.
// The y specifies top edge of sub in main.
func (r *Image) Insert(sub *Image, x int, y int, options *InsertOptions) (error) {
	if options != nil {
		out, err := vipsgenInsertWithOptions(r.image, sub.image, x, y, options.Expand, options.Background)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenInsert(r.image, sub.image, x, y)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Invert vips_invert invert an image
func (r *Image) Invert() (error) {
	out, err := vipsgenInvert(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// InvertlutOptions optional arguments for vips_invertlut
type InvertlutOptions struct {
	// Size LUT size to generate
	Size int
}

// DefaultInvertlutOptions creates default value for vips_invertlut optional arguments
func DefaultInvertlutOptions() *InvertlutOptions {
	return &InvertlutOptions{
		Size: 256,
	}
}

// Invertlut vips_invertlut build an inverted look-up table
func (r *Image) Invertlut(options *InvertlutOptions) (error) {
	if options != nil {
		out, err := vipsgenInvertlutWithOptions(r.image, options.Size)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenInvertlut(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// JoinOptions optional arguments for vips_join
type JoinOptions struct {
	// Expand Expand output to hold all of both inputs
	Expand bool
	// Shim Pixels between images
	Shim int
	// Background Colour for new pixels
	Background []float64
	// Align Align on the low, centre or high coordinate edge
	Align Align
}

// DefaultJoinOptions creates default value for vips_join optional arguments
func DefaultJoinOptions() *JoinOptions {
	return &JoinOptions{
	}
}

// Join vips_join join a pair of images
//
// The in2 specifies second input image.
// The direction specifies join left-right or up-down.
func (r *Image) Join(in2 *Image, direction Direction, options *JoinOptions) (error) {
	if options != nil {
		out, err := vipsgenJoinWithOptions(r.image, in2.image, direction, options.Expand, options.Shim, options.Background, options.Align)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenJoin(r.image, in2.image, direction)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// JpegsaveOptions optional arguments for vips_jpegsave
type JpegsaveOptions struct {
	// Q Q factor
	Q int
	// OptimizeCoding Compute optimal Huffman coding tables
	OptimizeCoding bool
	// Interlace Generate an interlaced (progressive) jpeg
	Interlace bool
	// TrellisQuant Apply trellis quantisation to each 8x8 block
	TrellisQuant bool
	// OvershootDeringing Apply overshooting to samples with extreme values
	OvershootDeringing bool
	// OptimizeScans Split spectrum of DCT coefficients into separate scans
	OptimizeScans bool
	// QuantTable Use predefined quantization table with given index
	QuantTable int
	// SubsampleMode Select chroma subsample operation mode
	SubsampleMode Subsample
	// RestartInterval Add restart markers every specified number of mcu
	RestartInterval int
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultJpegsaveOptions creates default value for vips_jpegsave optional arguments
func DefaultJpegsaveOptions() *JpegsaveOptions {
	return &JpegsaveOptions{
		Q: 75,
	}
}

// Jpegsave vips_jpegsave save image to jpeg file
//
// The filename specifies filename to save to.
func (r *Image) Jpegsave(filename string, options *JpegsaveOptions) (error) {
	if options != nil {
		err := vipsgenJpegsaveWithOptions(r.image, filename, options.Q, options.OptimizeCoding, options.Interlace, options.TrellisQuant, options.OvershootDeringing, options.OptimizeScans, options.QuantTable, options.SubsampleMode, options.RestartInterval, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenJpegsave(r.image, filename)
	if err != nil {
		return err
	}
	return nil
}

// JpegsaveBufferOptions optional arguments for vips_jpegsave_buffer
type JpegsaveBufferOptions struct {
	// Q Q factor
	Q int
	// OptimizeCoding Compute optimal Huffman coding tables
	OptimizeCoding bool
	// Interlace Generate an interlaced (progressive) jpeg
	Interlace bool
	// TrellisQuant Apply trellis quantisation to each 8x8 block
	TrellisQuant bool
	// OvershootDeringing Apply overshooting to samples with extreme values
	OvershootDeringing bool
	// OptimizeScans Split spectrum of DCT coefficients into separate scans
	OptimizeScans bool
	// QuantTable Use predefined quantization table with given index
	QuantTable int
	// SubsampleMode Select chroma subsample operation mode
	SubsampleMode Subsample
	// RestartInterval Add restart markers every specified number of mcu
	RestartInterval int
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultJpegsaveBufferOptions creates default value for vips_jpegsave_buffer optional arguments
func DefaultJpegsaveBufferOptions() *JpegsaveBufferOptions {
	return &JpegsaveBufferOptions{
		Q: 75,
	}
}

// JpegsaveBuffer vips_jpegsave_buffer save image to jpeg buffer
func (r *Image) JpegsaveBuffer(options *JpegsaveBufferOptions) ([]byte, error) {
	if options != nil {
		buf, err := vipsgenJpegsaveBufferWithOptions(r.image, options.Q, options.OptimizeCoding, options.Interlace, options.TrellisQuant, options.OvershootDeringing, options.OptimizeScans, options.QuantTable, options.SubsampleMode, options.RestartInterval, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return nil, err
		}
		return buf, nil
	}
	buf, err := vipsgenJpegsaveBuffer(r.image)
	if err != nil {
		return nil, err
	}
	return buf, nil
}

// JpegsaveTargetOptions optional arguments for vips_jpegsave_target
type JpegsaveTargetOptions struct {
	// Q Q factor
	Q int
	// OptimizeCoding Compute optimal Huffman coding tables
	OptimizeCoding bool
	// Interlace Generate an interlaced (progressive) jpeg
	Interlace bool
	// TrellisQuant Apply trellis quantisation to each 8x8 block
	TrellisQuant bool
	// OvershootDeringing Apply overshooting to samples with extreme values
	OvershootDeringing bool
	// OptimizeScans Split spectrum of DCT coefficients into separate scans
	OptimizeScans bool
	// QuantTable Use predefined quantization table with given index
	QuantTable int
	// SubsampleMode Select chroma subsample operation mode
	SubsampleMode Subsample
	// RestartInterval Add restart markers every specified number of mcu
	RestartInterval int
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultJpegsaveTargetOptions creates default value for vips_jpegsave_target optional arguments
func DefaultJpegsaveTargetOptions() *JpegsaveTargetOptions {
	return &JpegsaveTargetOptions{
		Q: 75,
	}
}

// JpegsaveTarget vips_jpegsave_target save image to jpeg target
//
// The target specifies target to save to.
func (r *Image) JpegsaveTarget(target *Target, options *JpegsaveTargetOptions) (error) {
	if options != nil {
		err := vipsgenJpegsaveTargetWithOptions(r.image, target.target, options.Q, options.OptimizeCoding, options.Interlace, options.TrellisQuant, options.OvershootDeringing, options.OptimizeScans, options.QuantTable, options.SubsampleMode, options.RestartInterval, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenJpegsaveTarget(r.image, target.target)
	if err != nil {
		return err
	}
	return nil
}


// Labelregions vips_labelregions label regions in an image
func (r *Image) Labelregions() (error) {
	out, err := vipsgenLabelregions(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// LinearOptions optional arguments for vips_linear
type LinearOptions struct {
	// Uchar Output should be uchar
	Uchar bool
}

// DefaultLinearOptions creates default value for vips_linear optional arguments
func DefaultLinearOptions() *LinearOptions {
	return &LinearOptions{
	}
}

// Linear vips_linear calculate (a * in + b)
//
// The a specifies multiply by this.
// The b specifies add this.
func (r *Image) Linear(a []float64, b []float64, options *LinearOptions) (error) {
	if options != nil {
		out, err := vipsgenLinearWithOptions(r.image, a, b, options.Uchar)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenLinear(r.image, a, b)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// LinecacheOptions optional arguments for vips_linecache
type LinecacheOptions struct {
	// TileHeight Tile height in pixels
	TileHeight int
	// Access Expected access pattern
	Access Access
	// Threaded Allow threaded access
	Threaded bool
	// Persistent Keep cache between evaluations
	Persistent bool
}

// DefaultLinecacheOptions creates default value for vips_linecache optional arguments
func DefaultLinecacheOptions() *LinecacheOptions {
	return &LinecacheOptions{
		TileHeight: 128,
	}
}

// Linecache vips_linecache cache an image as a set of lines
func (r *Image) Linecache(options *LinecacheOptions) (*Image, error) {
	if options != nil {
		out, err := vipsgenLinecacheWithOptions(r.image, options.TileHeight, options.Access, options.Threaded, options.Persistent)
		if err != nil {
			return nil, err
		}
		outImage := newImageRef(out, r.format, nil)
		return outImage, nil
	}
	out, err := vipsgenLinecache(r.image)
	if err != nil {
		return nil, err
	}
	outImage := newImageRef(out, r.format, nil)
	return outImage, nil
}

// MapimOptions optional arguments for vips_mapim
type MapimOptions struct {
	// Interpolate Interpolate pixels with this
	Interpolate *Interpolate
	// Background Background value
	Background []float64
	// Premultiplied Images have premultiplied alpha
	Premultiplied bool
	// Extend How to generate the extra pixels
	Extend Extend
}

// DefaultMapimOptions creates default value for vips_mapim optional arguments
func DefaultMapimOptions() *MapimOptions {
	return &MapimOptions{
		Extend: Extend(5),
	}
}

// Mapim vips_mapim resample with a map image
//
// The index specifies index pixels with this.
func (r *Image) Mapim(index *Image, options *MapimOptions) (error) {
	if options != nil {
		out, err := vipsgenMapimWithOptions(r.image, index.image, options.Interpolate, options.Background, options.Premultiplied, options.Extend)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenMapim(r.image, index.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// MaplutOptions optional arguments for vips_maplut
type MaplutOptions struct {
	// Band Apply one-band lut to this band of in
	Band int
}

// DefaultMaplutOptions creates default value for vips_maplut optional arguments
func DefaultMaplutOptions() *MaplutOptions {
	return &MaplutOptions{
		Band: -1,
	}
}

// Maplut vips_maplut map an image though a lut
//
// The lut specifies look-up table image.
func (r *Image) Maplut(lut *Image, options *MaplutOptions) (error) {
	if options != nil {
		out, err := vipsgenMaplutWithOptions(r.image, lut.image, options.Band)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenMaplut(r.image, lut.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// MatchOptions optional arguments for vips_match
type MatchOptions struct {
	// Hwindow Half window size
	Hwindow int
	// Harea Half area size
	Harea int
	// Search Search to improve tie-points
	Search bool
	// Interpolate Interpolate pixels with this
	Interpolate *Interpolate
}

// DefaultMatchOptions creates default value for vips_match optional arguments
func DefaultMatchOptions() *MatchOptions {
	return &MatchOptions{
		Hwindow: 1,
		Harea: 1,
	}
}

// Match vips_match first-order match of two images
//
// The sec specifies secondary image.
// The xr1 specifies position of first reference tie-point.
// The yr1 specifies position of first reference tie-point.
// The xs1 specifies position of first secondary tie-point.
// The ys1 specifies position of first secondary tie-point.
// The xr2 specifies position of second reference tie-point.
// The yr2 specifies position of second reference tie-point.
// The xs2 specifies position of second secondary tie-point.
// The ys2 specifies position of second secondary tie-point.
func (r *Image) Match(sec *Image, xr1 int, yr1 int, xs1 int, ys1 int, xr2 int, yr2 int, xs2 int, ys2 int, options *MatchOptions) (error) {
	if options != nil {
		out, err := vipsgenMatchWithOptions(r.image, sec.image, xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2, options.Hwindow, options.Harea, options.Search, options.Interpolate)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenMatch(r.image, sec.image, xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Math vips_math apply a math operation to an image
//
// The math specifies math to perform.
func (r *Image) Math(math OperationMath) (error) {
	out, err := vipsgenMath(r.image, math)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Math2 vips_math2 binary math operations
//
// The right specifies right-hand image argument.
// The math2 specifies math to perform.
func (r *Image) Math2(right *Image, math2 OperationMath2) (error) {
	out, err := vipsgenMath2(r.image, right.image, math2)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Math2Const vips_math2_const binary math operations with a constant
//
// The math2 specifies math to perform.
// The c specifies array of constants.
func (r *Image) Math2Const(math2 OperationMath2, c []float64) (error) {
	out, err := vipsgenMath2Const(r.image, math2, c)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Matrixinvert vips_matrixinvert invert an matrix
func (r *Image) Matrixinvert() (error) {
	out, err := vipsgenMatrixinvert(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// MatrixprintOptions optional arguments for vips_matrixprint
type MatrixprintOptions struct {
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultMatrixprintOptions creates default value for vips_matrixprint optional arguments
func DefaultMatrixprintOptions() *MatrixprintOptions {
	return &MatrixprintOptions{
	}
}

// Matrixprint vips_matrixprint print matrix
func (r *Image) Matrixprint(options *MatrixprintOptions) (error) {
	if options != nil {
		err := vipsgenMatrixprintWithOptions(r.image, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenMatrixprint(r.image)
	if err != nil {
		return err
	}
	return nil
}

// MatrixsaveOptions optional arguments for vips_matrixsave
type MatrixsaveOptions struct {
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultMatrixsaveOptions creates default value for vips_matrixsave optional arguments
func DefaultMatrixsaveOptions() *MatrixsaveOptions {
	return &MatrixsaveOptions{
	}
}

// Matrixsave vips_matrixsave save image to matrix
//
// The filename specifies filename to save to.
func (r *Image) Matrixsave(filename string, options *MatrixsaveOptions) (error) {
	if options != nil {
		err := vipsgenMatrixsaveWithOptions(r.image, filename, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenMatrixsave(r.image, filename)
	if err != nil {
		return err
	}
	return nil
}

// MatrixsaveTargetOptions optional arguments for vips_matrixsave_target
type MatrixsaveTargetOptions struct {
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultMatrixsaveTargetOptions creates default value for vips_matrixsave_target optional arguments
func DefaultMatrixsaveTargetOptions() *MatrixsaveTargetOptions {
	return &MatrixsaveTargetOptions{
	}
}

// MatrixsaveTarget vips_matrixsave_target save image to matrix
//
// The target specifies target to save to.
func (r *Image) MatrixsaveTarget(target *Target, options *MatrixsaveTargetOptions) (error) {
	if options != nil {
		err := vipsgenMatrixsaveTargetWithOptions(r.image, target.target, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenMatrixsaveTarget(r.image, target.target)
	if err != nil {
		return err
	}
	return nil
}

// MaxOptions optional arguments for vips_max
type MaxOptions struct {
	// Size Number of maximum values to find
	Size int
}

// DefaultMaxOptions creates default value for vips_max optional arguments
func DefaultMaxOptions() *MaxOptions {
	return &MaxOptions{
		Size: 10,
	}
}

// Max vips_max find image maximum
func (r *Image) Max(options *MaxOptions) (float64, error) {
	if options != nil {
		out, err := vipsgenMaxWithOptions(r.image, options.Size)
		if err != nil {
			return 0, err
		}
		return out, nil
	}
	out, err := vipsgenMax(r.image)
	if err != nil {
		return 0, err
	}
	return out, nil
}


// Maxpair vips_maxpair maximum of a pair of images
//
// The right specifies right-hand image argument.
func (r *Image) Maxpair(right *Image) (error) {
	out, err := vipsgenMaxpair(r.image, right.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// MeasureOptions optional arguments for vips_measure
type MeasureOptions struct {
	// Left Left edge of extract area
	Left int
	// Top Top edge of extract area
	Top int
	// Width Width of extract area
	Width int
	// Height Height of extract area
	Height int
}

// DefaultMeasureOptions creates default value for vips_measure optional arguments
func DefaultMeasureOptions() *MeasureOptions {
	return &MeasureOptions{
		Width: 1,
		Height: 1,
	}
}

// Measure vips_measure measure a set of patches on a color chart
//
// The h specifies number of patches across chart.
// The v specifies number of patches down chart.
func (r *Image) Measure(h int, v int, options *MeasureOptions) (error) {
	if options != nil {
		out, err := vipsgenMeasureWithOptions(r.image, h, v, options.Left, options.Top, options.Width, options.Height)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenMeasure(r.image, h, v)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// MergeOptions optional arguments for vips_merge
type MergeOptions struct {
	// Mblend Maximum blend size
	Mblend int
}

// DefaultMergeOptions creates default value for vips_merge optional arguments
func DefaultMergeOptions() *MergeOptions {
	return &MergeOptions{
		Mblend: 10,
	}
}

// Merge vips_merge merge two images
//
// The sec specifies secondary image.
// The direction specifies horizontal or vertical merge.
// The dx specifies horizontal displacement from sec to ref.
// The dy specifies vertical displacement from sec to ref.
func (r *Image) Merge(sec *Image, direction Direction, dx int, dy int, options *MergeOptions) (error) {
	if options != nil {
		out, err := vipsgenMergeWithOptions(r.image, sec.image, direction, dx, dy, options.Mblend)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenMerge(r.image, sec.image, direction, dx, dy)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// MinOptions optional arguments for vips_min
type MinOptions struct {
	// Size Number of minimum values to find
	Size int
}

// DefaultMinOptions creates default value for vips_min optional arguments
func DefaultMinOptions() *MinOptions {
	return &MinOptions{
		Size: 10,
	}
}

// Min vips_min find image minimum
func (r *Image) Min(options *MinOptions) (float64, error) {
	if options != nil {
		out, err := vipsgenMinWithOptions(r.image, options.Size)
		if err != nil {
			return 0, err
		}
		return out, nil
	}
	out, err := vipsgenMin(r.image)
	if err != nil {
		return 0, err
	}
	return out, nil
}


// Minpair vips_minpair minimum of a pair of images
//
// The right specifies right-hand image argument.
func (r *Image) Minpair(right *Image) (error) {
	out, err := vipsgenMinpair(r.image, right.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Morph vips_morph morphology operation
//
// The mask specifies input matrix image.
// The morph specifies morphological operation to perform.
func (r *Image) Morph(mask *Image, morph OperationMorphology) (error) {
	out, err := vipsgenMorph(r.image, mask.image, morph)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// MosaicOptions optional arguments for vips_mosaic
type MosaicOptions struct {
	// Hwindow Half window size
	Hwindow int
	// Harea Half area size
	Harea int
	// Mblend Maximum blend size
	Mblend int
	// Bandno Band to search for features on
	Bandno int
}

// DefaultMosaicOptions creates default value for vips_mosaic optional arguments
func DefaultMosaicOptions() *MosaicOptions {
	return &MosaicOptions{
		Hwindow: 5,
		Harea: 15,
		Mblend: 10,
	}
}

// Mosaic vips_mosaic mosaic two images
//
// The sec specifies secondary image.
// The direction specifies horizontal or vertical mosaic.
// The xref specifies position of reference tie-point.
// The yref specifies position of reference tie-point.
// The xsec specifies position of secondary tie-point.
// The ysec specifies position of secondary tie-point.
func (r *Image) Mosaic(sec *Image, direction Direction, xref int, yref int, xsec int, ysec int, options *MosaicOptions) (error) {
	if options != nil {
		out, err := vipsgenMosaicWithOptions(r.image, sec.image, direction, xref, yref, xsec, ysec, options.Hwindow, options.Harea, options.Mblend, options.Bandno)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenMosaic(r.image, sec.image, direction, xref, yref, xsec, ysec)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// Mosaic1Options optional arguments for vips_mosaic1
type Mosaic1Options struct {
	// Hwindow Half window size
	Hwindow int
	// Harea Half area size
	Harea int
	// Search Search to improve tie-points
	Search bool
	// Interpolate Interpolate pixels with this
	Interpolate *Interpolate
	// Mblend Maximum blend size
	Mblend int
}

// DefaultMosaic1Options creates default value for vips_mosaic1 optional arguments
func DefaultMosaic1Options() *Mosaic1Options {
	return &Mosaic1Options{
		Hwindow: 5,
		Harea: 15,
		Mblend: 10,
	}
}

// Mosaic1 vips_mosaic1 first-order mosaic of two images
//
// The sec specifies secondary image.
// The direction specifies horizontal or vertical mosaic.
// The xr1 specifies position of first reference tie-point.
// The yr1 specifies position of first reference tie-point.
// The xs1 specifies position of first secondary tie-point.
// The ys1 specifies position of first secondary tie-point.
// The xr2 specifies position of second reference tie-point.
// The yr2 specifies position of second reference tie-point.
// The xs2 specifies position of second secondary tie-point.
// The ys2 specifies position of second secondary tie-point.
func (r *Image) Mosaic1(sec *Image, direction Direction, xr1 int, yr1 int, xs1 int, ys1 int, xr2 int, yr2 int, xs2 int, ys2 int, options *Mosaic1Options) (error) {
	if options != nil {
		out, err := vipsgenMosaic1WithOptions(r.image, sec.image, direction, xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2, options.Hwindow, options.Harea, options.Search, options.Interpolate, options.Mblend)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenMosaic1(r.image, sec.image, direction, xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// MsbOptions optional arguments for vips_msb
type MsbOptions struct {
	// Band Band to msb
	Band int
}

// DefaultMsbOptions creates default value for vips_msb optional arguments
func DefaultMsbOptions() *MsbOptions {
	return &MsbOptions{
	}
}

// Msb vips_msb pick most-significant byte from an image
func (r *Image) Msb(options *MsbOptions) (error) {
	if options != nil {
		out, err := vipsgenMsbWithOptions(r.image, options.Band)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenMsb(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Multiply vips_multiply multiply two images
//
// The right specifies right-hand image argument.
func (r *Image) Multiply(right *Image) (error) {
	out, err := vipsgenMultiply(r.image, right.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Percent vips_percent find threshold for percent of pixels
//
// The percent specifies percent of pixels.
func (r *Image) Percent(percent float64) (int, error) {
	threshold, err := vipsgenPercent(r.image, percent)
	if err != nil {
		return 0, err
	}
	return threshold, nil
}


// Phasecor vips_phasecor calculate phase correlation
//
// The in2 specifies second input image.
func (r *Image) Phasecor(in2 *Image) (error) {
	out, err := vipsgenPhasecor(r.image, in2.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// PngsaveOptions optional arguments for vips_pngsave
type PngsaveOptions struct {
	// Compression Compression factor
	Compression int
	// Interlace Interlace image
	Interlace bool
	// Filter libpng row filter flag(s)
	Filter PngFilter
	// Palette Quantise to 8bpp palette
	Palette bool
	// Q Quantisation quality
	Q int
	// Dither Amount of dithering
	Dither float64
	// Bitdepth Write as a 1, 2, 4, 8 or 16 bit image
	Bitdepth int
	// Effort Quantisation CPU effort
	Effort int
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultPngsaveOptions creates default value for vips_pngsave optional arguments
func DefaultPngsaveOptions() *PngsaveOptions {
	return &PngsaveOptions{
		Compression: 6,
		Q: 100,
		Dither: 1,
		Bitdepth: 8,
		Effort: 7,
	}
}

// Pngsave vips_pngsave save image to png file
//
// The filename specifies filename to save to.
func (r *Image) Pngsave(filename string, options *PngsaveOptions) (error) {
	if options != nil {
		err := vipsgenPngsaveWithOptions(r.image, filename, options.Compression, options.Interlace, options.Filter, options.Palette, options.Q, options.Dither, options.Bitdepth, options.Effort, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenPngsave(r.image, filename)
	if err != nil {
		return err
	}
	return nil
}

// PngsaveBufferOptions optional arguments for vips_pngsave_buffer
type PngsaveBufferOptions struct {
	// Compression Compression factor
	Compression int
	// Interlace Interlace image
	Interlace bool
	// Filter libpng row filter flag(s)
	Filter PngFilter
	// Palette Quantise to 8bpp palette
	Palette bool
	// Q Quantisation quality
	Q int
	// Dither Amount of dithering
	Dither float64
	// Bitdepth Write as a 1, 2, 4, 8 or 16 bit image
	Bitdepth int
	// Effort Quantisation CPU effort
	Effort int
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultPngsaveBufferOptions creates default value for vips_pngsave_buffer optional arguments
func DefaultPngsaveBufferOptions() *PngsaveBufferOptions {
	return &PngsaveBufferOptions{
		Compression: 6,
		Q: 100,
		Dither: 1,
		Bitdepth: 8,
		Effort: 7,
	}
}

// PngsaveBuffer vips_pngsave_buffer save image to png buffer
func (r *Image) PngsaveBuffer(options *PngsaveBufferOptions) ([]byte, error) {
	if options != nil {
		buf, err := vipsgenPngsaveBufferWithOptions(r.image, options.Compression, options.Interlace, options.Filter, options.Palette, options.Q, options.Dither, options.Bitdepth, options.Effort, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return nil, err
		}
		return buf, nil
	}
	buf, err := vipsgenPngsaveBuffer(r.image)
	if err != nil {
		return nil, err
	}
	return buf, nil
}

// PngsaveTargetOptions optional arguments for vips_pngsave_target
type PngsaveTargetOptions struct {
	// Compression Compression factor
	Compression int
	// Interlace Interlace image
	Interlace bool
	// Filter libpng row filter flag(s)
	Filter PngFilter
	// Palette Quantise to 8bpp palette
	Palette bool
	// Q Quantisation quality
	Q int
	// Dither Amount of dithering
	Dither float64
	// Bitdepth Write as a 1, 2, 4, 8 or 16 bit image
	Bitdepth int
	// Effort Quantisation CPU effort
	Effort int
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultPngsaveTargetOptions creates default value for vips_pngsave_target optional arguments
func DefaultPngsaveTargetOptions() *PngsaveTargetOptions {
	return &PngsaveTargetOptions{
		Compression: 6,
		Q: 100,
		Dither: 1,
		Bitdepth: 8,
		Effort: 7,
	}
}

// PngsaveTarget vips_pngsave_target save image to target as PNG
//
// The target specifies target to save to.
func (r *Image) PngsaveTarget(target *Target, options *PngsaveTargetOptions) (error) {
	if options != nil {
		err := vipsgenPngsaveTargetWithOptions(r.image, target.target, options.Compression, options.Interlace, options.Filter, options.Palette, options.Q, options.Dither, options.Bitdepth, options.Effort, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenPngsaveTarget(r.image, target.target)
	if err != nil {
		return err
	}
	return nil
}

// PpmsaveOptions optional arguments for vips_ppmsave
type PpmsaveOptions struct {
	// Format Format to save in
	Format PpmFormat
	// Ascii Save as ascii
	Ascii bool
	// Bitdepth Set to 1 to write as a 1 bit image
	Bitdepth int
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultPpmsaveOptions creates default value for vips_ppmsave optional arguments
func DefaultPpmsaveOptions() *PpmsaveOptions {
	return &PpmsaveOptions{
		Format: PpmFormat(2),
	}
}

// Ppmsave vips_ppmsave save image to ppm file
//
// The filename specifies filename to save to.
func (r *Image) Ppmsave(filename string, options *PpmsaveOptions) (error) {
	if options != nil {
		err := vipsgenPpmsaveWithOptions(r.image, filename, options.Format, options.Ascii, options.Bitdepth, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenPpmsave(r.image, filename)
	if err != nil {
		return err
	}
	return nil
}

// PpmsaveTargetOptions optional arguments for vips_ppmsave_target
type PpmsaveTargetOptions struct {
	// Format Format to save in
	Format PpmFormat
	// Ascii Save as ascii
	Ascii bool
	// Bitdepth Set to 1 to write as a 1 bit image
	Bitdepth int
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultPpmsaveTargetOptions creates default value for vips_ppmsave_target optional arguments
func DefaultPpmsaveTargetOptions() *PpmsaveTargetOptions {
	return &PpmsaveTargetOptions{
		Format: PpmFormat(2),
	}
}

// PpmsaveTarget vips_ppmsave_target save to ppm
//
// The target specifies target to save to.
func (r *Image) PpmsaveTarget(target *Target, options *PpmsaveTargetOptions) (error) {
	if options != nil {
		err := vipsgenPpmsaveTargetWithOptions(r.image, target.target, options.Format, options.Ascii, options.Bitdepth, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenPpmsaveTarget(r.image, target.target)
	if err != nil {
		return err
	}
	return nil
}

// PremultiplyOptions optional arguments for vips_premultiply
type PremultiplyOptions struct {
	// MaxAlpha Maximum value of alpha channel
	MaxAlpha float64
}

// DefaultPremultiplyOptions creates default value for vips_premultiply optional arguments
func DefaultPremultiplyOptions() *PremultiplyOptions {
	return &PremultiplyOptions{
		MaxAlpha: 255,
	}
}

// Premultiply vips_premultiply premultiply image alpha
func (r *Image) Premultiply(options *PremultiplyOptions) (error) {
	if options != nil {
		out, err := vipsgenPremultiplyWithOptions(r.image, options.MaxAlpha)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenPremultiply(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Prewitt vips_prewitt Prewitt edge detector
func (r *Image) Prewitt() (error) {
	out, err := vipsgenPrewitt(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Profile vips_profile find image profiles
func (r *Image) Profile() (*Image, *Image, error) {
	columns, rows, err := vipsgenProfile(r.image)
	if err != nil {
		return nil, nil, err
	}
	columnsImage := newImageRef(columns, r.format, nil)
	rowsImage := newImageRef(rows, r.format, nil)
	return columnsImage, rowsImage, nil
}


// Project vips_project find image projections
func (r *Image) Project() (*Image, *Image, error) {
	columns, rows, err := vipsgenProject(r.image)
	if err != nil {
		return nil, nil, err
	}
	columnsImage := newImageRef(columns, r.format, nil)
	rowsImage := newImageRef(rows, r.format, nil)
	return columnsImage, rowsImage, nil
}

// QuadraticOptions optional arguments for vips_quadratic
type QuadraticOptions struct {
	// Interpolate Interpolate values with this
	Interpolate *Interpolate
}

// DefaultQuadraticOptions creates default value for vips_quadratic optional arguments
func DefaultQuadraticOptions() *QuadraticOptions {
	return &QuadraticOptions{
	}
}

// Quadratic vips_quadratic resample an image with a quadratic transform
//
// The coeff specifies coefficient matrix.
func (r *Image) Quadratic(coeff *Image, options *QuadraticOptions) (error) {
	if options != nil {
		out, err := vipsgenQuadraticWithOptions(r.image, coeff.image, options.Interpolate)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenQuadratic(r.image, coeff.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Rad2float vips_rad2float unpack Radiance coding to float RGB
func (r *Image) Rad2float() (error) {
	out, err := vipsgenRad2float(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// RadsaveOptions optional arguments for vips_radsave
type RadsaveOptions struct {
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultRadsaveOptions creates default value for vips_radsave optional arguments
func DefaultRadsaveOptions() *RadsaveOptions {
	return &RadsaveOptions{
	}
}

// Radsave vips_radsave save image to Radiance file
//
// The filename specifies filename to save to.
func (r *Image) Radsave(filename string, options *RadsaveOptions) (error) {
	if options != nil {
		err := vipsgenRadsaveWithOptions(r.image, filename, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenRadsave(r.image, filename)
	if err != nil {
		return err
	}
	return nil
}

// RadsaveBufferOptions optional arguments for vips_radsave_buffer
type RadsaveBufferOptions struct {
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultRadsaveBufferOptions creates default value for vips_radsave_buffer optional arguments
func DefaultRadsaveBufferOptions() *RadsaveBufferOptions {
	return &RadsaveBufferOptions{
	}
}

// RadsaveBuffer vips_radsave_buffer save image to Radiance buffer
func (r *Image) RadsaveBuffer(options *RadsaveBufferOptions) ([]byte, error) {
	if options != nil {
		buf, err := vipsgenRadsaveBufferWithOptions(r.image, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return nil, err
		}
		return buf, nil
	}
	buf, err := vipsgenRadsaveBuffer(r.image)
	if err != nil {
		return nil, err
	}
	return buf, nil
}

// RadsaveTargetOptions optional arguments for vips_radsave_target
type RadsaveTargetOptions struct {
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultRadsaveTargetOptions creates default value for vips_radsave_target optional arguments
func DefaultRadsaveTargetOptions() *RadsaveTargetOptions {
	return &RadsaveTargetOptions{
	}
}

// RadsaveTarget vips_radsave_target save image to Radiance target
//
// The target specifies target to save to.
func (r *Image) RadsaveTarget(target *Target, options *RadsaveTargetOptions) (error) {
	if options != nil {
		err := vipsgenRadsaveTargetWithOptions(r.image, target.target, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenRadsaveTarget(r.image, target.target)
	if err != nil {
		return err
	}
	return nil
}


// Rank vips_rank rank filter
//
// The width specifies window width in pixels.
// The height specifies window height in pixels.
// The index specifies select pixel at index.
func (r *Image) Rank(width int, height int, index int) (error) {
	out, err := vipsgenRank(r.image, width, height, index)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// RawsaveOptions optional arguments for vips_rawsave
type RawsaveOptions struct {
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultRawsaveOptions creates default value for vips_rawsave optional arguments
func DefaultRawsaveOptions() *RawsaveOptions {
	return &RawsaveOptions{
	}
}

// Rawsave vips_rawsave save image to raw file
//
// The filename specifies filename to save to.
func (r *Image) Rawsave(filename string, options *RawsaveOptions) (error) {
	if options != nil {
		err := vipsgenRawsaveWithOptions(r.image, filename, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenRawsave(r.image, filename)
	if err != nil {
		return err
	}
	return nil
}

// RawsaveBufferOptions optional arguments for vips_rawsave_buffer
type RawsaveBufferOptions struct {
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultRawsaveBufferOptions creates default value for vips_rawsave_buffer optional arguments
func DefaultRawsaveBufferOptions() *RawsaveBufferOptions {
	return &RawsaveBufferOptions{
	}
}

// RawsaveBuffer vips_rawsave_buffer write raw image to buffer
func (r *Image) RawsaveBuffer(options *RawsaveBufferOptions) ([]byte, error) {
	if options != nil {
		buf, err := vipsgenRawsaveBufferWithOptions(r.image, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return nil, err
		}
		return buf, nil
	}
	buf, err := vipsgenRawsaveBuffer(r.image)
	if err != nil {
		return nil, err
	}
	return buf, nil
}

// RawsaveTargetOptions optional arguments for vips_rawsave_target
type RawsaveTargetOptions struct {
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultRawsaveTargetOptions creates default value for vips_rawsave_target optional arguments
func DefaultRawsaveTargetOptions() *RawsaveTargetOptions {
	return &RawsaveTargetOptions{
	}
}

// RawsaveTarget vips_rawsave_target write raw image to target
//
// The target specifies target to save to.
func (r *Image) RawsaveTarget(target *Target, options *RawsaveTargetOptions) (error) {
	if options != nil {
		err := vipsgenRawsaveTargetWithOptions(r.image, target.target, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenRawsaveTarget(r.image, target.target)
	if err != nil {
		return err
	}
	return nil
}


// Recomb vips_recomb linear recombination with matrix
//
// The m specifies matrix of coefficients.
func (r *Image) Recomb(m *Image) (error) {
	out, err := vipsgenRecomb(r.image, m.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// ReduceOptions optional arguments for vips_reduce
type ReduceOptions struct {
	// Kernel Resampling kernel
	Kernel Kernel
	// Gap Reducing gap
	Gap float64
}

// DefaultReduceOptions creates default value for vips_reduce optional arguments
func DefaultReduceOptions() *ReduceOptions {
	return &ReduceOptions{
		Kernel: Kernel(5),
	}
}

// Reduce vips_reduce reduce an image
//
// The hshrink specifies horizontal shrink factor.
// The vshrink specifies vertical shrink factor.
func (r *Image) Reduce(hshrink float64, vshrink float64, options *ReduceOptions) (error) {
	if options != nil {
		out, err := vipsgenReduceWithOptions(r.image, hshrink, vshrink, options.Kernel, options.Gap)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenReduce(r.image, hshrink, vshrink)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// ReducehOptions optional arguments for vips_reduceh
type ReducehOptions struct {
	// Kernel Resampling kernel
	Kernel Kernel
	// Gap Reducing gap
	Gap float64
}

// DefaultReducehOptions creates default value for vips_reduceh optional arguments
func DefaultReducehOptions() *ReducehOptions {
	return &ReducehOptions{
		Kernel: Kernel(5),
	}
}

// Reduceh vips_reduceh shrink an image horizontally
//
// The hshrink specifies horizontal shrink factor.
func (r *Image) Reduceh(hshrink float64, options *ReducehOptions) (error) {
	if options != nil {
		out, err := vipsgenReducehWithOptions(r.image, hshrink, options.Kernel, options.Gap)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenReduceh(r.image, hshrink)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// ReducevOptions optional arguments for vips_reducev
type ReducevOptions struct {
	// Kernel Resampling kernel
	Kernel Kernel
	// Gap Reducing gap
	Gap float64
}

// DefaultReducevOptions creates default value for vips_reducev optional arguments
func DefaultReducevOptions() *ReducevOptions {
	return &ReducevOptions{
		Kernel: Kernel(5),
	}
}

// Reducev vips_reducev shrink an image vertically
//
// The vshrink specifies vertical shrink factor.
func (r *Image) Reducev(vshrink float64, options *ReducevOptions) (error) {
	if options != nil {
		out, err := vipsgenReducevWithOptions(r.image, vshrink, options.Kernel, options.Gap)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenReducev(r.image, vshrink)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Relational vips_relational relational operation on two images
//
// The right specifies right-hand image argument.
// The relational specifies relational to perform.
func (r *Image) Relational(right *Image, relational OperationRelational) (error) {
	out, err := vipsgenRelational(r.image, right.image, relational)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// RelationalConst vips_relational_const relational operations against a constant
//
// The relational specifies relational to perform.
// The c specifies array of constants.
func (r *Image) RelationalConst(relational OperationRelational, c []float64) (error) {
	out, err := vipsgenRelationalConst(r.image, relational, c)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Remainder vips_remainder remainder after integer division of two images
//
// The right specifies right-hand image argument.
func (r *Image) Remainder(right *Image) (error) {
	out, err := vipsgenRemainder(r.image, right.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// RemainderConst vips_remainder_const remainder after integer division of an image and a constant
//
// The c specifies array of constants.
func (r *Image) RemainderConst(c []float64) (error) {
	out, err := vipsgenRemainderConst(r.image, c)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Replicate vips_replicate replicate an image
//
// The across specifies repeat this many times horizontally.
// The down specifies repeat this many times vertically.
func (r *Image) Replicate(across int, down int) (error) {
	out, err := vipsgenReplicate(r.image, across, down)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// ResizeOptions optional arguments for vips_resize
type ResizeOptions struct {
	// Kernel Resampling kernel
	Kernel Kernel
	// Gap Reducing gap
	Gap float64
	// Vscale Vertical scale image by this factor
	Vscale float64
}

// DefaultResizeOptions creates default value for vips_resize optional arguments
func DefaultResizeOptions() *ResizeOptions {
	return &ResizeOptions{
		Kernel: Kernel(5),
		Gap: 2,
	}
}

// Resize vips_resize resize an image
//
// The scale specifies scale image by this factor.
func (r *Image) Resize(scale float64, options *ResizeOptions) (error) {
	if options != nil {
		out, err := vipsgenResizeWithOptions(r.image, scale, options.Kernel, options.Gap, options.Vscale)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenResize(r.image, scale)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Rot vips_rot rotate an image
//
// The angle specifies angle to rotate image.
func (r *Image) Rot(angle Angle) (error) {
	out, err := vipsgenRot(r.image, angle)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// Rot45Options optional arguments for vips_rot45
type Rot45Options struct {
	// Angle Angle to rotate image
	Angle Angle45
}

// DefaultRot45Options creates default value for vips_rot45 optional arguments
func DefaultRot45Options() *Rot45Options {
	return &Rot45Options{
		Angle: Angle45(1),
	}
}

// Rot45 vips_rot45 rotate an image
func (r *Image) Rot45(options *Rot45Options) (error) {
	if options != nil {
		out, err := vipsgenRot45WithOptions(r.image, options.Angle)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenRot45(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// RotateOptions optional arguments for vips_rotate
type RotateOptions struct {
	// Interpolate Interpolate pixels with this
	Interpolate *Interpolate
	// Background Background value
	Background []float64
	// Odx Horizontal output displacement
	Odx float64
	// Ody Vertical output displacement
	Ody float64
	// Idx Horizontal input displacement
	Idx float64
	// Idy Vertical input displacement
	Idy float64
}

// DefaultRotateOptions creates default value for vips_rotate optional arguments
func DefaultRotateOptions() *RotateOptions {
	return &RotateOptions{
	}
}

// Rotate vips_rotate rotate an image by a number of degrees
//
// The angle specifies rotate clockwise by this many degrees.
func (r *Image) Rotate(angle float64, options *RotateOptions) (error) {
	if options != nil {
		out, err := vipsgenRotateWithOptions(r.image, angle, options.Interpolate, options.Background, options.Odx, options.Ody, options.Idx, options.Idy)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenRotate(r.image, angle)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Round vips_round perform a round function on an image
//
// The round specifies rounding operation to perform.
func (r *Image) Round(round OperationRound) (error) {
	out, err := vipsgenRound(r.image, round)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// SRGB2HSV vips_sRGB2HSV transform sRGB to HSV
func (r *Image) SRGB2HSV() (error) {
	out, err := vipsgenSRGB2HSV(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// SRGB2scRGB vips_sRGB2scRGB convert an sRGB image to scRGB
func (r *Image) SRGB2scRGB() (error) {
	out, err := vipsgenSRGB2scRGB(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// ScRGB2BWOptions optional arguments for vips_scRGB2BW
type ScRGB2BWOptions struct {
	// Depth Output device space depth in bits
	Depth int
}

// DefaultScRGB2BWOptions creates default value for vips_scRGB2BW optional arguments
func DefaultScRGB2BWOptions() *ScRGB2BWOptions {
	return &ScRGB2BWOptions{
		Depth: 8,
	}
}

// ScRGB2BW vips_scRGB2BW convert scRGB to BW
func (r *Image) ScRGB2BW(options *ScRGB2BWOptions) (error) {
	if options != nil {
		out, err := vipsgenScRGB2BWWithOptions(r.image, options.Depth)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenScRGB2BW(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// ScRGB2XYZ vips_scRGB2XYZ transform scRGB to XYZ
func (r *Image) ScRGB2XYZ() (error) {
	out, err := vipsgenScRGB2XYZ(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// ScRGB2sRGBOptions optional arguments for vips_scRGB2sRGB
type ScRGB2sRGBOptions struct {
	// Depth Output device space depth in bits
	Depth int
}

// DefaultScRGB2sRGBOptions creates default value for vips_scRGB2sRGB optional arguments
func DefaultScRGB2sRGBOptions() *ScRGB2sRGBOptions {
	return &ScRGB2sRGBOptions{
		Depth: 8,
	}
}

// ScRGB2sRGB vips_scRGB2sRGB convert an scRGB image to sRGB
func (r *Image) ScRGB2sRGB(options *ScRGB2sRGBOptions) (error) {
	if options != nil {
		out, err := vipsgenScRGB2sRGBWithOptions(r.image, options.Depth)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenScRGB2sRGB(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// ScaleOptions optional arguments for vips_scale
type ScaleOptions struct {
	// Exp Exponent for log scale
	Exp float64
	// Log Log scale
	Log bool
}

// DefaultScaleOptions creates default value for vips_scale optional arguments
func DefaultScaleOptions() *ScaleOptions {
	return &ScaleOptions{
		Exp: 0.25,
	}
}

// Scale vips_scale scale an image to uchar
func (r *Image) Scale(options *ScaleOptions) (error) {
	if options != nil {
		out, err := vipsgenScaleWithOptions(r.image, options.Exp, options.Log)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenScale(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Scharr vips_scharr Scharr edge detector
func (r *Image) Scharr() (error) {
	out, err := vipsgenScharr(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// SequentialOptions optional arguments for vips_sequential
type SequentialOptions struct {
	// TileHeight Tile height in pixels
	TileHeight int
}

// DefaultSequentialOptions creates default value for vips_sequential optional arguments
func DefaultSequentialOptions() *SequentialOptions {
	return &SequentialOptions{
		TileHeight: 1,
	}
}

// Sequential vips_sequential check sequential access
func (r *Image) Sequential(options *SequentialOptions) (*Image, error) {
	if options != nil {
		out, err := vipsgenSequentialWithOptions(r.image, options.TileHeight)
		if err != nil {
			return nil, err
		}
		outImage := newImageRef(out, r.format, nil)
		return outImage, nil
	}
	out, err := vipsgenSequential(r.image)
	if err != nil {
		return nil, err
	}
	outImage := newImageRef(out, r.format, nil)
	return outImage, nil
}

// SharpenOptions optional arguments for vips_sharpen
type SharpenOptions struct {
	// Sigma Sigma of Gaussian
	Sigma float64
	// X1 Flat/jaggy threshold
	X1 float64
	// Y2 Maximum brightening
	Y2 float64
	// Y3 Maximum darkening
	Y3 float64
	// M1 Slope for flat areas
	M1 float64
	// M2 Slope for jaggy areas
	M2 float64
}

// DefaultSharpenOptions creates default value for vips_sharpen optional arguments
func DefaultSharpenOptions() *SharpenOptions {
	return &SharpenOptions{
		Sigma: 0.5,
		X1: 2,
		Y2: 10,
		Y3: 20,
		M2: 3,
	}
}

// Sharpen vips_sharpen unsharp masking for print
func (r *Image) Sharpen(options *SharpenOptions) (error) {
	if options != nil {
		out, err := vipsgenSharpenWithOptions(r.image, options.Sigma, options.X1, options.Y2, options.Y3, options.M1, options.M2)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenSharpen(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// ShrinkOptions optional arguments for vips_shrink
type ShrinkOptions struct {
	// Ceil Round-up output dimensions
	Ceil bool
}

// DefaultShrinkOptions creates default value for vips_shrink optional arguments
func DefaultShrinkOptions() *ShrinkOptions {
	return &ShrinkOptions{
	}
}

// Shrink vips_shrink shrink an image
//
// The hshrink specifies horizontal shrink factor.
// The vshrink specifies vertical shrink factor.
func (r *Image) Shrink(hshrink float64, vshrink float64, options *ShrinkOptions) (error) {
	if options != nil {
		out, err := vipsgenShrinkWithOptions(r.image, hshrink, vshrink, options.Ceil)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenShrink(r.image, hshrink, vshrink)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// ShrinkhOptions optional arguments for vips_shrinkh
type ShrinkhOptions struct {
	// Ceil Round-up output dimensions
	Ceil bool
}

// DefaultShrinkhOptions creates default value for vips_shrinkh optional arguments
func DefaultShrinkhOptions() *ShrinkhOptions {
	return &ShrinkhOptions{
	}
}

// Shrinkh vips_shrinkh shrink an image horizontally
//
// The hshrink specifies horizontal shrink factor.
func (r *Image) Shrinkh(hshrink int, options *ShrinkhOptions) (error) {
	if options != nil {
		out, err := vipsgenShrinkhWithOptions(r.image, hshrink, options.Ceil)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenShrinkh(r.image, hshrink)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// ShrinkvOptions optional arguments for vips_shrinkv
type ShrinkvOptions struct {
	// Ceil Round-up output dimensions
	Ceil bool
}

// DefaultShrinkvOptions creates default value for vips_shrinkv optional arguments
func DefaultShrinkvOptions() *ShrinkvOptions {
	return &ShrinkvOptions{
	}
}

// Shrinkv vips_shrinkv shrink an image vertically
//
// The vshrink specifies vertical shrink factor.
func (r *Image) Shrinkv(vshrink int, options *ShrinkvOptions) (error) {
	if options != nil {
		out, err := vipsgenShrinkvWithOptions(r.image, vshrink, options.Ceil)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenShrinkv(r.image, vshrink)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Sign vips_sign unit vector of pixel
func (r *Image) Sign() (error) {
	out, err := vipsgenSign(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// SimilarityOptions optional arguments for vips_similarity
type SimilarityOptions struct {
	// Scale Scale by this factor
	Scale float64
	// Angle Rotate clockwise by this many degrees
	Angle float64
	// Interpolate Interpolate pixels with this
	Interpolate *Interpolate
	// Background Background value
	Background []float64
	// Odx Horizontal output displacement
	Odx float64
	// Ody Vertical output displacement
	Ody float64
	// Idx Horizontal input displacement
	Idx float64
	// Idy Vertical input displacement
	Idy float64
}

// DefaultSimilarityOptions creates default value for vips_similarity optional arguments
func DefaultSimilarityOptions() *SimilarityOptions {
	return &SimilarityOptions{
		Scale: 1,
	}
}

// Similarity vips_similarity similarity transform of an image
func (r *Image) Similarity(options *SimilarityOptions) (error) {
	if options != nil {
		out, err := vipsgenSimilarityWithOptions(r.image, options.Scale, options.Angle, options.Interpolate, options.Background, options.Odx, options.Ody, options.Idx, options.Idy)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenSimilarity(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// SmartcropOptions optional arguments for vips_smartcrop
type SmartcropOptions struct {
	// Interesting How to measure interestingness
	Interesting Interesting
	// Premultiplied Input image already has premultiplied alpha
	Premultiplied bool
}

// DefaultSmartcropOptions creates default value for vips_smartcrop optional arguments
func DefaultSmartcropOptions() *SmartcropOptions {
	return &SmartcropOptions{
		Interesting: Interesting(3),
	}
}

// Smartcrop vips_smartcrop extract an area from an image
//
// The width specifies width of extract area.
// The height specifies height of extract area.
func (r *Image) Smartcrop(width int, height int, options *SmartcropOptions) (error) {
	if options != nil {
		out, err := vipsgenSmartcropWithOptions(r.image, width, height, options.Interesting, options.Premultiplied)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenSmartcrop(r.image, width, height)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Sobel vips_sobel Sobel edge detector
func (r *Image) Sobel() (error) {
	out, err := vipsgenSobel(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Spcor vips_spcor spatial correlation
//
// The ref specifies input reference image.
func (r *Image) Spcor(ref *Image) (error) {
	out, err := vipsgenSpcor(r.image, ref.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Spectrum vips_spectrum make displayable power spectrum
func (r *Image) Spectrum() (error) {
	out, err := vipsgenSpectrum(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Stats vips_stats find many image stats
func (r *Image) Stats() (error) {
	out, err := vipsgenStats(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// StdifOptions optional arguments for vips_stdif
type StdifOptions struct {
	// S0 New deviation
	S0 float64
	// B Weight of new deviation
	B float64
	// M0 New mean
	M0 float64
	// A Weight of new mean
	A float64
}

// DefaultStdifOptions creates default value for vips_stdif optional arguments
func DefaultStdifOptions() *StdifOptions {
	return &StdifOptions{
		S0: 50,
		B: 0.5,
		M0: 128,
		A: 0.5,
	}
}

// Stdif vips_stdif statistical difference
//
// The width specifies window width in pixels.
// The height specifies window height in pixels.
func (r *Image) Stdif(width int, height int, options *StdifOptions) (error) {
	if options != nil {
		out, err := vipsgenStdifWithOptions(r.image, width, height, options.S0, options.B, options.M0, options.A)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenStdif(r.image, width, height)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// SubsampleOptions optional arguments for vips_subsample
type SubsampleOptions struct {
	// Point Point sample
	Point bool
}

// DefaultSubsampleOptions creates default value for vips_subsample optional arguments
func DefaultSubsampleOptions() *SubsampleOptions {
	return &SubsampleOptions{
	}
}

// Subsample vips_subsample subsample an image
//
// The xfac specifies horizontal subsample factor.
// The yfac specifies vertical subsample factor.
func (r *Image) Subsample(xfac int, yfac int, options *SubsampleOptions) (error) {
	if options != nil {
		out, err := vipsgenSubsampleWithOptions(r.image, xfac, yfac, options.Point)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenSubsample(r.image, xfac, yfac)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Subtract vips_subtract subtract two images
//
// The right specifies right-hand image argument.
func (r *Image) Subtract(right *Image) (error) {
	out, err := vipsgenSubtract(r.image, right.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// ThumbnailImageOptions optional arguments for vips_thumbnail_image
type ThumbnailImageOptions struct {
	// Height Size to this height
	Height int
	// Size Only upsize, only downsize, or both
	Size Size
	// NoRotate Don't use orientation tags to rotate image upright
	NoRotate bool
	// Crop Reduce to fill target rectangle, then crop
	Crop Interesting
	// Linear Reduce in linear light
	Linear bool
	// ImportProfile Fallback import profile
	ImportProfile string
	// ExportProfile Fallback export profile
	ExportProfile string
	// Intent Rendering intent
	Intent Intent
	// FailOn Error level to fail on
	FailOn FailOn
}

// DefaultThumbnailImageOptions creates default value for vips_thumbnail_image optional arguments
func DefaultThumbnailImageOptions() *ThumbnailImageOptions {
	return &ThumbnailImageOptions{
		Height: 1,
		Intent: Intent(1),
	}
}

// ThumbnailImage vips_thumbnail_image generate thumbnail from image
//
// The width specifies size to this width.
func (r *Image) ThumbnailImage(width int, options *ThumbnailImageOptions) (error) {
	if options != nil {
		out, err := vipsgenThumbnailImageWithOptions(r.image, width, options.Height, options.Size, options.NoRotate, options.Crop, options.Linear, options.ImportProfile, options.ExportProfile, options.Intent, options.FailOn)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenThumbnailImage(r.image, width)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// TilecacheOptions optional arguments for vips_tilecache
type TilecacheOptions struct {
	// TileWidth Tile width in pixels
	TileWidth int
	// TileHeight Tile height in pixels
	TileHeight int
	// MaxTiles Maximum number of tiles to cache
	MaxTiles int
	// Access Expected access pattern
	Access Access
	// Threaded Allow threaded access
	Threaded bool
	// Persistent Keep cache between evaluations
	Persistent bool
}

// DefaultTilecacheOptions creates default value for vips_tilecache optional arguments
func DefaultTilecacheOptions() *TilecacheOptions {
	return &TilecacheOptions{
		TileWidth: 128,
		TileHeight: 128,
		MaxTiles: 1000,
	}
}

// Tilecache vips_tilecache cache an image as a set of tiles
func (r *Image) Tilecache(options *TilecacheOptions) (*Image, error) {
	if options != nil {
		out, err := vipsgenTilecacheWithOptions(r.image, options.TileWidth, options.TileHeight, options.MaxTiles, options.Access, options.Threaded, options.Persistent)
		if err != nil {
			return nil, err
		}
		outImage := newImageRef(out, r.format, nil)
		return outImage, nil
	}
	out, err := vipsgenTilecache(r.image)
	if err != nil {
		return nil, err
	}
	outImage := newImageRef(out, r.format, nil)
	return outImage, nil
}

// Transpose3dOptions optional arguments for vips_transpose3d
type Transpose3dOptions struct {
	// PageHeight Height of each input page
	PageHeight int
}

// DefaultTranspose3dOptions creates default value for vips_transpose3d optional arguments
func DefaultTranspose3dOptions() *Transpose3dOptions {
	return &Transpose3dOptions{
	}
}

// Transpose3d vips_transpose3d transpose3d an image
func (r *Image) Transpose3d(options *Transpose3dOptions) (error) {
	if options != nil {
		out, err := vipsgenTranspose3dWithOptions(r.image, options.PageHeight)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenTranspose3d(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// UnpremultiplyOptions optional arguments for vips_unpremultiply
type UnpremultiplyOptions struct {
	// MaxAlpha Maximum value of alpha channel
	MaxAlpha float64
	// AlphaBand Unpremultiply with this alpha
	AlphaBand int
}

// DefaultUnpremultiplyOptions creates default value for vips_unpremultiply optional arguments
func DefaultUnpremultiplyOptions() *UnpremultiplyOptions {
	return &UnpremultiplyOptions{
		MaxAlpha: 255,
		AlphaBand: 3,
	}
}

// Unpremultiply vips_unpremultiply unpremultiply image alpha
func (r *Image) Unpremultiply(options *UnpremultiplyOptions) (error) {
	if options != nil {
		out, err := vipsgenUnpremultiplyWithOptions(r.image, options.MaxAlpha, options.AlphaBand)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenUnpremultiply(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// VipssaveOptions optional arguments for vips_vipssave
type VipssaveOptions struct {
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultVipssaveOptions creates default value for vips_vipssave optional arguments
func DefaultVipssaveOptions() *VipssaveOptions {
	return &VipssaveOptions{
	}
}

// Vipssave vips_vipssave save image to file in vips format
//
// The filename specifies filename to save to.
func (r *Image) Vipssave(filename string, options *VipssaveOptions) (error) {
	if options != nil {
		err := vipsgenVipssaveWithOptions(r.image, filename, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenVipssave(r.image, filename)
	if err != nil {
		return err
	}
	return nil
}

// VipssaveTargetOptions optional arguments for vips_vipssave_target
type VipssaveTargetOptions struct {
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultVipssaveTargetOptions creates default value for vips_vipssave_target optional arguments
func DefaultVipssaveTargetOptions() *VipssaveTargetOptions {
	return &VipssaveTargetOptions{
	}
}

// VipssaveTarget vips_vipssave_target save image to target in vips format
//
// The target specifies target to save to.
func (r *Image) VipssaveTarget(target *Target, options *VipssaveTargetOptions) (error) {
	if options != nil {
		err := vipsgenVipssaveTargetWithOptions(r.image, target.target, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenVipssaveTarget(r.image, target.target)
	if err != nil {
		return err
	}
	return nil
}

// WebpsaveOptions optional arguments for vips_webpsave
type WebpsaveOptions struct {
	// Q Q factor
	Q int
	// Lossless Enable lossless compression
	Lossless bool
	// Preset Preset for lossy compression
	Preset WebpPreset
	// SmartSubsample Enable high quality chroma subsampling
	SmartSubsample bool
	// NearLossless Enable preprocessing in lossless mode (uses Q)
	NearLossless bool
	// AlphaQ Change alpha plane fidelity for lossy compression
	AlphaQ int
	// MinSize Optimise for minimum size
	MinSize bool
	// Kmin Minimum number of frames between key frames
	Kmin int
	// Kmax Maximum number of frames between key frames
	Kmax int
	// Effort Level of CPU effort to reduce file size
	Effort int
	// TargetSize Desired target size in bytes
	TargetSize int
	// Mixed Allow mixed encoding (might reduce file size)
	Mixed bool
	// SmartDeblock Enable auto-adjusting of the deblocking filter
	SmartDeblock bool
	// Passes Number of entropy-analysis passes (in [1..10])
	Passes int
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultWebpsaveOptions creates default value for vips_webpsave optional arguments
func DefaultWebpsaveOptions() *WebpsaveOptions {
	return &WebpsaveOptions{
		Q: 75,
		AlphaQ: 100,
		Kmin: 2147483646,
		Kmax: 2147483647,
		Effort: 4,
		Passes: 1,
	}
}

// Webpsave vips_webpsave save as WebP
//
// The filename specifies filename to save to.
func (r *Image) Webpsave(filename string, options *WebpsaveOptions) (error) {
	if options != nil {
		err := vipsgenWebpsaveWithOptions(r.image, filename, options.Q, options.Lossless, options.Preset, options.SmartSubsample, options.NearLossless, options.AlphaQ, options.MinSize, options.Kmin, options.Kmax, options.Effort, options.TargetSize, options.Mixed, options.SmartDeblock, options.Passes, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenWebpsave(r.image, filename)
	if err != nil {
		return err
	}
	return nil
}

// WebpsaveBufferOptions optional arguments for vips_webpsave_buffer
type WebpsaveBufferOptions struct {
	// Q Q factor
	Q int
	// Lossless Enable lossless compression
	Lossless bool
	// Preset Preset for lossy compression
	Preset WebpPreset
	// SmartSubsample Enable high quality chroma subsampling
	SmartSubsample bool
	// NearLossless Enable preprocessing in lossless mode (uses Q)
	NearLossless bool
	// AlphaQ Change alpha plane fidelity for lossy compression
	AlphaQ int
	// MinSize Optimise for minimum size
	MinSize bool
	// Kmin Minimum number of frames between key frames
	Kmin int
	// Kmax Maximum number of frames between key frames
	Kmax int
	// Effort Level of CPU effort to reduce file size
	Effort int
	// TargetSize Desired target size in bytes
	TargetSize int
	// Mixed Allow mixed encoding (might reduce file size)
	Mixed bool
	// SmartDeblock Enable auto-adjusting of the deblocking filter
	SmartDeblock bool
	// Passes Number of entropy-analysis passes (in [1..10])
	Passes int
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultWebpsaveBufferOptions creates default value for vips_webpsave_buffer optional arguments
func DefaultWebpsaveBufferOptions() *WebpsaveBufferOptions {
	return &WebpsaveBufferOptions{
		Q: 75,
		AlphaQ: 100,
		Kmin: 2147483646,
		Kmax: 2147483647,
		Effort: 4,
		Passes: 1,
	}
}

// WebpsaveBuffer vips_webpsave_buffer save as WebP
func (r *Image) WebpsaveBuffer(options *WebpsaveBufferOptions) ([]byte, error) {
	if options != nil {
		buf, err := vipsgenWebpsaveBufferWithOptions(r.image, options.Q, options.Lossless, options.Preset, options.SmartSubsample, options.NearLossless, options.AlphaQ, options.MinSize, options.Kmin, options.Kmax, options.Effort, options.TargetSize, options.Mixed, options.SmartDeblock, options.Passes, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return nil, err
		}
		return buf, nil
	}
	buf, err := vipsgenWebpsaveBuffer(r.image)
	if err != nil {
		return nil, err
	}
	return buf, nil
}

// WebpsaveTargetOptions optional arguments for vips_webpsave_target
type WebpsaveTargetOptions struct {
	// Q Q factor
	Q int
	// Lossless Enable lossless compression
	Lossless bool
	// Preset Preset for lossy compression
	Preset WebpPreset
	// SmartSubsample Enable high quality chroma subsampling
	SmartSubsample bool
	// NearLossless Enable preprocessing in lossless mode (uses Q)
	NearLossless bool
	// AlphaQ Change alpha plane fidelity for lossy compression
	AlphaQ int
	// MinSize Optimise for minimum size
	MinSize bool
	// Kmin Minimum number of frames between key frames
	Kmin int
	// Kmax Maximum number of frames between key frames
	Kmax int
	// Effort Level of CPU effort to reduce file size
	Effort int
	// TargetSize Desired target size in bytes
	TargetSize int
	// Mixed Allow mixed encoding (might reduce file size)
	Mixed bool
	// SmartDeblock Enable auto-adjusting of the deblocking filter
	SmartDeblock bool
	// Passes Number of entropy-analysis passes (in [1..10])
	Passes int
	// Keep Which metadata to retain
	Keep Keep
	// Background Background value
	Background []float64
	// PageHeight Set page height for multipage save
	PageHeight int
	// Profile Filename of ICC profile to embed
	Profile string
}

// DefaultWebpsaveTargetOptions creates default value for vips_webpsave_target optional arguments
func DefaultWebpsaveTargetOptions() *WebpsaveTargetOptions {
	return &WebpsaveTargetOptions{
		Q: 75,
		AlphaQ: 100,
		Kmin: 2147483646,
		Kmax: 2147483647,
		Effort: 4,
		Passes: 1,
	}
}

// WebpsaveTarget vips_webpsave_target save as WebP
//
// The target specifies target to save to.
func (r *Image) WebpsaveTarget(target *Target, options *WebpsaveTargetOptions) (error) {
	if options != nil {
		err := vipsgenWebpsaveTargetWithOptions(r.image, target.target, options.Q, options.Lossless, options.Preset, options.SmartSubsample, options.NearLossless, options.AlphaQ, options.MinSize, options.Kmin, options.Kmax, options.Effort, options.TargetSize, options.Mixed, options.SmartDeblock, options.Passes, options.Keep, options.Background, options.PageHeight, options.Profile)
		if err != nil {
			return err
		}
		return nil
	}
	err := vipsgenWebpsaveTarget(r.image, target.target)
	if err != nil {
		return err
	}
	return nil
}

// WrapOptions optional arguments for vips_wrap
type WrapOptions struct {
	// X Left edge of input in output
	X int
	// Y Top edge of input in output
	Y int
}

// DefaultWrapOptions creates default value for vips_wrap optional arguments
func DefaultWrapOptions() *WrapOptions {
	return &WrapOptions{
	}
}

// Wrap vips_wrap wrap image origin
func (r *Image) Wrap(options *WrapOptions) (error) {
	if options != nil {
		out, err := vipsgenWrapWithOptions(r.image, options.X, options.Y)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenWrap(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}


// Zoom vips_zoom zoom an image
//
// The xfac specifies horizontal zoom factor.
// The yfac specifies vertical zoom factor.
func (r *Image) Zoom(xfac int, yfac int) (error) {
	out, err := vipsgenZoom(r.image, xfac, yfac)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}



// ProfileLoad vips_profile_load load named ICC profile
//
// The name specifies profile name.
func ProfileLoad(name string) ([]byte, error) {
	Startup(nil)
	return vipsgenProfileLoad(name)
}


// LoadOptions are options for loading an image. Some are type-specific.
type LoadOptions struct {
	// N Number of pages to load, -1 for all
	N int
	// Page First page to load
	Page int
	// Dpi Resolution in DPI
	Dpi int
	// Autorotate Rotate image using exif orientation
	Autorotate bool
	// FailOnError Fail on first error
	FailOnError bool
	// Shrink Shrink factor for jpeg load
	Shrink int
	// Thumbnail Load the thumbnail instead of main image (for HEIF)
	Thumbnail bool
	// Unlimited Allow without size restrictions
	Unlimited bool
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
}

// DefaultLoadOptions creates default LoadOptions
func DefaultLoadOptions() *LoadOptions {
	return &LoadOptions{
		FailOnError: true,
	}
}

// OptionString convert import params to option_string
func (i *LoadOptions) OptionString() string {
	var values []string
	if v := i.N; v != 0 {
		values = append(values, "n="+strconv.Itoa(v))
	}
	if v := i.Page; v != 0 {
		values = append(values, "page="+strconv.Itoa(v))
	}
	if v := i.Dpi; v != 0 {
		values = append(values, "dpi="+strconv.Itoa(v))
	}
	if v := i.FailOnError; v {
		values = append(values, "fail="+boolToStr(v))
	}
	if v := i.Shrink; v != 0 {
		values = append(values, "shrink="+strconv.Itoa(v))
	}
	if v := i.Autorotate; v {
		values = append(values, "autorotate="+boolToStr(v))
	}
	if v := i.Unlimited; v {
		values = append(values, "unlimited="+boolToStr(v))
	}
	if v := i.Thumbnail; v {
		values = append(values, "thumbnail="+boolToStr(v))
	}
	if v := i.Memory; v {
		values = append(values, "memory="+boolToStr(v))
	}
	if access := i.Access; access != 0 {
		switch access {
		case AccessSequential:
			values = append(values, "access=sequential")
		case AccessRandom:
			values = append(values, "access=random")
		case AccessSequentialUnbuffered:
			values = append(values, "access=sequential-unbuffered")
		}
	}
	return strings.Join(values, ",")
}

// NewImageFromSource vips_image_new_from_source loads a Source and creates a new Image
func NewImageFromSource(s *Source, options *LoadOptions) (*Image, error) {
	Startup(nil)
	if options == nil {
		options = DefaultLoadOptions()
	}
	vipsImage, err := vipsgenImageFromSource(s.src, options)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, vipsDetermineImageType(vipsImage), nil), nil
}

// NewImageFromBuffer vips_image_new_from_buffer loads an image buffer and creates a new Image
func NewImageFromBuffer(buf []byte, options *LoadOptions) (*Image, error) {
	Startup(nil)
	if options == nil {
		options = DefaultLoadOptions()
	}
	vipsImage, err := vipsgenImageFromBuffer(buf, options)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, vipsDetermineImageType(vipsImage), buf), nil
}

// NewImageFromFile vips_image_new_from_file loads an image from file and creates a new Image
func NewImageFromFile(file string, options *LoadOptions) (*Image, error) {
	Startup(nil)
	if options == nil {
		options = DefaultLoadOptions()
	}
	vipsImage, err := vipsgenImageFromFile(file, options)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, vipsDetermineImageType(vipsImage), nil), nil
}

// NewImageFromMemory vips_image_new_from_memory loads a raw RGB/RGBA image buffer and creates a new Image
func NewImageFromMemory(buf []byte, width, height, bands int) (*Image, error) {
	Startup(nil)
	vipsImage, err := vipsgenImageFromMemory(buf, width, height, bands)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, buf), nil
}


func newImageRef(vipsImage *C.VipsImage, format ImageType, buf []byte) *Image {
	imageRef := &Image{
		image:  vipsImage,
		format: format,
		buf:    buf,
	}
	log("vipsgen", LogLevelDebug, fmt.Sprintf("created imageRef %p", imageRef))
	return imageRef
}

// setImage resets the image for this image and frees the previous one
func (r *Image) setImage(image *C.VipsImage) {
	r.lock.Lock()
	defer r.lock.Unlock()
	if r.image == image {
		return
	}
	if r.image != nil {
		clearImage(r.image)
	}
	r.image = image
	r.pageHeight = 0
}

// Close closes the image and frees the memory
func (r *Image) Close() {
	if r == nil {
		return
	}
	r.lock.Lock()
	if r.image != nil {
		clearImage(r.image)
		r.image = nil
		log("vipsgen", LogLevelDebug, fmt.Sprintf("closing image %p", r))
	}
	r.buf = nil
	r.lock.Unlock()
}

// Format returns the initial format of the vips image when loaded.
func (r *Image) Format() ImageType {
	return r.format
}

// Width returns the width of this image.
func (r *Image) Width() int {
	return int(r.image.Xsize)
}

// Height returns the height of this image.
func (r *Image) Height() int {
	return int(r.image.Ysize)
}

// Bands returns the number of bands for this image.
func (r *Image) Bands() int {
	return int(r.image.Bands)
}

// ResX returns the X resolution
func (r *Image) ResX() float64 {
	return float64(r.image.Xres)
}

// ResY returns the Y resolution
func (r *Image) ResY() float64 {
	return float64(r.image.Yres)
}

// OffsetX returns the X offset
func (r *Image) OffsetX() int {
	return int(r.image.Xoffset)
}

// OffsetY returns the Y offset
func (r *Image) OffsetY() int {
	return int(r.image.Yoffset)
}

// BandFormat returns the current band format
func (r *Image) BandFormat() BandFormat {
	return BandFormat(int(r.image.BandFmt))
}

// Coding returns the image coding
func (r *Image) Coding() Coding {
	return Coding(int(r.image.Coding))
}

// Interpretation returns the current interpretation of the color space of the image.
func (r *Image) Interpretation() Interpretation {
	return Interpretation(int(r.image.Type))
}

// IsColorSpaceSupported returns a boolean whether the image's color space is supported by libvips.
func (r *Image) IsColorSpaceSupported() bool {
	return vipsIsColorSpaceSupported(r.image)
}

// HasAlpha returns if the image has an alpha layer.
func (r *Image) HasAlpha() bool {
	return vipsHasAlpha(r.image)
}

// HasICCProfile checks whether the image has an ICC profile embedded.
func (r *Image) HasICCProfile() bool {
	return vipsHasICCProfile(r.image)
}

// HasIPTC returns a boolean whether the image in question has IPTC data associated with it.
func (r *Image) HasIPTC() bool {
	return vipsHasIPTC(r.image)
}

// Orientation returns the orientation number as it appears in the Exif, if present
func (r *Image) Orientation() int {
	return vipsGetMetaOrientation(r.image)
}

// GetFields vips_image_get_fields returns a list of all metadata field names in the image
func (r *Image) GetFields() []string {
	return vipsImageGetFields(r.image)
}

// HasField vips_image_get_typeof checks if the image has a metadata field with the given name
func (r *Image) HasField(name string) bool {
    return vipsImageHasField(r.image, name)
}

// GetBlob vips_image_get_blob retrieves binary metadata from the image by field name
func (r *Image) GetBlob(name string) ([]byte, error) {
	return vipsImageGetBlob(r.image, name)
}

// SetDouble vips_image_set_double sets a double-precision floating point metadata value
func (r *Image) SetDouble(name string, f float64) {
	vipsImageSetDouble(r.image, name, f)
}

// GetDouble vips_image_get_double retrieves a double-precision floating point metadata value
func (r *Image) GetDouble(name string) (float64, error) {
	return vipsImageGetDouble(r.image, name)
}

// SetInt vips_image_set_int sets an integer metadata value
func (r *Image) SetInt(name string, i int) {
	vipsImageSetInt(r.image, name, i)
}

// GetInt vips_image_get_int retrieves an integer metadata value
func (r *Image) GetInt(name string) (int, error) {
	return vipsImageGetInt(r.image, name)
}

// SetString vips_image_set_string sets a string metadata value
func (r *Image) SetString(name string, str string) {
	vipsImageSetString(r.image, name, str)
}

// GetString vips_image_get_string retrieves a string metadata value
func (r *Image) GetString(name string) (string, error) {
	return vipsImageGetString(r.image, name)
}

// GetAsString vips_image_get_as_string retrieves any metadata value converted to string format
func (r *Image) GetAsString(name string) (string, error) {
	return vipsImageGetAsString(r.image, name)
}

// GetArrayDouble vips_image_get_array_double retrieves a double array metadata value
func (r *Image) GetArrayDouble(name string) ([]float64, error) {
	return vipsImageGetArrayDouble(r.image, name)
}

// GetArrayInt vips_image_get_array_int retrieves an integer array metadata value
func (r *Image) GetArrayInt(name string) ([]int, error) {
	return vipsImageGetArrayInt(r.image, name)
}

// Exif extracts all EXIF metadata from the image and returns it as a map of field names to string values
func (r *Image) Exif() map[string]string {
	fields := vipsImageGetFields(r.image)
	exifData := map[string]string{}
	for _, field := range fields {
		if strings.HasPrefix(field, "exif") {
			if val, err := vipsImageGetString(r.image, field); err == nil {
				exifData[field] = val
			}
		}
	}
	return exifData
}

// SetOrientation sets the orientation in the EXIF header of the associated image.
func (r *Image) SetOrientation(orientation int) error {
	out, err := vipsgenCopy(r.image)
	if err != nil {
		return err
	}
	vipsSetMetaOrientation(out, orientation)
	r.setImage(out)
	return nil
}

// RemoveOrientation removes the EXIF orientation information of the image.
func (r *Image) RemoveOrientation() error {
	out, err := vipsgenCopy(r.image)
	if err != nil {
		return err
	}
	vipsRemoveMetaOrientation(out)
	r.setImage(out)
	return nil
}

// Pages returns the number of pages in the Image
// For animated images this corresponds to the number of frames
func (r *Image) Pages() int {
	
	// libvips uses the same attribute (n_pages) to represent the number of pyramid layers in JP2K
	// as we interpret the attribute as frames and JP2K does not support animation we override this with 1
	if r.format == ImageTypeJp2k {
		return 1
	}
	
	return vipsGetImageNPages(r.image)
}


// SetPages sets the number of pages in the Image
// For animated images this corresponds to the number of frames
func (r *Image) SetPages(pages int) error {
	out, err := vipsgenCopy(r.image)
	if err != nil {
		return err
	}
	vipsSetImageNPages(out, pages)
	r.setImage(out)
	return nil
}

// PageHeight return the height of a single page
func (r *Image) PageHeight() int {
	if r.pageHeight == 0 {
		r.pageHeight = vipsGetPageHeight(r.image)
	}
	return r.pageHeight
}

// SetPageHeight set the height of a page
// For animated images this is used when "unrolling" back to frames
func (r *Image) SetPageHeight(height int) error {
	vipsSetPageHeight(r.image, height)
	r.pageHeight = height
	return nil
}

// Background get the background of image.
func (r *Image) Background() ([]float64, error) {
	return vipsImageGetArrayDouble(r.image, "background")
}

// PageDelay gets the page delay array for animation
func (r *Image) PageDelay() ([]int, error) {
	return vipsImageGetArrayInt(r.image, "delay")
}

// GetICCProfile retrieves the ICC profile data (if any) from the image.
func (r *Image) GetICCProfile() ([]byte, bool) {
	return vipsGetICCProfile(r.image)
}

// RemoveICCProfile removes the ICC Profile information from the image.
// Typically, browsers and other software assume images without profile to be in the sRGB color space.
func (r *Image) RemoveICCProfile() error {
	out, err := vipsgenCopy(r.image)
	if err != nil {
		return err
	}
	vipsRemoveICCProfile(out)
	r.setImage(out)
	return nil
}

// RemoveExif removes all metadata from the image (except ICC profile)
func (r *Image) RemoveExif() error {
	out, err := vipsgenRemoveExif(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// Modulate the colors
func (r *Image) Modulate(brightness, saturation, hue float64) error {
	var err error
	var multiplications []float64
	var additions []float64
	colorspace := r.Interpretation()
	if colorspace == InterpretationRgb {
		colorspace = InterpretationSrgb
	}
	multiplications = []float64{brightness, saturation, 1}
	additions = []float64{0, 0, hue}
	if r.HasAlpha() {
		multiplications = append(multiplications, 1)
		additions = append(additions, 0)
	}
	err = r.Colourspace(InterpretationLch, nil)
	if err != nil {
		return err
	}
	err = r.Linear(multiplications, additions, nil)
	if err != nil {
		return err
	}
	err = r.Colourspace(colorspace, nil)
	if err != nil {
		return err
	}
	return nil
}

// ModulateHSV modulates the image HSV values based on the supplier parameters.
func (r *Image) ModulateHSV(brightness, saturation float64, hue int) error {
	var err error
	var multiplications []float64
	var additions []float64
	colorspace := r.Interpretation()
	if colorspace == InterpretationRgb {
		colorspace = InterpretationSrgb
	}
	if r.HasAlpha() {
		multiplications = []float64{1, saturation, brightness, 1}
		additions = []float64{float64(hue), 0, 0, 0}
	} else {
		multiplications = []float64{1, saturation, brightness}
		additions = []float64{float64(hue), 0, 0}
	}
	err = r.Colourspace(InterpretationHsv, nil)
	if err != nil {
		return err
	}
	err = r.Linear(multiplications, additions, nil)
	if err != nil {
		return err
	}
	err = r.Colourspace(colorspace, nil)
	if err != nil {
		return err
	}
	return nil
}

// EmbedMultiPageOptions are options for EmbedMultiPage method
type EmbedMultiPageOptions struct {
	// Extend determines how the image edges are extended
	Extend Extend
	// Background color components [0-255]
	Background []float64
}

// DefaultEmbedMultiPageOptions creates default options for EmbedMultiPage
func DefaultEmbedMultiPageOptions() *EmbedMultiPageOptions {
	return &EmbedMultiPageOptions{
		Extend:     ExtendBlack,
		Background: []float64{},
	}
}

// EmbedMultiPage embeds the image in a larger image with the specified dimensions
// When the image has multiple pages (e.g. animated GIF), this embeds each frame
func (r *Image) EmbedMultiPage(left, top, width, height int, options *EmbedMultiPageOptions) error {
	if options == nil {
		options = DefaultEmbedMultiPageOptions()
	}
	
	if r.Height() == r.PageHeight() {
		out, err := vipsgenEmbedWithOptions(r.image, left, top, width, height, options.Extend, options.Background)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	
	if options.Extend == ExtendBackground {
		bg := []float64{0, 0, 0, 255}
		if len(options.Background) > 0 {
			for i := 0; i < len(options.Background) && i < 4; i++ {
				bg[i] = options.Background[i]
			}
		}
		out, err := vipsgenEmbedMultiPageBackground(
			r.image,
			left, top, width, height,
			int(bg[0]), int(bg[1]), int(bg[2]), int(bg[3]),
		)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsgenEmbedMultiPage(r.image, left, top, width, height, options.Extend)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// ExtractAreaMultiPage extracts a region from the image, working correctly with multi-page (animated) images
func (r *Image) ExtractAreaMultiPage(left, top, width, height int) error {
	
	if r.Height() == r.PageHeight() {
		out, err := vipsgenExtractArea(r.image, left, top, width, height)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	
	out, err := vipsgenExtractAreaMultiPage(r.image, left, top, width, height)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// RotMultiPage rotates an image by a multiple of 90 degrees, working correctly with multi-page (animated) images
func (r *Image) RotMultiPage(angle Angle) error {
	
	if r.Height() == r.PageHeight() {
		out, err := vipsgenRot(r.image, angle)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	
	out, err := vipsgenRotMultiPage(r.image, angle)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// LabelOptions are options for Label method
type LabelOptions struct {
	// Font name
	Font string
	// Text size
	Size int
	// Text alignment
	Align Align
	// Text color components [0-255]
	Color []float64
	// Text opacity (0-1)
	Opacity float64
}

// DefaultLabelOptions creates default options for Label
func DefaultLabelOptions() *LabelOptions {
	return &LabelOptions{
		Font:    "sans",
		Size:    12,
		Align:   AlignLow,
		Color:   []float64{0, 0, 0},
		Opacity: 1.0,
	}
}

// Label adds text to the image
func (r *Image) Label(text string, x, y int, options *LabelOptions) error {
	if options == nil {
		options = DefaultLabelOptions()
	}
	color := []float64{0, 0, 0}
	if options.Color != nil {
		for i := 0; i < len(options.Color) && i < 3; i++ {
			color[i] = options.Color[i]
		}
	}
	out, err := vipsgenLabel(r.image, text, options.Font,
		x, y, options.Size, options.Align,
		int(color[0]), int(color[1]), int(color[2]),
		options.Opacity,
	)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}
